<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Yuanjun&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Yuanjun&#039;s Blog"><meta name="msapplication-TileImage" content="/img/logo.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Yuanjun&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Yuanjun&#039;s Blog"><meta property="og:url" content="https://wtffqbpl.github.io/"><meta property="og:site_name" content="Yuanjun&#039;s Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://wtffqbpl.github.io/img/og_image.png"><meta property="article:author" content="Yuanjun Ren"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://wtffqbpl.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wtffqbpl.github.io"},"headline":"Yuanjun's Blog","image":["https://wtffqbpl.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Yuanjun Ren"},"publisher":{"@type":"Organization","name":"Yuanjun's Blog","logo":{"@type":"ImageObject","url":"https://wtffqbpl.github.io/img/logo.png"}},"description":""}</script><link rel="icon" href="/img/logo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Yuanjun&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wtffqbpl/wtffqbpl.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-06T14:40:06.000Z" title="11/6/2022, 10:40:06 PM">2022-11-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-11-06T14:43:03.089Z" title="11/6/2022, 10:43:03 PM">2022-11-06</time></span><span class="level-item">a few seconds read (About 12 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/11/06/LLVM-Series/">LLVM Series</a></h1><div class="content"><h1 id="LLVM-Series"><a href="#LLVM-Series" class="headerlink" title="LLVM Series"></a>LLVM Series</h1><ul>
<li><input disabled="" type="checkbox"> Callgraph</li>
<li><input disabled="" type="checkbox"> LibCall Creation</li>
<li><input disabled="" type="checkbox"> Calling Clang to compile a source codes.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-06T10:19:30.000Z" title="11/6/2022, 6:19:30 PM">2022-11-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-11-06T14:41:08.756Z" title="11/6/2022, 10:41:08 PM">2022-11-06</time></span><span class="level-item">27 minutes read (About 4029 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/11/06/Template-Metaprogramming-Type-Traits/">Template Metaprogramming---Type Traits</a></h1><div class="content"><h1 id="The-Aims"><a href="#The-Aims" class="headerlink" title="The Aims"></a>The Aims</h1><ul>
<li>How to implement and how to use</li>
<li>Exploration of the standard set of type traits<ul>
<li>Focus on techniques for implementing type traits</li>
</ul>
</li>
<li>Remove some of the mystique that still surrounds template metaprogramming.</li>
<li>Practical advice from a regular user.</li>
<li>So you can more readily use the standard set and implement your own when<br>needed.</li>
</ul>
<h1 id="What-is-Meta-Programming"><a href="#What-is-Meta-Programming" class="headerlink" title="What is Meta-Programming"></a>What is Meta-Programming</h1><ul>
<li>In general, when programs treat programs as data</li>
<li>Could be other programs or itself</li>
<li>Could be at “compile time” or “run time”</li>
<li>We will discuss compile time metaprogramming in C++</li>
<li>Wide array of current techniques, but still considered a niche</li>
<li>This two-part tutorial helps shed light on a very few essential ideoms</li>
</ul>
<h1 id="Why-Care-About-Metaprogramming-and-type-traits-in-particular"><a href="#Why-Care-About-Metaprogramming-and-type-traits-in-particular" class="headerlink" title="Why Care About Metaprogramming (and type traits in particular)"></a>Why Care About Metaprogramming (and type traits in particular)</h1><ul>
<li>Each new standard library employs more metaprogramming techniques</li>
<li>Some requirements are impossible without advanced techniques(e.g., std::optional)</li>
<li>Many third party libraries, not just Boost</li>
<li>Tools and idioms have become well developed, no longer black magic, limited to STL and Boost.</li>
<li>All C++ programmers should understand the basics.</li>
<li>Any library developer should understand a good bit more</li>
<li>C++20 - concepts and independent requires expressions</li>
</ul>
<p>It’s kind of a paradigm shift, there are a lot of things that make metaprogramming more look like<br>regular functional programming.</p>
<h1 id="Meta-Functions"><a href="#Meta-Functions" class="headerlink" title="Meta-Functions"></a>Meta-Functions</h1><ul>
<li>A meta-function is not a function but a class&#x2F;struct</li>
<li>Meta-functions are not part of the language and have no formal language support</li>
<li>They exist as an idiomatic use of existing language features</li>
<li>Their use is not enforced by the language</li>
<li>Their use is dictated by convention</li>
<li>C++ community has created common “standard” conventions</li>
</ul>
<h2 id="The-Definition-of-meta-function"><a href="#The-Definition-of-meta-function" class="headerlink" title="The Definition of meta-function"></a>The Definition of meta-function</h2><ul>
<li>Technically, a class with zero+ template parameters and zero+ return types and values</li>
<li>Convention is that a meta-function should return one thing, like a regular function</li>
<li>Convention was developed over time, so plenty of existing examples that do not follow this convention</li>
<li>More modern meta-functions do follow this convention</li>
</ul>
<h2 id="Return-From-a-Meta-Function"><a href="#Return-From-a-Meta-Function" class="headerlink" title="Return From a Meta-Function"></a>Return From a Meta-Function</h2><ul>
<li>Expose a public value “value”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TheAnswer</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Expose a public type “type”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Echo</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Meta-functions yield back some types to you.</p>
<h3 id="Value-Meta-functions"><a href="#Value-Meta-functions" class="headerlink" title="Value Meta-functions"></a>Value Meta-functions</h3><ul>
<li>Simple regular function: identity</li>
</ul>
<p>This is a very simple regular function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">int_identity</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; reutrn x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(<span class="number">42</span> == <span class="built_in">int_identity</span>(<span class="number">42</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>The Simple Meta-Function: identity</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> X&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IntIdentity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = X;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == IntIdentity&lt;<span class="number">42</span>&gt;::value)</span><br></pre></td></tr></table></figure>

<ul>
<li>Generic Identity Function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">identity</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returned type will be int</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="number">42</span> == <span class="built_in">identity</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returned type will be unsigned long long</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="number">42ull</span> == <span class="built_in">identity</span>(<span class="number">42ull</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>Generic Identity Meta-Function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ValueIdentity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> T value = Value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of value will be int</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == ValueIdentity&lt;<span class="type">int</span>, <span class="number">42</span>&gt;::value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of value will be unsigned long long</span></span><br><span class="line"><span class="built_in">static_assert</span>(ValueIdentity&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, <span class="number">42ull</span>&gt;::value == <span class="number">42ull</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Generic Identity Meta-Function (C++17)</li>
</ul>
<p>Template accepts non-type template parameter since C++17.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> X&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ValueIdentity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = X;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of value will be int</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == ValueIdentity&lt;<span class="number">42</span>&gt;::value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of value will be unsigned long long</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42ull</span> == ValueIdentity&lt;<span class="number">42ull</span>&gt;::value);</span><br></pre></td></tr></table></figure>

<ul>
<li>Two forms of Sum Function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">sum</span><span class="params">(X x, Y y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return type will be unsigned long long</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="number">42ull</span> == <span class="built_in">sum</span>(<span class="number">30</span>, <span class="number">12ull</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// It takes two separate non-type template parameters</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> X, <span class="keyword">auto</span> Y&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = X + Y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return type will be unsigned long long</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42ull</span> == Sum&lt;<span class="number">30</span>, <span class="number">12ull</span>&gt;::value);</span><br></pre></td></tr></table></figure>

<h3 id="Type-Meta-Functions"><a href="#Type-Meta-Functions" class="headerlink" title="Type Meta-Functions"></a>Type Meta-Functions</h3><ul>
<li>Type meta-functions just like a workhorse (especially will the advent of constexpr) which manipulate<br>types.</li>
<li>“Returns” a type.</li>
</ul>
<p>This is a type meta-function demo</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentity</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br></pre></td></tr></table></figure>

<p>C++20 introduces std::type_identity</p>
<h3 id="Calling-Type-Meta-Functions"><a href="#Calling-Type-Meta-Functions" class="headerlink" title="Calling Type Meta-Functions"></a>Calling Type Meta-Functions</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ValueIdentity&lt;<span class="number">42</span>&gt;::value;</span><br><span class="line">TypeIdentity&lt;<span class="type">int</span>&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Typename Dance</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> TypeIdentity&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<h3 id="Convenience-Calling-Conventions"><a href="#Convenience-Calling-Conventions" class="headerlink" title="Convenience Calling Conventions"></a>Convenience Calling Conventions</h3><ul>
<li>Value meta-functions use variable templates ending with “_v”.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> X&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ValueIdentity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = X;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// variable template</span></span><br><span class="line"><span class="comment">// This is a convenient way to call a value meta-functions using variable template.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> X&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> ValueIdentity_v = ValueIdentity&lt;X&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == ValueIdentity&lt;<span class="number">42</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == ValueIdentity_v&lt;<span class="number">42</span>&gt;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Type Meta-Functions use alias templates ending with “_t”. <code>Typename Dance</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TypeIdentity_t = <span class="keyword">typename</span> TypeIdentity&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="type">int</span>, TypeIdentity_t&lt;<span class="type">int</span>&gt;&gt;);</span><br></pre></td></tr></table></figure>

<p>These calling conventions are easier to use. But each one must be explicitly handwritten.</p>
<ul>
<li>A meta-convention to get around that which I may get to if time for bonus material.</li>
</ul>
<h1 id="Type-Traits"><a href="#Type-Traits" class="headerlink" title="Type Traits"></a>Type Traits</h1><h2 id="Some-Useful-Meta-Functions"><a href="#Some-Useful-Meta-Functions" class="headerlink" title="Some Useful Meta-Functions"></a>Some Useful Meta-Functions</h2><h3 id="std-integral-constant"><a href="#std-integral-constant" class="headerlink" title="std::integral_constant"></a>std::integral_constant</h3><p>A very useful meta-function. It allows us to wrap a constant with its type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, T v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> T value = v;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> value_type  = T;</span><br><span class="line">  <span class="keyword">using</span> type        = integral_constant&lt;T, v&gt;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">  <span class="comment">// this is a functor, a call operator.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="std-bool-constant"><a href="#std-bool-constant" class="headerlink" title="std::bool_constant"></a>std::bool_constant</h3><p>This is Convenient helpers.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> B&gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="type">bool</span>, B&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias templates</span></span><br><span class="line"><span class="keyword">using</span> true_type = bool_constant&lt;<span class="literal">true</span>&gt;; <span class="comment">// this is equivalent to integral_constant&lt;bool, true&gt;.</span></span><br><span class="line"><span class="keyword">using</span> false_type = bool_constant&lt;<span class="literal">false</span>&gt;; <span class="comment">// this is equivalent to integral_constant&lt;bool, false&gt;.</span></span><br></pre></td></tr></table></figure>

<p><code>true_type</code> and <code>false_type</code> are going to be meta-functions. They are called nullary meta-functions<br>because they have no parameters.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true_type::value;</span><br><span class="line">false_type::value;</span><br></pre></td></tr></table></figure>

<h1 id="Standard-Type-Trait-Requirements"><a href="#Standard-Type-Trait-Requirements" class="headerlink" title="Standard Type Trait Requirements"></a>Standard Type Trait Requirements</h1><h2 id="Cpp17-Unary-Type-Trait"><a href="#Cpp17-Unary-Type-Trait" class="headerlink" title="Cpp17 Unary Type Trait"></a>Cpp17 Unary Type Trait</h2><p>Cpp20 introduces very different meta-programming techniques.</p>
<p>For a unary type trait in the standard library which is what we’re got which is what we are talking<br>about. Unary type trait in the standard library it has a class template of one template type<br>argument</p>
<p>Cpp17UnaryTypeTrait</p>
<ul>
<li>Class Template</li>
<li>One template type argument*</li>
<li>Cpp17DefaultConstructible</li>
<li>Cpp17CopyConstructible</li>
<li>Publicly and unambiguously derived from a specialization of <code>std::integral_constant</code>.<br>All the unary type traits have to derive from <code>integral_constant</code>.</li>
<li>The member names of the base characteristic shall not be hidden and shall be unambiguously available<br>Basically, this means if you inherit from it you can’t hide any of that stuff, you got to let all<br>that stuff be available publicly.</li>
</ul>
<h2 id="Cpp17BinaryTypeTrait"><a href="#Cpp17BinaryTypeTrait" class="headerlink" title="Cpp17BinaryTypeTrait"></a>Cpp17BinaryTypeTrait</h2><p>This is an exactly same thing with <code>Cpp17UnaryTypeTrait</code> except Cpp17BinaryTypeTrait has two<br>template type argument*.</p>
<h2 id="Cpp17TransformationTrait"><a href="#Cpp17TransformationTrait" class="headerlink" title="Cpp17TransformationTrait"></a>Cpp17TransformationTrait</h2><ul>
<li>Class Template</li>
<li>One template type argument*</li>
<li>Define a publicly asccessible nested type name <code>type</code>.</li>
<li>No default&#x2F;copy constructible requirement</li>
<li>No inheritance requirement</li>
</ul>
<h1 id="Specialization"><a href="#Specialization" class="headerlink" title="Specialization"></a>Specialization</h1><h2 id="is-void-Unary-Type-Trait"><a href="#is-void-Unary-Type-Trait" class="headerlink" title="is_void (Unary Type Trait)"></a>is_void (Unary Type Trait)</h2><ul>
<li>Value meta-function: is the type void? yields true_type or false_type</li>
</ul>
<p>Specialization</p>
<ul>
<li><p>Primary template: general case</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span> : std::false_type &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Specialization: special case(s)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The empty angle brackets mean it&#x27;s an explicit full specialization,</span></span><br><span class="line"><span class="comment">// and then we take the type that we are specializing for. And we put</span></span><br><span class="line"><span class="comment">// it in right place.</span></span><br><span class="line"><span class="comment">// In this case, we are going to return true and so these static_assert.</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(is_void&lt;<span class="type">void</span>&gt;&#123;&#125;);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">not</span> is_void&lt;<span class="type">int</span>&gt;&#123;&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Why does is void reutrn true type false type instead of true false values?</p>
</li>
</ul>
<p>The reason because it is a meta-function returning the true type(the actual type of it).<br>First of all, the <code>is_void</code> is inherited from <code>integral_constant</code>. <code>false_type</code> is just integral<br>constant bool false. <code>true_type</code> is just <code>integral_constant</code> bool true. The standard says that<br>unary meta-functions must inherit from one of those.<br>And the reason because if all we did was just return a true value where is a </p>
<p><code>is_void</code> is inherit from a <code>true_type</code>, and <code>true_type</code> is already having a type.</p>
<p><code>static_assert(is_void&lt;void&gt;&#123;&#125;</code>, the curly bracket, that is instantiating one of those things and it<br>implicit conversion operator to turn it into a true.</p>
<ul>
<li>Is <code>void const</code> void?</li>
<li>Is <code>void volatile</code> void?</li>
<li><code>is_void</code> is in primary type categories.</li>
</ul>
<p>Yes, the standard says <code>void</code> &amp; <code>void const</code> &amp; <code>void volatile</code> &amp; <code>void const volatile</code> are all <code>void</code>.</p>
<p><code>cv</code> stands for <code>const volatile</code></p>
<p>For any given type T, the result of applying one of these templates to T and to cv T shall yield<br>the same result.</p>
<p><strong>The definition of <code>is_void</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The primary template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_void</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// specialization for void.</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="comment">// specialization for void const</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span> <span class="type">const</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="comment">// specialization for void volatile</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="comment">// specialization for void const volatile</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_void</span> &lt;<span class="type">void</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The standard mandates this as well.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_void_v = is_void&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="remove-const-Transformation-Trait"><a href="#remove-const-Transformation-Trait" class="headerlink" title="remove_const (Transformation Trait)"></a>remove_const (Transformation Trait)</h2><p>There are three type traits: unary traits&#x2F;binary traits&#x2F;transformation traits. <code>remove_const</code> is<br>a transformation traits. transformation traits are what they call they are type meta-functions.</p>
<ul>
<li>Formal Definition<blockquote>
<p>The member typedef type names the same type as T except that any top-level const-qualifier has<br>been removed.</p>
</blockquote>
</li>
</ul>
<p>The <code>top-level</code> qualifier, like volatile&#x2F;const which are attached to the type itself. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">remove_const&lt;int&gt; -&gt; int</span><br><span class="line">remove_const&lt;const int&gt; -&gt; int</span><br><span class="line">remove_const&lt;const volatile int&gt; -&gt; volatile int</span><br><span class="line"></span><br><span class="line">remove_const&lt;int *&gt; -&gt; int *</span><br><span class="line"></span><br><span class="line">remove_const&lt;cont int *&gt; -&gt; const int * // this because pointer to a constant,</span><br><span class="line">                                        // it is not a const pointer.</span><br><span class="line"></span><br><span class="line">remove_const&lt;int const * const&gt; -&gt; int const *</span><br><span class="line">remove_const&lt;int * const&gt; -&gt; int *</span><br></pre></td></tr></table></figure>

<ul>
<li>The definition of <code>remove_const</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentity</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// primary template, do nothing if no const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span> : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial specialization, when detect const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;T <span class="type">const</span>&gt; : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standar mandated convenience alias</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">rmeove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Contains <code>const</code> so the partial specialization will match.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;T <span class="type">const</span>&gt; : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>The const is explicitly matched so the part remaining to match with the “T” is int volatile</p>
<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>This is basically think of it as like an if statement in regular programming. Some conditions it<br>returns T, else return F.</p>
<p>In this you can read it, if the bool condition is true, return T, else return F.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentitiy</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This partial specialization means condition is true, then returns T.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Condition,  <span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span> : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This partial specialization means condition is false, then conditional returns F.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span>&lt;<span class="literal">false</span>, T, F&gt; : TypeIdentity&lt;F&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(is_same_v&lt;<span class="type">int</span>, <span class="type">conditional_t</span>&lt;is_void&lt;<span class="type">void</span>&gt;::value, <span class="type">int</span>, <span class="type">long</span>&gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(is_same_v&lt;<span class="type">long</span>, <span class="type">conditional_t</span>&lt;is_void&lt;<span class="type">char</span>&gt;::value, <span class="type">int</span>, <span class="type">long</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>Not all the type traits can be implemented by c++, the compiler has way more information about<br>the type system and about what’s going on than it is exposed to the programmer through the<br>language.</p>
<p>Type traits can be implemented by intrinsics, and compiler can be more efficient for intrinsics<br>processing.</p>
<p><code>is_union</code> should be supported by compiler.</p>
<h1 id="Primary-Type-Categories"><a href="#Primary-Type-Categories" class="headerlink" title="Primary Type Categories"></a>Primary Type Categories</h1><p>There are 14 primary type categories.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">is_void             is_class</span><br><span class="line">is_null_pointer     is_function</span><br><span class="line">is_integral         is_pointer</span><br><span class="line">is_floating_point   is_lvalue_reference</span><br><span class="line">is_array            is_rvalue_reference</span><br><span class="line">is_enum             is_member_object_pointer</span><br><span class="line">is_union            is_member_function_pointer</span><br></pre></td></tr></table></figure>

<ul>
<li>All are to have base characteristic of either <code>true_type</code> or <code>false_type</code>.</li>
<li>All should yield the same result in light of cv(const volatile) qualifiers.</li>
</ul>
<h2 id="is-null-pointer"><a href="#is-null-pointer" class="headerlink" title="is_null_pointer"></a>is_null_pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_null_pointer</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_null_pointer</span>&lt;std::<span class="type">nullptr_t</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_null_pointer</span>&lt;std::<span class="type">nullptr_t</span> <span class="type">const</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_null_pointer</span>&lt;std::<span class="type">nullptr_t</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_null_pointer</span>&lt;std::<span class="type">nullptr_t</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The standard mandates this as well...</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_null_pointer_v = is_null_pointer&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="is-floating-point"><a href="#is-floating-point" class="headerlink" title="is_floating_point"></a>is_floating_point</h2><p><code>float</code>&#x2F;<code>double</code>&#x2F;<code>long double</code></p>
<p>requires 12 specializations.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// float type</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span> <span class="type">const</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double type</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span> <span class="type">const</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long double type</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">long</span> <span class="type">double</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">long</span> <span class="type">double</span> <span class="type">const</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">long</span> <span class="type">double</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">long</span> <span class="type">double</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for convenience use</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_floating_point_v = is_floating_point&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="is-integral"><a href="#is-integral" class="headerlink" title="is_integral"></a>is_integral</h2><ul>
<li>Five standard signed integer types: <code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code>, <code>long long int</code>.</li>
<li>Implementation defined extended signed integer types.</li>
<li>Corresponding, but different, unsigned integer types.</li>
<li>char, char8_t, char16_t, char32_t, wchar_t.</li>
<li>bool</li>
<li>Requires 16 * 4 &#x3D; 54 specializations.</li>
</ul>
<h1 id="Meta-Function-Abstractions"><a href="#Meta-Function-Abstractions" class="headerlink" title="Meta-Function Abstractions"></a>Meta-Function Abstractions</h1><ul>
<li>We would have reached for this long before now with regular&#x2F;normal programming.</li>
<li>Treat meta-function programming like regular programming because, well, that’s what it is.</li>
<li>Step back to the land of regular functions.</li>
<li>Pretend we needed to implement these same ideas with strings instead of types.</li>
</ul>
<p>The regular type of <code>is_void</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_void</span><span class="params">(std::string_view s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="string">&quot;void&quot;</span></span><br><span class="line">    ||   s == <span class="string">&quot;void const&quot;</span></span><br><span class="line">    ||   s == <span class="string">&quot;void volatile&quot;</span></span><br><span class="line">    ||   s == <span class="string">&quot;void const volatile&quot;</span></span><br><span class="line">    ||   s == <span class="string">&quot;void volatile const&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A new version of type traits(A Step in the right direction)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string_view <span class="title">remove_cv</span><span class="params">(std::string_view)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_void</span><span class="params">(std::string_view s)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">remove_cv</span>(s) == <span class="string">&quot;void&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_null_pointer</span><span class="params">(std::string_view s)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">remove_cv</span>(s) == <span class="string">&quot;std::nullptr_t&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_floating_point</span><span class="params">(std::string_view input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> s = <span class="built_in">remove_cv</span>(input);</span><br><span class="line">  <span class="keyword">return</span> s == <span class="string">&quot;float&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;double&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;long double&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string_view <span class="title">strip_signed</span><span class="params">(std::string_view)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_integral</span><span class="params">(std::string_view input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> s = <span class="built_in">strip_signed</span>(<span class="built_in">remove_cv</span>(input));</span><br><span class="line">  <span class="keyword">return</span> s == <span class="string">&quot;bool&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;char8_t&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;char16_t&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;char32_t&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;wchar_t&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;char&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;short&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;int&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;long&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;long long&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We already have <code>remove_const</code>, we also need <code>remove_volatile</code>, compose them to get <code>remove_cv</code>.</p>
<h2 id="remove-volatile"><a href="#remove-volatile" class="headerlink" title="remove_volatile"></a>remove_volatile</h2><ul>
<li>Formal Definition<blockquote>
<p>The member typedef type names the same type as T except that any top-level volatile-qualifier has<br>been remove.</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentity</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Primary template, do nothing if no volatile</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_volatile</span> : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial specialization, when detect volatile</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">strut remove_volatile&lt;T <span class="keyword">volatile</span>&gt; : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard mandated convenience alias.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_volatile_t</span> = <span class="keyword">typename</span> remove_volatile&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<h2 id="remove-cv"><a href="#remove-cv" class="headerlink" title="remove_cv"></a>remove_cv</h2><ul>
<li>Formal Definition<blockquote>
<p>The member typedef type names the same type as T except that any top-level cv-qualifier has<br>been removed.</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">// using remove_cv = remove_const&lt;typename remove_volatile&lt;T&gt;::type&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// alias template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> remove_cv = remove_const&lt;<span class="type">remove_volatile_t</span>&lt;T&gt;&gt;;</span><br><span class="line"><span class="comment">// remove_volatile_t&lt;T&gt; is the same thing with typename remove_volatile&lt;T&gt;::type.</span></span><br><span class="line"><span class="comment">// Here we don&#x27;t use remove_const_t, this because we want remove_cv to be a meta-function.</span></span><br><span class="line"><span class="comment">// If we use remove_const_t, remove_cv is just a type either meta-function.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_cv_t</span> = <span class="keyword">typename</span> remove_cv&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Eg. <code>remove_cv&lt;int const volatile&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Removing volatile, then const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> remove_cv = remove_const&lt;<span class="type">remove_volatile_t</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove_cv&lt;int const volatile&gt;</span></span><br><span class="line"><span class="comment">// remove_const&lt;remove_volatile_t&lt;int const volatile&gt;&gt;</span></span><br><span class="line"><span class="comment">// remove_const&lt;typename remove_volatile&lt;int const volatile&gt;::type&gt;</span></span><br><span class="line"><span class="comment">// remove_const&lt;int const&gt;</span></span><br></pre></td></tr></table></figure>

<p>Eg. <code>remove_ct_t&lt;int const volatile&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_cv_t</span> = <span class="keyword">typename</span> remove_cv&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove_cv_t&lt;int const volatile&gt;</span></span><br><span class="line"><span class="comment">// typename remove_cv&lt;int const volatile&gt;::type</span></span><br><span class="line"><span class="comment">// typename remove_const&lt;int const&gt;::type</span></span><br><span class="line"><span class="comment">// int</span></span><br></pre></td></tr></table></figure>

<h2 id="is-same"><a href="#is-same" class="headerlink" title="is_same"></a>is_same</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">strut is_same : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial specialization --- when they are both the same.</span></span><br><span class="line"><span class="comment">// angle brackets</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_same</span>&lt;T, T&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="comment">// When T1 and T2 are same, then is_same matches this partial</span></span><br><span class="line"><span class="comment">// specialization version. Otherwise, is_same matches the</span></span><br><span class="line"><span class="comment">// false_type version. Compiler only choose the best match version.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_same_v = is_same&lt;T1, T2&gt;::value;</span><br></pre></td></tr></table></figure>

<p><strong>Examples</strong></p>
<ul>
<li><code>static_assert(not is_same_v&lt;int, unsigned&gt;)</code></li>
</ul>
<p>T1 &#x3D; int, T2 &#x3D; unsigned, primary template matches. No way to make T to match<br>specialization.</p>
<ul>
<li><code>static_assert(is_same_v&lt;int, int&gt;)</code></li>
</ul>
<p>T1 &#x3D; int, T2 &#x3D; int, primary template matches, T &#x3D; int – specialization matches</p>
<h2 id="is-same-raw"><a href="#is-same-raw" class="headerlink" title="is_same_raw"></a>is_same_raw</h2><p>This is not standard type traits, but it is kind of useful. Take two types, and remove each<br>cv qualifiers and then compares them. If the two types are the same after removing these<br>cv qualifiers, then I’m treat them the same. So this might be helpful considering that<br>all of our type traits want us to remove both the const and the volatile qualifiers.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> is_same_raw = is_same&lt;<span class="type">remove_cv_t</span>&lt;T1&gt;, <span class="type">remove_cv_t</span>&lt;T2&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_same_raw_v = is_same_raw&lt;T1, T2&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="is-floating-point-redux"><a href="#is-floating-point-redux" class="headerlink" title="is_floating_point: redux"></a>is_floating_point: redux</h2><p>This is using alias template.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_floating_point = std::bool_constant&lt;</span><br><span class="line">        is_same_raw_v&lt;<span class="type">float</span>,       T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">double</span>,      T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">long</span> <span class="type">double</span>, T&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="is-integral-redux"><a href="#is-integral-redux" class="headerlink" title="is_integral: redux"></a>is_integral: redux</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_integral = std::bool_constant&lt;</span><br><span class="line">        is_same_raw_v&lt;<span class="type">bool</span>,               T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">char</span>,               T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">char8_t</span>,            T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">char16_t</span>,           T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">char32_t</span>,           T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">wchar_t</span>,            T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">signed</span> <span class="type">char</span>,        T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">short</span>,              T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">int</span>,                T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">long</span>,               T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">long</span> <span class="type">long</span>,          T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">char</span>,      T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">short</span>,     T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">int</span>,       T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">long</span>,      T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, T&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>It might be implemented using parameter pack.</p>
<p><code>is_type_in_pack</code> is a meta-function, it takes a type and ti take a list of bunch of other types.<br>Adn <code>is_type_in_pack</code> will biscally returned true if that type was anywhere in that list.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">using</span> is_type_in_pack = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_integral = is_type_inpack&lt;<span class="type">remove_cv_t</span>&lt;T&gt;,</span><br><span class="line">    <span class="type">bool</span>,</span><br><span class="line">    <span class="type">char</span>, <span class="type">char8_t</span>, <span class="type">char16_t</span>, <span class="type">char32_t</span>, <span class="type">wchar_t</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span>, <span class="type">unsigned</span> <span class="type">char</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span>, <span class="type">unsigned</span> <span class="type">short</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="is-array"><a href="#is-array" class="headerlink" title="is_array"></a>is_array</h2><p>The definition of <code>is_array</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_array</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inbounded array</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_arrya</span> &lt;T[N]&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unbounded array</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_array</span>&lt;T[]&gt; : std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>Some examples.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(is_array,<span class="type">int</span>[<span class="number">5</span>]&gt;);</span><br><span class="line"><span class="comment">// T = int[5] - primary template matches</span></span><br><span class="line"><span class="comment">// T = int, N = 5 - first specialization matches</span></span><br><span class="line"><span class="comment">// no way to form T to match second sepcialization</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(is_array&lt;<span class="type">int</span>[]&gt;);</span><br><span class="line"><span class="comment">// T = int[] == primary template matches</span></span><br></pre></td></tr></table></figure>

<h2 id="is-pointer"><a href="#is-pointer" class="headerlink" title="is_pointer"></a>is_pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="comment">// Primary template - most things are not pointers</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer_impl</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When we have a pointer</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer_impl</span>&lt;T *&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// alias template </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_pointer = detail::is_pointer_impl&lt;<span class="type">remove_cv_t</span>&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="is-union"><a href="#is-union" class="headerlink" title="is_union"></a>is_union</h2><p>This meta-function is actually impossible to implement without support from the compiler. Both clang<br>and gcc provide this particular compiler intrinsic to determine if a type is a union.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_union = std::bool_constant&lt;__is_union(T)&gt;;</span><br></pre></td></tr></table></figure>


<h2 id="is-class-or-union"><a href="#is-class-or-union" class="headerlink" title="is_class_or_union"></a>is_class_or_union</h2><p>What do we know about unions and classes that is unique to those two types?</p>
<ul>
<li>They can have members.</li>
<li>Devise a way to detect if a type can have a member.</li>
<li>How can you tell if a class has a member?</li>
<li>The syntax for a pointer-to-member is valid for any class, even without any members.</li>
</ul>
<p>Eg.</p>
<p><code>int*</code> is a valid pointer type, but does not have to point to anything. meta-programming is aimed to<br>deal with types, not the data.</p>
<ul>
<li>int Foo::* is a member pointer type, does not have to point to anything.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An empty struct, with no members of any kind</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BarIntObjectMemPtr is an alias for a type that is a pointer to a member of class Bar, where the</span></span><br><span class="line"><span class="comment">// member is an int.</span></span><br><span class="line"><span class="keyword">using</span> BarintObjectMemPtr = <span class="type">int</span> Bar::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This, however, generates a hard compiler error</span></span><br><span class="line">usign LongIntObjectMemPtr = ing <span class="type">long</span>::*;</span><br></pre></td></tr></table></figure>

<h1 id="Funciton-Overload-Resolution"><a href="#Funciton-Overload-Resolution" class="headerlink" title="Funciton Overload Resolution"></a>Funciton Overload Resolution</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="function">std::true_type <span class="title">is_nullptr</span><span class="params">(std::<span class="type">nullptr_t</span>)</span></span>;</span><br><span class="line"><span class="comment">// ... it will match anything. But it is the least priority. It will only ever be used if nothing</span></span><br><span class="line"><span class="comment">// else matches. It&#x27;ll only be used if it&#x27;s the only one that matches.</span></span><br><span class="line"><span class="function">std::false_type <span class="title">is_nullptr</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_null_pointer = <span class="keyword">decltype</span>(detail::<span class="built_in">is_nullptr</span>(std::<span class="built_in">devlval</span>&lt;T&gt;()));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">not</span> is_null_pointer&lt;<span class="type">int</span>&gt;::value);</span><br><span class="line"><span class="comment">// This only match the second one.</span></span><br><span class="line"><span class="built_in">static_assert</span>(is_null_pointer&lt;std::<span class="type">nullptr_t</span>&gt;::value);</span><br><span class="line"><span class="comment">// This can match two versions of `is_nullptr`, but overload resolution will choose the first one, </span></span><br><span class="line"><span class="comment">// because the first one is the best match.</span></span><br></pre></td></tr></table></figure>

<p>Another case.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentity</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::true_type <span class="title">isconst</span><span class="params">(TypeIdentity&lt;T <span class="type">const</span>&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::false_type <span class="title">isconst</span><span class="params">(TypeIdentity&lt;T&gt;)</span></span>;</span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_const = <span class="keyword">decltype</span>(detail::<span class="built_in">isconst</span>(std::declval&lt;TypeIdentity&lt;T&gt;&gt;()));</span><br></pre></td></tr></table></figure>

<p>This uses technique called <code>Tag Dispatch</code>. <code>Tag Dispatch</code> is where we are creating a type that is<br>just being used as a tag.</p>
<p><code>TypeIdentity</code> takes no space, and it is very efficient to pass these guys around.</p>
<h1 id="SFINAE-Substitution-Failure-Is-Not-An-Error"><a href="#SFINAE-Substitution-Failure-Is-Not-An-Error" class="headerlink" title="SFINAE (Substitution Failure Is Not An Error)"></a>SFINAE (Substitution Failure Is Not An Error)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::true_type <span class="title">can_have_pointer_to_member</span><span class="params">(<span class="type">int</span> T::*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::false_type <span class="title">can_have_pointer_to_member</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="is-class"><a href="#is-class" class="headerlink" title="is_class"></a>is_class</h2><p>Almost always implemented as compiler intrinsic. Because compiler is much faster dealing with<br>intrinsics than dealing with even the simplest template stuff. Without the support of compiler, it<br>is kind of impossible to distinguish between union and non-union class type.</p>
<p>We have <code>is_union</code> (with help from the compiler)</p>
<ul>
<li>The definition is:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::bool_constant&lt;<span class="keyword">not</span> std::is_union_v&lt;T&gt;&gt;</span><br><span class="line"><span class="built_in">is_class_or_union</span>(<span class="type">int</span> T::*);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We only want to use the return type of `is_class_or_union` function. So we don&#x27;t need to</span></span><br><span class="line"><span class="comment">// create implementation for this function.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::false_type <span class="title">is_class_or_union</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_class = <span class="keyword">decltype</span>(detail::<span class="built_in">is_class_or_union</span>&lt;T&gt;(<span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>Implement <code>is_class</code> using <code>constexpr</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_class_or_union</span><span class="params">(<span class="type">int</span> T::*)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">not</span> std::is_union&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_class_or_union</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_class = std::bool_constant&lt;detail::<span class="built_in">is_class_or_union</span>&lt;T&gt;(<span class="literal">nullptr</span>)&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_const = <span class="keyword">decltype</span>(detail::<span class="built_in">isconst</span>(std::declval&lt;TypeIdentity&lt;T&gt;&gt;()));</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>decltype</strong> — tells you to pretend that compiler will evaluate this expression, and give me the<br>result the type that you would get from the evaluated expression.</li>
<li><strong>declval</strong> — is there so you can grab a reference to any type. It just gives you a reference<br>to something as if you had created one as if you had one. So it just declaration, it’s there’s no<br>implementation.</li>
</ul>
<h2 id="is-in-pack"><a href="#is-in-pack" class="headerlink" title="is_in_pack"></a>is_in_pack</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Template declaration, with no definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInPack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base case --- no more elements</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInPack</span>&lt;TargetT&gt; : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NOTES: is_in_pack uses partial specialization to match the two same types.</span></span><br><span class="line"><span class="comment">// If the first one matches the target, we are done.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInpack</span>&lt;TargetT, TargetT, Ts...&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise, check the remaining ones.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInpack</span>&lt;TargetT, T, Ts...&gt; : IsInPack&lt;Target, Ts...&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>Examples</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(IsInPack&lt;<span class="type">int</span>, <span class="type">double</span>,<span class="type">char</span>,<span class="type">int</span>,<span class="type">float</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">not</span> IsInPack&lt;<span class="type">long</span>, <span class="type">double</span>,<span class="type">char</span>,<span class="type">int</span>,<span class="type">float</span>&gt;::value);</span><br></pre></td></tr></table></figure>

<p>The version of using <code>is_base_of</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentitiy</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInPackImpl</span> : TypeIdentity&lt;Ts&gt;... &#123;&#125;;</span><br><span class="line"></span><br><span class="line">tmeplate &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">using</span> IsInpack = std::is_base_of&lt;</span><br><span class="line">    TypeIdentity&lt;TargetT&gt;,</span><br><span class="line">    detail::IsInPackImpl&lt;Ts...&gt;&gt;;</span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br></pre></td></tr></table></figure>

<p>Examples</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(IsInPack&lt;<span class="type">int</span>, <span class="type">double</span>,<span class="type">char</span>,<span class="type">int</span>,<span class="type">float</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">not</span> IsInPack&lt;<span class="type">long</span>, <span class="type">double</span>,<span class="type">char</span>,<span class="type">int</span>,<span class="type">float</span>&gt;::value);</span><br></pre></td></tr></table></figure>

<h2 id="is-base-of"><a href="#is-base-of" class="headerlink" title="is_base_of"></a>is_base_of</h2><p>If Derived is derived from Base or if both are the same non-union class (in both cases<br>cv-qualification), provides the member constant value equal to <code>true</code>. Otherwise value is <code>false</code>.</p>
<p>The possible definition of <code>is_base_of</code> is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function">std::true_type <span class="title">test_pre_ptr_convertible</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> B*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="function">std::false_type <span class="title">test_pre_ptr_convertible</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test_pre_is_base_of</span><span class="params">(...)</span> -&gt; std::true_type</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> B, <span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test_pre_is_base_of</span><span class="params">(<span class="type">int</span>)</span> -&gt;</span></span><br><span class="line"><span class="function">  <span class="title">decltype</span><span class="params">(test_pre_ptr_convertible&lt;B&gt;(<span class="keyword">static_cast</span>&lt;D*&gt;(<span class="literal">nullptr</span>)))</span></span>;</span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Base, <span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_base_of</span> :</span><br><span class="line">    std::integral_constant&lt;</span><br><span class="line">        <span class="type">bool</span>,</span><br><span class="line">        std::is_class&lt;Base&gt;::value &amp;&amp; std::is_class&lt;Derived&gt;::<span class="function">value &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">decltype</span><span class="params">(details::test_pre_is_base_of&lt;Base, Derived&gt;(<span class="number">0</span>))</span>::value</span></span><br><span class="line"><span class="function">    &gt; </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Learning-materials"><a href="#Learning-materials" class="headerlink" title="Learning materials."></a>Learning materials.</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=tiAVWcjIF6o">Template Metaprogramming: Type Traits Part I</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dLZcocFOb5Q">Template Metaprogramming: Type Traits Part II</a></li>
</ul>
<ul>
<li>Modern Template Metaprogramming: A Compendium, Part I, Walter E. Brown,<br> CppCon 2014,<br>Link: <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Am2is2QCvxY">Part  I</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=a0FliKwcwXE">Part II</a></li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/maybez/maybe/blob/master/Books/C%2B%2B/Modern%20C%2B%2B%20Design/Modern%20C%2B%2B%20Design_ENG.pdf">Modern C++ Design</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ghjang/cpp_practical_tmp_study">About C++ Template Metaprogramming</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Template-Metaprogramming-with-CPP">Template Metaprogramming with C++</a></li>
<li><a target="_blank" rel="noopener" href="https://hrjiang.github.io/fopl/13_templates-generics.pdf">Generic programming in OO Languages</a></li>
<li><a target="_blank" rel="noopener" href="https://ptgmedia.pearsoncmg.com/images/9780137647842/samplepages/9780137647842_Sample.pdf">30 Core Guidelines for Writting Clean, Safe, and Fast Code</a></li>
<li><a target="_blank" rel="noopener" href="https://2018.cppconf-piter.ru/talks/day-2/track-a/1.pdf">Reflective Metaprogramming in C++</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qmickecs/article/details/70574506">Tag Dispatching</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-30T16:01:50.000Z" title="10/31/2022, 12:01:50 AM">2022-10-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-31T09:15:36.878Z" title="10/31/2022, 5:15:36 PM">2022-10-31</time></span><span class="level-item">3 minutes read (About 425 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/31/CMAKE-Multiple-directories/">CMAKE---Multiple directories</a></h1><div class="content"><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>CMake is a direcory-based project management tool. If your project has multiple directories, more <code>CMakeLists.txt</code> files should be created in your project directories.</p>
<h1 id="Situation"><a href="#Situation" class="headerlink" title="Situation"></a>Situation</h1><p>As the following directories, each directory is a standalone module. For example:</p>
<ol>
<li>the root target has its own source file(s) in <code>$&#123;ROOT&#125;/src</code> directory.</li>
<li><code>hello_object_lib</code> is a <code>OBJECT</code> target, and it has its own including paths. So we use a CMakeLists.txt file for target management.</li>
<li><code>hello_shared_lib</code> is a <code>SHARED</code> library target, the root project will link this shared library or provide for other projects.</li>
<li><code>hello_static_lib</code> is a <code>STATIC</code> library target, this target will generate a static library file for other projects.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── hello_object_lib</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── inc</span><br><span class="line">│   └── src</span><br><span class="line">│       └── main.cc</span><br><span class="line">├── hello_shared_lib</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── hello</span><br><span class="line">│   │       └── hello.hpp</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── hello.cc</span><br><span class="line">│       ├── internal.cc</span><br><span class="line">│       └── internal.hpp</span><br><span class="line">├── hello_static_lib</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── hello</span><br><span class="line">│   │       └── hello.hpp</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── hello.cc</span><br><span class="line">│       ├── internal.cc</span><br><span class="line">│       └── internal.hpp</span><br><span class="line">└── src</span><br><span class="line">    └── main.cc</span><br></pre></td></tr></table></figure>

<p>The content of root <code>CMakeLists.txt</code> is as follows. Each sub-directory should be added in this CMakeLists.txt.</p>
<p>In this CMakeLists.txt, we define a executable target <code>multiple_exec</code>, all of the other targets will be linked to this executable target. There’s a difference should be noticed. <code>OBJECT</code> target cannot be linked into other targets using <code>target_link_libraries</code> command before CMake V3.12. So if you use the older CMake version, you should use the </p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(multiple_dirs</span><br><span class="line">        VERSION <span class="number">1.0</span></span><br><span class="line">        DESCRIPTION <span class="string">&quot;Multiple directory project&quot;</span></span><br><span class="line">        LANGUAGES CXX</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add subdirectories with examples.</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(hello_object_lib)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(hello_shared_lib)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(hello_static_lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add an example executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(multiple_exec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add sources to the example executable</span></span><br><span class="line"><span class="keyword">target_sources</span>(multiple_exec PRIVATE src/main.cc)</span><br><span class="line"><span class="comment"># link libraries</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        multiple_exec</span><br><span class="line">        PRIVATE hello_object_target hello_shared_target hello_static_target)</span><br></pre></td></tr></table></figure>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/wtffqbpl/AdvancedCMake">My-Advanced-CMake-Repo</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-30T04:40:26.000Z" title="10/30/2022, 12:40:26 PM">2022-10-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-11-06T10:23:51.112Z" title="11/6/2022, 6:23:51 PM">2022-11-06</time></span><span class="level-item">4 minutes read (About 620 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/30/How-To-Use-Hexo/">How To Use Hexo</a></h1><div class="content"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The combination of Hexo + GithubPages is easy way to configure your own blog.  Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h1 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h1><h2 id="Create-a-Github-Repo"><a href="#Create-a-Github-Repo" class="headerlink" title="Create a Github Repo"></a>Create a Github Repo</h2><p>You should create a repo for your blog, and the repo name must be <code>&lt;username&gt;.github.io</code>.</p>
<h2 id="Init-Hexo"><a href="#Init-Hexo" class="headerlink" title="Init Hexo"></a>Init Hexo</h2><p>Then, navigate to <code>&lt;username&gt;.github.io</code> directory, run the following command to init Hexo blog.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd &lt;username&gt;.github.io</span></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h2 id="Install-Dependencies"><a href="#Install-Dependencies" class="headerlink" title="Install Dependencies"></a>Install Dependencies</h2><p>Finally, run the following command to finalize installing procedures.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h1 id="Hexo-Useful-Commands"><a href="#Hexo-Useful-Commands" class="headerlink" title="Hexo Useful Commands"></a>Hexo Useful Commands</h1><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><p>Enter &lt;username&gt;.github.io directory, and execute the following command for new page creation.  If you haven’t specify layout, hexo will use the default layout for new page creation. The default layout is configured in _config.yml file, the keyword is <code>default_layout</code>. For more info, please<br>see chapter <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo new [layout] &lt;title&gt;</span></span><br><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><p>If you want to preview your blog on your local machine, you can use following command to deploy your blog on your local machine.  For more info, please see chapter <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><p>Before you publish your blog to github pages, you should generate static files locally.  If you use the github pages’s theme, you only need to configure wanted theme in your <code>_config.yml</code> file, and github will gengerate all static files before deploying. For more info, please see chapter <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h2 id="Deploy-to-Remote-Sites"><a href="#Deploy-to-Remote-Sites" class="headerlink" title="Deploy to Remote Sites"></a>Deploy to Remote Sites</h2><p>After generating all static files, you can deploy your blog on github pages. This command would create a <code>master</code> branch in your blog repo. So your github pages should be based on <code>master</code> branch. You can change the github pages’ branch in <code>Settings-&gt;Pages-&gt;Branch</code>.</p>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/change_default_branch.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>For more info, please see chapter <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a>.</p>
<h1 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h1><h2 id="Install-Theme"><a href="#Install-Theme" class="headerlink" title="Install Theme"></a>Install Theme</h2><p>I’d like to use <code>hexo-theme-icarus</code> theme. User should execute the following commands to configure icarus theme.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-icarus">hexo-theme-icarus</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-theme-icarus</span><br><span class="line">hexo config theme icarus</span><br></pre></td></tr></table></figure>
<p>Hexo provides numerous themes, please see <a target="_blank" rel="noopener" href="https://hexo.io/themes/">Hexo-Themes</a> for more details.</p>
<h2 id="Change-Your-Personnel-Info"><a href="#Change-Your-Personnel-Info" class="headerlink" title="Change Your Personnel Info"></a>Change Your Personnel Info</h2><p>User should change the personnel info in <code>_config.icarus.yml</code> file.</p>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>All blog data are listed in <code>source/</code> directory. My <code>source</code> directory hierarchy is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">» tree source     </span><br><span class="line">source</span><br><span class="line">├── _posts</span><br><span class="line">│   ├── How-To-Use-Hexo.md</span><br><span class="line">│   └── hello-world.md</span><br><span class="line">└── img</span><br><span class="line">    ├── alipay-qrcode.jpg</span><br><span class="line">    ├── logo.png</span><br><span class="line">    ├── logo.svg</span><br><span class="line">    └── wechat-qrcode.jpg</span><br><span class="line"></span><br><span class="line">2 directories, 6 files</span><br></pre></td></tr></table></figure>

<p>If you want to change the default logo <code>logo.svg</code>, you should put your own <code>logo.svg</code> in <code>source/img/logo.svg</code>. Besides, Mac user can use <code>imagemagick</code> tool for png to svg conversion. For more details, you can see <a target="_blank" rel="noopener" href="https://www.imagemagick.org/script/index.php">imagemagick-homepage</a>.  After install <code>imagemagick</code> tool, you can execute the following commands to convert.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert logo.png logo.svg</span><br></pre></td></tr></table></figure>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a target="_blank" rel="noopener" href="https://ji2xpro.github.io/73d224e9/">PicGo-Configuration</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues/4757">Using-ssh-instead-of-http-in-config.yml-file</a></li>
<li><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo-Doc</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-30T03:54:54.768Z" title="10/30/2022, 11:54:54 AM">2022-10-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-30T03:54:54.768Z" title="10/30/2022, 11:54:54 AM">2022-10-30</time></span><span class="level-item">a minute read (About 123 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/30/hello-world/">Hello World</a></h1><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.jpg" alt="Yuanjun Ren"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yuanjun Ren</p><p class="is-size-6 is-block">C++ Programmer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an/China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wtffqbpl" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wtffqbpl"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/yuanjun-ren-5a7949bb"><i class="fab fa-linkedin"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CMake/"><span class="tag">CMake</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLVM/"><span class="tag">LLVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Meta-Programming/"><span class="tag">Meta-Programming</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-06T14:40:06.000Z">2022-11-06</time></p><p class="title"><a href="/2022/11/06/LLVM-Series/">LLVM Series</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-06T10:19:30.000Z">2022-11-06</time></p><p class="title"><a href="/2022/11/06/Template-Metaprogramming-Type-Traits/">Template Metaprogramming---Type Traits</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-30T16:01:50.000Z">2022-10-31</time></p><p class="title"><a href="/2022/10/31/CMAKE-Multiple-directories/">CMAKE---Multiple directories</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-30T04:40:26.000Z">2022-10-30</time></p><p class="title"><a href="/2022/10/30/How-To-Use-Hexo/">How To Use Hexo</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-30T03:54:54.768Z">2022-10-30</time></p><p class="title"><a href="/2022/10/30/hello-world/">Hello World</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Yuanjun&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Yuanjun Ren</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wtffqbpl/wtffqbpl.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>