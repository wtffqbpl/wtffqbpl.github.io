<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Template Metaprogramming---Type Traits - Yuanjun&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Yuanjun&#039;s Blog"><meta name="msapplication-TileImage" content="/img/logo.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Yuanjun&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="An overview notes about type_traits.h."><meta property="og:type" content="blog"><meta property="og:title" content="Template Metaprogramming---Type Traits"><meta property="og:url" content="https://wtffqbpl.github.io/2022/11/06/Template-Metaprogramming-Type-Traits/"><meta property="og:site_name" content="Yuanjun&#039;s Blog"><meta property="og:description" content="An overview notes about type_traits.h."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://wtffqbpl.github.io/img/cpp/cpp.png"><meta property="article:published_time" content="2022-11-06T10:19:30.000Z"><meta property="article:modified_time" content="2022-11-12T18:37:02.555Z"><meta property="article:author" content="Yuanjun Ren"><meta property="article:tag" content="C++"><meta property="article:tag" content="Meta-Programming"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://wtffqbpl.github.io/img/cpp/cpp.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wtffqbpl.github.io/2022/11/06/Template-Metaprogramming-Type-Traits/"},"headline":"Template Metaprogramming---Type Traits","image":["https://wtffqbpl.github.io/img/cpp/cpp.png"],"datePublished":"2022-11-06T10:19:30.000Z","dateModified":"2022-11-12T18:37:02.555Z","author":{"@type":"Person","name":"Yuanjun Ren"},"publisher":{"@type":"Organization","name":"Yuanjun's Blog","logo":{"@type":"ImageObject","url":"https://wtffqbpl.github.io/img/logo.png"}},"description":"An overview notes about type_traits.h."}</script><link rel="canonical" href="https://wtffqbpl.github.io/2022/11/06/Template-Metaprogramming-Type-Traits/"><link rel="icon" href="/img/logo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Yuanjun&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wtffqbpl/wtffqbpl.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/cpp/cpp.png" alt="Template Metaprogramming---Type Traits"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-06T10:19:30.000Z" title="11/6/2022, 6:19:30 PM">2022-11-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-11-12T18:37:02.555Z" title="11/13/2022, 2:37:02 AM">2022-11-13</time></span><span class="level-item">27 minutes read (About 4029 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Template Metaprogramming---Type Traits</h1><div class="content"><h1 id="The-Aims"><a href="#The-Aims" class="headerlink" title="The Aims"></a>The Aims</h1><ul>
<li>How to implement and how to use</li>
<li>Exploration of the standard set of type traits<ul>
<li>Focus on techniques for implementing type traits</li>
</ul>
</li>
<li>Remove some of the mystique that still surrounds template metaprogramming.</li>
<li>Practical advice from a regular user.</li>
<li>So you can more readily use the standard set and implement your own when<br>needed.</li>
</ul>
<h1 id="What-is-Meta-Programming"><a href="#What-is-Meta-Programming" class="headerlink" title="What is Meta-Programming"></a>What is Meta-Programming</h1><ul>
<li>In general, when programs treat programs as data</li>
<li>Could be other programs or itself</li>
<li>Could be at “compile time” or “run time”</li>
<li>We will discuss compile time metaprogramming in C++</li>
<li>Wide array of current techniques, but still considered a niche</li>
<li>This two-part tutorial helps shed light on a very few essential ideoms</li>
</ul>
<h1 id="Why-Care-About-Metaprogramming-and-type-traits-in-particular"><a href="#Why-Care-About-Metaprogramming-and-type-traits-in-particular" class="headerlink" title="Why Care About Metaprogramming (and type traits in particular)"></a>Why Care About Metaprogramming (and type traits in particular)</h1><ul>
<li>Each new standard library employs more metaprogramming techniques</li>
<li>Some requirements are impossible without advanced techniques(e.g., std::optional)</li>
<li>Many third party libraries, not just Boost</li>
<li>Tools and idioms have become well developed, no longer black magic, limited to STL and Boost.</li>
<li>All C++ programmers should understand the basics.</li>
<li>Any library developer should understand a good bit more</li>
<li>C++20 - concepts and independent requires expressions</li>
</ul>
<p>It’s kind of a paradigm shift, there are a lot of things that make metaprogramming more look like<br>regular functional programming.</p>
<h1 id="Meta-Functions"><a href="#Meta-Functions" class="headerlink" title="Meta-Functions"></a>Meta-Functions</h1><ul>
<li>A meta-function is not a function but a class&#x2F;struct</li>
<li>Meta-functions are not part of the language and have no formal language support</li>
<li>They exist as an idiomatic use of existing language features</li>
<li>Their use is not enforced by the language</li>
<li>Their use is dictated by convention</li>
<li>C++ community has created common “standard” conventions</li>
</ul>
<h2 id="The-Definition-of-meta-function"><a href="#The-Definition-of-meta-function" class="headerlink" title="The Definition of meta-function"></a>The Definition of meta-function</h2><ul>
<li>Technically, a class with zero+ template parameters and zero+ return types and values</li>
<li>Convention is that a meta-function should return one thing, like a regular function</li>
<li>Convention was developed over time, so plenty of existing examples that do not follow this convention</li>
<li>More modern meta-functions do follow this convention</li>
</ul>
<h2 id="Return-From-a-Meta-Function"><a href="#Return-From-a-Meta-Function" class="headerlink" title="Return From a Meta-Function"></a>Return From a Meta-Function</h2><ul>
<li>Expose a public value “value”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TheAnswer</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Expose a public type “type”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Echo</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Meta-functions yield back some types to you.</p>
<h3 id="Value-Meta-functions"><a href="#Value-Meta-functions" class="headerlink" title="Value Meta-functions"></a>Value Meta-functions</h3><ul>
<li>Simple regular function: identity</li>
</ul>
<p>This is a very simple regular function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">int_identity</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; reutrn x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(<span class="number">42</span> == <span class="built_in">int_identity</span>(<span class="number">42</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>The Simple Meta-Function: identity</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> X&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IntIdentity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = X;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == IntIdentity&lt;<span class="number">42</span>&gt;::value)</span><br></pre></td></tr></table></figure>

<ul>
<li>Generic Identity Function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">identity</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returned type will be int</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="number">42</span> == <span class="built_in">identity</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returned type will be unsigned long long</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="number">42ull</span> == <span class="built_in">identity</span>(<span class="number">42ull</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>Generic Identity Meta-Function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ValueIdentity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> T value = Value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of value will be int</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == ValueIdentity&lt;<span class="type">int</span>, <span class="number">42</span>&gt;::value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of value will be unsigned long long</span></span><br><span class="line"><span class="built_in">static_assert</span>(ValueIdentity&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, <span class="number">42ull</span>&gt;::value == <span class="number">42ull</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Generic Identity Meta-Function (C++17)</li>
</ul>
<p>Template accepts non-type template parameter since C++17.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> X&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ValueIdentity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = X;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of value will be int</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == ValueIdentity&lt;<span class="number">42</span>&gt;::value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The type of value will be unsigned long long</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42ull</span> == ValueIdentity&lt;<span class="number">42ull</span>&gt;::value);</span><br></pre></td></tr></table></figure>

<ul>
<li>Two forms of Sum Function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">sum</span><span class="params">(X x, Y y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return type will be unsigned long long</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="number">42ull</span> == <span class="built_in">sum</span>(<span class="number">30</span>, <span class="number">12ull</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// It takes two separate non-type template parameters</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> X, <span class="keyword">auto</span> Y&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = X + Y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return type will be unsigned long long</span></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42ull</span> == Sum&lt;<span class="number">30</span>, <span class="number">12ull</span>&gt;::value);</span><br></pre></td></tr></table></figure>

<h3 id="Type-Meta-Functions"><a href="#Type-Meta-Functions" class="headerlink" title="Type Meta-Functions"></a>Type Meta-Functions</h3><ul>
<li>Type meta-functions just like a workhorse (especially will the advent of constexpr) which manipulate<br>types.</li>
<li>“Returns” a type.</li>
</ul>
<p>This is a type meta-function demo</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentity</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br></pre></td></tr></table></figure>

<p>C++20 introduces std::type_identity</p>
<h3 id="Calling-Type-Meta-Functions"><a href="#Calling-Type-Meta-Functions" class="headerlink" title="Calling Type Meta-Functions"></a>Calling Type Meta-Functions</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ValueIdentity&lt;<span class="number">42</span>&gt;::value;</span><br><span class="line">TypeIdentity&lt;<span class="type">int</span>&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Typename Dance</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> TypeIdentity&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<h3 id="Convenience-Calling-Conventions"><a href="#Convenience-Calling-Conventions" class="headerlink" title="Convenience Calling Conventions"></a>Convenience Calling Conventions</h3><ul>
<li>Value meta-functions use variable templates ending with “_v”.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> X&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ValueIdentity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> value = X;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// variable template</span></span><br><span class="line"><span class="comment">// This is a convenient way to call a value meta-functions using</span></span><br><span class="line"><span class="comment">// variable template.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> X&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> ValueIdentity_v = ValueIdentity&lt;X&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == ValueIdentity&lt;<span class="number">42</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="number">42</span> == ValueIdentity_v&lt;<span class="number">42</span>&gt;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Type Meta-Functions use alias templates ending with “_t”. <code>Typename Dance</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TypeIdentity_t = <span class="keyword">typename</span> TypeIdentity&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="type">int</span>, TypeIdentity_t&lt;<span class="type">int</span>&gt;&gt;);</span><br></pre></td></tr></table></figure>

<p>These calling conventions are easier to use. But each one must be explicitly handwritten.</p>
<ul>
<li>A meta-convention to get around that which I may get to if time for bonus material.</li>
</ul>
<h1 id="Type-Traits"><a href="#Type-Traits" class="headerlink" title="Type Traits"></a>Type Traits</h1><h2 id="Some-Useful-Meta-Functions"><a href="#Some-Useful-Meta-Functions" class="headerlink" title="Some Useful Meta-Functions"></a>Some Useful Meta-Functions</h2><h3 id="std-integral-constant"><a href="#std-integral-constant" class="headerlink" title="std::integral_constant"></a>std::integral_constant</h3><p>A very useful meta-function. It allows us to wrap a constant with its type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, T v&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">integral_constant</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> T value = v;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> value_type  = T;</span><br><span class="line">  <span class="keyword">using</span> type        = integral_constant&lt;T, v&gt;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// this is a functor, a call operator.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="std-bool-constant"><a href="#std-bool-constant" class="headerlink" title="std::bool_constant"></a>std::bool_constant</h3><p>This is Convenient helpers.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> B&gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="type">bool</span>, B&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias templates</span></span><br><span class="line"><span class="comment">// this is equivalent to integral_constant&lt;bool, true&gt;.</span></span><br><span class="line"><span class="keyword">using</span> true_type = bool_constant&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="comment">// this is equivalent to integral_constant&lt;bool, false&gt;.</span></span><br><span class="line"><span class="keyword">using</span> false_type = bool_constant&lt;<span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><code>true_type</code> and <code>false_type</code> are going to be meta-functions. They are called nullary meta-functions<br>because they have no parameters.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true_type::value;</span><br><span class="line">false_type::value;</span><br></pre></td></tr></table></figure>

<h1 id="Standard-Type-Trait-Requirements"><a href="#Standard-Type-Trait-Requirements" class="headerlink" title="Standard Type Trait Requirements"></a>Standard Type Trait Requirements</h1><h2 id="Cpp17-Unary-Type-Trait"><a href="#Cpp17-Unary-Type-Trait" class="headerlink" title="Cpp17 Unary Type Trait"></a>Cpp17 Unary Type Trait</h2><p>Cpp20 introduces very different meta-programming techniques.</p>
<p>For a unary type trait in the standard library which is what we’re got which is what we are talking<br>about. Unary type trait in the standard library it has a class template of one template type<br>argument</p>
<p>Cpp17UnaryTypeTrait</p>
<ul>
<li>Class Template</li>
<li>One template type argument*</li>
<li>Cpp17DefaultConstructible</li>
<li>Cpp17CopyConstructible</li>
<li>Publicly and unambiguously derived from a specialization of <code>std::integral_constant</code>.<br>All the unary type traits have to derive from <code>integral_constant</code>.</li>
<li>The member names of the base characteristic shall not be hidden and shall be unambiguously available<br>Basically, this means if you inherit from it you can’t hide any of that stuff, you got to let all<br>that stuff be available publicly.</li>
</ul>
<h2 id="Cpp17BinaryTypeTrait"><a href="#Cpp17BinaryTypeTrait" class="headerlink" title="Cpp17BinaryTypeTrait"></a>Cpp17BinaryTypeTrait</h2><p>This is an exactly same thing with <code>Cpp17UnaryTypeTrait</code> except Cpp17BinaryTypeTrait has two<br>template type argument*.</p>
<h2 id="Cpp17TransformationTrait"><a href="#Cpp17TransformationTrait" class="headerlink" title="Cpp17TransformationTrait"></a>Cpp17TransformationTrait</h2><ul>
<li>Class Template</li>
<li>One template type argument*</li>
<li>Define a publicly asccessible nested type name <code>type</code>.</li>
<li>No default&#x2F;copy constructible requirement</li>
<li>No inheritance requirement</li>
</ul>
<h1 id="Specialization"><a href="#Specialization" class="headerlink" title="Specialization"></a>Specialization</h1><h2 id="is-void-Unary-Type-Trait"><a href="#is-void-Unary-Type-Trait" class="headerlink" title="is_void (Unary Type Trait)"></a>is_void (Unary Type Trait)</h2><ul>
<li>Value meta-function: is the type void? yields true_type or false_type</li>
</ul>
<p>Specialization</p>
<ul>
<li><p>Primary template: general case</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span> : std::false_type &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Specialization: special case(s)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The empty angle brackets mean it&#x27;s an explicit full</span></span><br><span class="line"><span class="comment">// specialization, and then we take the type that we</span></span><br><span class="line"><span class="comment">// are specializing for. And we put it in right place.</span></span><br><span class="line"><span class="comment">// In this case, we are going to return true and so</span></span><br><span class="line"><span class="comment">// these static_assert.</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(is_void&lt;<span class="type">void</span>&gt;&#123;&#125;);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">not</span> is_void&lt;<span class="type">int</span>&gt;&#123;&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Why does is void reutrn true type false type instead of true false values?</p>
</li>
</ul>
<p>The reason because it is a meta-function returning the true type(the actual type of it).<br>First of all, the <code>is_void</code> is inherited from <code>integral_constant</code>. <code>false_type</code> is just integral<br>constant bool false. <code>true_type</code> is just <code>integral_constant</code> bool true. The standard says that<br>unary meta-functions must inherit from one of those.<br>And the reason because if all we did was just return a true value where is a </p>
<p><code>is_void</code> is inherit from a <code>true_type</code>, and <code>true_type</code> is already having a type.</p>
<p><code>static_assert(is_void&lt;void&gt;&#123;&#125;</code>, the curly bracket, that is instantiating one of those things and it<br>implicit conversion operator to turn it into a true.</p>
<ul>
<li>Is <code>void const</code> void?</li>
<li>Is <code>void volatile</code> void?</li>
<li><code>is_void</code> is in primary type categories.</li>
</ul>
<p>Yes, the standard says <code>void</code> &amp; <code>void const</code> &amp; <code>void volatile</code> &amp; <code>void const volatile</code> are all <code>void</code>.</p>
<p><code>cv</code> stands for <code>const volatile</code></p>
<p>For any given type T, the result of applying one of these templates to T and to cv T shall yield<br>the same result.</p>
<p><strong>The definition of <code>is_void</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The primary template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_void</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// specialization for void.</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="comment">// specialization for void const</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span> <span class="type">const</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="comment">// specialization for void volatile</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="comment">// specialization for void const volatile</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span> &lt;<span class="type">void</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The standard mandates this as well.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_void_v = is_void&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="remove-const-Transformation-Trait"><a href="#remove-const-Transformation-Trait" class="headerlink" title="remove_const (Transformation Trait)"></a>remove_const (Transformation Trait)</h2><p>There are three type traits: unary traits&#x2F;binary traits&#x2F;transformation traits. <code>remove_const</code> is<br>a transformation traits. transformation traits are what they call they are type meta-functions.</p>
<ul>
<li>Formal Definition<blockquote>
<p>The member typedef type names the same type as T except that any top-level const-qualifier has<br>been removed.</p>
</blockquote>
</li>
</ul>
<p>The <code>top-level</code> qualifier, like volatile&#x2F;const which are attached to the type itself. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">remove_const&lt;int&gt; -&gt; int</span><br><span class="line">remove_const&lt;const int&gt; -&gt; int</span><br><span class="line">remove_const&lt;const volatile int&gt; -&gt; volatile int</span><br><span class="line"></span><br><span class="line">remove_const&lt;int *&gt; -&gt; int *</span><br><span class="line"></span><br><span class="line">remove_const&lt;cont int *&gt; -&gt; const int *</span><br><span class="line">// this because pointer to a constant,</span><br><span class="line">// it is not a const pointer.</span><br><span class="line"></span><br><span class="line">remove_const&lt;int const * const&gt; -&gt; int const *</span><br><span class="line">remove_const&lt;int * const&gt; -&gt; int *</span><br></pre></td></tr></table></figure>

<ul>
<li>The definition of <code>remove_const</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentity</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// primary template, do nothing if no const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span> : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial specialization, when detect const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;T <span class="type">const</span>&gt; : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standar mandated convenience alias</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">rmeove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Contains <code>const</code> so the partial specialization will match.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_const</span>&lt;T <span class="type">const</span>&gt; : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>The const is explicitly matched so the part remaining to match with the “T” is int volatile</p>
<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>This is basically think of it as like an if statement in regular programming. Some conditions it<br>returns T, else return F.</p>
<p>In this you can read it, if the bool condition is true, return T, else return F.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentitiy</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This partial specialization means condition is true,</span></span><br><span class="line"><span class="comment">// then returns T.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Condition,  <span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span> : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This partial specialization means condition is false,</span></span><br><span class="line"><span class="comment">// then conditional returns F.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span>&lt;<span class="literal">false</span>, T, F&gt; : TypeIdentity&lt;F&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(is_same_v&lt;<span class="type">int</span>, <span class="type">conditional_t</span>&lt;is_void&lt;<span class="type">void</span>&gt;::value,</span><br><span class="line">                                           <span class="type">int</span>, <span class="type">long</span>&gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(is_same_v&lt;<span class="type">long</span>, <span class="type">conditional_t</span>&lt;is_void&lt;<span class="type">char</span>&gt;::value,</span><br><span class="line">                                           <span class="type">int</span>, <span class="type">long</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>Not all the type traits can be implemented by c++, the compiler has way more information about<br>the type system and about what’s going on than it is exposed to the programmer through the<br>language.</p>
<p>Type traits can be implemented by intrinsics, and compiler can be more efficient for intrinsics<br>processing.</p>
<p><code>is_union</code> should be supported by compiler.</p>
<h1 id="Primary-Type-Categories"><a href="#Primary-Type-Categories" class="headerlink" title="Primary Type Categories"></a>Primary Type Categories</h1><p>There are 14 primary type categories.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">is_void             is_class</span><br><span class="line">is_null_pointer     is_function</span><br><span class="line">is_integral         is_pointer</span><br><span class="line">is_floating_point   is_lvalue_reference</span><br><span class="line">is_array            is_rvalue_reference</span><br><span class="line">is_enum             is_member_object_pointer</span><br><span class="line">is_union            is_member_function_pointer</span><br></pre></td></tr></table></figure>

<ul>
<li>All are to have base characteristic of either <code>true_type</code> or <code>false_type</code>.</li>
<li>All should yield the same result in light of cv(const volatile) qualifiers.</li>
</ul>
<h2 id="is-null-pointer"><a href="#is-null-pointer" class="headerlink" title="is_null_pointer"></a>is_null_pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_null_pointer</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_null_pointer</span>&lt;std::<span class="type">nullptr_t</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_null_pointer</span>&lt;std::<span class="type">nullptr_t</span> <span class="type">const</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_null_pointer</span>&lt;std::<span class="type">nullptr_t</span> <span class="keyword">volatile</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_null_pointer</span>&lt;std::<span class="type">nullptr_t</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The standard mandates this as well...</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_null_pointer_v = is_null_pointer&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="is-floating-point"><a href="#is-floating-point" class="headerlink" title="is_floating_point"></a>is_floating_point</h2><p><code>float</code>&#x2F;<code>double</code>&#x2F;<code>long double</code></p>
<p>requires 12 specializations.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_floating_point</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// float type</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span> <span class="type">const</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span> <span class="keyword">volatile</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double type</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span> <span class="type">const</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span> <span class="keyword">volatile</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">double</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long double type</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">long</span> <span class="type">double</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">long</span> <span class="type">double</span> <span class="type">const</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">long</span> <span class="type">double</span> <span class="keyword">volatile</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">long</span> <span class="type">double</span> <span class="type">const</span> <span class="keyword">volatile</span>&gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for convenience use</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_floating_point_v =</span><br><span class="line">    is_floating_point&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="is-integral"><a href="#is-integral" class="headerlink" title="is_integral"></a>is_integral</h2><ul>
<li>Five standard signed integer types: <code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code>, <code>long long int</code>.</li>
<li>Implementation defined extended signed integer types.</li>
<li>Corresponding, but different, unsigned integer types.</li>
<li>char, char8_t, char16_t, char32_t, wchar_t.</li>
<li>bool</li>
<li>Requires 16 * 4 &#x3D; 54 specializations.</li>
</ul>
<h1 id="Meta-Function-Abstractions"><a href="#Meta-Function-Abstractions" class="headerlink" title="Meta-Function Abstractions"></a>Meta-Function Abstractions</h1><ul>
<li>We would have reached for this long before now with regular&#x2F;normal programming.</li>
<li>Treat meta-function programming like regular programming because, well, that’s what it is.</li>
<li>Step back to the land of regular functions.</li>
<li>Pretend we needed to implement these same ideas with strings instead of types.</li>
</ul>
<p>The regular type of <code>is_void</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_void</span><span class="params">(std::string_view s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="string">&quot;void&quot;</span></span><br><span class="line">    ||   s == <span class="string">&quot;void const&quot;</span></span><br><span class="line">    ||   s == <span class="string">&quot;void volatile&quot;</span></span><br><span class="line">    ||   s == <span class="string">&quot;void const volatile&quot;</span></span><br><span class="line">    ||   s == <span class="string">&quot;void volatile const&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A new version of type traits(A Step in the right direction)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string_view <span class="title">remove_cv</span><span class="params">(std::string_view)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_void</span><span class="params">(std::string_view s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">remove_cv</span>(s) == <span class="string">&quot;void&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_null_pointer</span><span class="params">(std::string_view s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">remove_cv</span>(s) == <span class="string">&quot;std::nullptr_t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_floating_point</span><span class="params">(std::string_view input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> s = <span class="built_in">remove_cv</span>(input);</span><br><span class="line">  <span class="keyword">return</span> s == <span class="string">&quot;float&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;double&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;long double&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string_view <span class="title">strip_signed</span><span class="params">(std::string_view)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_integral</span><span class="params">(std::string_view input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> s = <span class="built_in">strip_signed</span>(<span class="built_in">remove_cv</span>(input));</span><br><span class="line">  <span class="keyword">return</span> s == <span class="string">&quot;bool&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;char8_t&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;char16_t&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;char32_t&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;wchar_t&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;char&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;short&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;int&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;long&quot;</span></span><br><span class="line">      || s == <span class="string">&quot;long long&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We already have <code>remove_const</code>, we also need <code>remove_volatile</code>, compose them to get <code>remove_cv</code>.</p>
<h2 id="remove-volatile"><a href="#remove-volatile" class="headerlink" title="remove_volatile"></a>remove_volatile</h2><ul>
<li>Formal Definition<blockquote>
<p>The member typedef type names the same type as T except that any top-level volatile-qualifier has<br>been remove.</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentity</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Primary template, do nothing if no volatile</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_volatile</span> : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial specialization, when detect volatile</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">strut remove_volatile&lt;T <span class="keyword">volatile</span>&gt; : TypeIdentity&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard mandated convenience alias.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_volatile_t</span> =</span><br><span class="line">    <span class="keyword">typename</span> remove_volatile&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<h2 id="remove-cv"><a href="#remove-cv" class="headerlink" title="remove_cv"></a>remove_cv</h2><ul>
<li>Formal Definition<blockquote>
<p>The member typedef type names the same type as T except that any top-level cv-qualifier has<br>been removed.</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">// using remove_cv = remove_const&lt;typename remove_volatile&lt;T&gt;::type&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// alias template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> remove_cv = remove_const&lt;<span class="type">remove_volatile_t</span>&lt;T&gt;&gt;;</span><br><span class="line"><span class="comment">// remove_volatile_t&lt;T&gt; is the same thing with typename</span></span><br><span class="line"><span class="comment">// remove_volatile&lt;T&gt;::type.</span></span><br><span class="line"><span class="comment">// Here we don&#x27;t use remove_const_t, this because we want</span></span><br><span class="line"><span class="comment">// remove_cv to be a meta-function.</span></span><br><span class="line"><span class="comment">// If we use remove_const_t, remove_cv is just a type either</span></span><br><span class="line"><span class="comment">// meta-function.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_cv_t</span> = <span class="keyword">typename</span> remove_cv&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Eg. <code>remove_cv&lt;int const volatile&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Removing volatile, then const</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> remove_cv = remove_const&lt;<span class="type">remove_volatile_t</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove_cv&lt;int const volatile&gt;</span></span><br><span class="line"><span class="comment">// remove_const&lt;remove_volatile_t&lt;int const volatile&gt;&gt;</span></span><br><span class="line"><span class="comment">// remove_const&lt;typename remove_volatile&lt;int const volatile&gt;::type&gt;</span></span><br><span class="line"><span class="comment">// remove_const&lt;int const&gt;</span></span><br></pre></td></tr></table></figure>

<p>Eg. <code>remove_ct_t&lt;int const volatile&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_cv_t</span> = <span class="keyword">typename</span> remove_cv&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove_cv_t&lt;int const volatile&gt;</span></span><br><span class="line"><span class="comment">// typename remove_cv&lt;int const volatile&gt;::type</span></span><br><span class="line"><span class="comment">// typename remove_const&lt;int const&gt;::type</span></span><br><span class="line"><span class="comment">// int</span></span><br></pre></td></tr></table></figure>

<h2 id="is-same"><a href="#is-same" class="headerlink" title="is_same"></a>is_same</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">strut is_same : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial specialization --- when they are both the same.</span></span><br><span class="line"><span class="comment">// angle brackets</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_same</span>&lt;T, T&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="comment">// When T1 and T2 are same, then is_same matches this partial</span></span><br><span class="line"><span class="comment">// specialization version. Otherwise, is_same matches the</span></span><br><span class="line"><span class="comment">// false_type version. Compiler only choose the best match version.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_same_v = is_same&lt;T1, T2&gt;::value;</span><br></pre></td></tr></table></figure>

<p><strong>Examples</strong></p>
<ul>
<li><code>static_assert(not is_same_v&lt;int, unsigned&gt;)</code></li>
</ul>
<p>T1 &#x3D; int, T2 &#x3D; unsigned, primary template matches. No way to make T to match<br>specialization.</p>
<ul>
<li><code>static_assert(is_same_v&lt;int, int&gt;)</code></li>
</ul>
<p>T1 &#x3D; int, T2 &#x3D; int, primary template matches, T &#x3D; int – specialization matches</p>
<h2 id="is-same-raw"><a href="#is-same-raw" class="headerlink" title="is_same_raw"></a>is_same_raw</h2><p>This is not standard type traits, but it is kind of useful. Take two types, and remove each<br>cv qualifiers and then compares them. If the two types are the same after removing these<br>cv qualifiers, then I’m treat them the same. So this might be helpful considering that<br>all of our type traits want us to remove both the const and the volatile qualifiers.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> is_same_raw = is_same&lt;<span class="type">remove_cv_t</span>&lt;T1&gt;, <span class="type">remove_cv_t</span>&lt;T2&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_same_raw_v = is_same_raw&lt;T1, T2&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="is-floating-point-redux"><a href="#is-floating-point-redux" class="headerlink" title="is_floating_point: redux"></a>is_floating_point: redux</h2><p>This is using alias template.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_floating_point = std::bool_constant&lt;</span><br><span class="line">        is_same_raw_v&lt;<span class="type">float</span>,       T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">double</span>,      T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">long</span> <span class="type">double</span>, T&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="is-integral-redux"><a href="#is-integral-redux" class="headerlink" title="is_integral: redux"></a>is_integral: redux</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_integral = std::bool_constant&lt;</span><br><span class="line">        is_same_raw_v&lt;<span class="type">bool</span>,               T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">char</span>,               T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">char8_t</span>,            T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">char16_t</span>,           T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">char32_t</span>,           T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">wchar_t</span>,            T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">signed</span> <span class="type">char</span>,        T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">short</span>,              T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">int</span>,                T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">long</span>,               T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">long</span> <span class="type">long</span>,          T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">char</span>,      T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">short</span>,     T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">int</span>,       T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">long</span>,      T&gt;</span><br><span class="line">     || is_same_raw_v&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, T&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>It might be implemented using parameter pack.</p>
<p><code>is_type_in_pack</code> is a meta-function, it takes a type and ti take a list of bunch of other types.<br>Adn <code>is_type_in_pack</code> will biscally returned true if that type was anywhere in that list.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">using</span> is_type_in_pack = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_integral = is_type_inpack&lt;<span class="type">remove_cv_t</span>&lt;T&gt;,</span><br><span class="line">    <span class="type">bool</span>,</span><br><span class="line">    <span class="type">char</span>, <span class="type">char8_t</span>, <span class="type">char16_t</span>, <span class="type">char32_t</span>, <span class="type">wchar_t</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span>, <span class="type">unsigned</span> <span class="type">char</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span>, <span class="type">unsigned</span> <span class="type">short</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="is-array"><a href="#is-array" class="headerlink" title="is_array"></a>is_array</h2><p>The definition of <code>is_array</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_array</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inbounded array</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_arrya</span> &lt;T[N]&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unbounded array</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_array</span>&lt;T[]&gt; : std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>Some examples.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(is_array,<span class="type">int</span>[<span class="number">5</span>]&gt;);</span><br><span class="line"><span class="comment">// T = int[5] - primary template matches</span></span><br><span class="line"><span class="comment">// T = int, N = 5 - first specialization matches</span></span><br><span class="line"><span class="comment">// no way to form T to match second sepcialization</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(is_array&lt;<span class="type">int</span>[]&gt;);</span><br><span class="line"><span class="comment">// T = int[] == primary template matches</span></span><br></pre></td></tr></table></figure>

<h2 id="is-pointer"><a href="#is-pointer" class="headerlink" title="is_pointer"></a>is_pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="comment">// Primary template - most things are not pointers</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer_impl</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When we have a pointer</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer_impl</span>&lt;T *&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// alias template </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_pointer = detail::is_pointer_impl&lt;<span class="type">remove_cv_t</span>&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="is-union"><a href="#is-union" class="headerlink" title="is_union"></a>is_union</h2><p>This meta-function is actually impossible to implement without support from the compiler. Both clang<br>and gcc provide this particular compiler intrinsic to determine if a type is a union.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_union = std::bool_constant&lt;__is_union(T)&gt;;</span><br></pre></td></tr></table></figure>


<h2 id="is-class-or-union"><a href="#is-class-or-union" class="headerlink" title="is_class_or_union"></a>is_class_or_union</h2><p>What do we know about unions and classes that is unique to those two types?</p>
<ul>
<li>They can have members.</li>
<li>Devise a way to detect if a type can have a member.</li>
<li>How can you tell if a class has a member?</li>
<li>The syntax for a pointer-to-member is valid for any class, even without any members.</li>
</ul>
<p>Eg.</p>
<p><code>int*</code> is a valid pointer type, but does not have to point to anything. meta-programming is aimed to<br>deal with types, not the data.</p>
<ul>
<li>int Foo::* is a member pointer type, does not have to point to anything.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An empty struct, with no members of any kind</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BarIntObjectMemPtr is an alias for a type that is a</span></span><br><span class="line"><span class="comment">// pointer to a member of class Bar, where the member</span></span><br><span class="line"><span class="comment">// is an int.</span></span><br><span class="line"><span class="keyword">using</span> BarintObjectMemPtr = <span class="type">int</span> Bar::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This, however, generates a hard compiler error</span></span><br><span class="line">usign LongIntObjectMemPtr = ing <span class="type">long</span>::*;</span><br></pre></td></tr></table></figure>

<h1 id="Funciton-Overload-Resolution"><a href="#Funciton-Overload-Resolution" class="headerlink" title="Funciton Overload Resolution"></a>Funciton Overload Resolution</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="function">std::true_type <span class="title">is_nullptr</span><span class="params">(std::<span class="type">nullptr_t</span>)</span></span>;</span><br><span class="line"><span class="comment">// ... it will match anything. But it is the least priority.</span></span><br><span class="line"><span class="comment">// It will only ever be used if nothing else matches. It&#x27;ll</span></span><br><span class="line"><span class="comment">// only be used if it&#x27;s the only one that matches.</span></span><br><span class="line"><span class="function">std::false_type <span class="title">is_nullptr</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_null_pointer =</span><br><span class="line">    <span class="keyword">decltype</span>(detail::<span class="built_in">is_nullptr</span>(std::<span class="built_in">devlval</span>&lt;T&gt;()));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">not</span> is_null_pointer&lt;<span class="type">int</span>&gt;::value);</span><br><span class="line"><span class="comment">// This only match the second one.</span></span><br><span class="line"><span class="built_in">static_assert</span>(is_null_pointer&lt;std::<span class="type">nullptr_t</span>&gt;::value);</span><br><span class="line"><span class="comment">// This can match two versions of `is_nullptr`, but overload</span></span><br><span class="line"><span class="comment">// resolution will choose the first one, because the first</span></span><br><span class="line"><span class="comment">// one is the best match.</span></span><br></pre></td></tr></table></figure>

<p>Another case.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentity</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::true_type <span class="title">isconst</span><span class="params">(TypeIdentity&lt;T <span class="type">const</span>&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::false_type <span class="title">isconst</span><span class="params">(TypeIdentity&lt;T&gt;)</span></span>;</span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_const =</span><br><span class="line">    <span class="keyword">decltype</span>(detail::<span class="built_in">isconst</span>(std::declval&lt;TypeIdentity&lt;T&gt;&gt;()));</span><br></pre></td></tr></table></figure>

<p>This uses technique called <code>Tag Dispatch</code>. <code>Tag Dispatch</code> is where we are creating a type that is<br>just being used as a tag.</p>
<p><code>TypeIdentity</code> takes no space, and it is very efficient to pass these guys around.</p>
<h1 id="SFINAE-Substitution-Failure-Is-Not-An-Error"><a href="#SFINAE-Substitution-Failure-Is-Not-An-Error" class="headerlink" title="SFINAE (Substitution Failure Is Not An Error)"></a>SFINAE (Substitution Failure Is Not An Error)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::true_type <span class="title">can_have_pointer_to_member</span><span class="params">(<span class="type">int</span> T::*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::false_type <span class="title">can_have_pointer_to_member</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="is-class"><a href="#is-class" class="headerlink" title="is_class"></a>is_class</h2><p>Almost always implemented as compiler intrinsic. Because compiler is much faster dealing with<br>intrinsics than dealing with even the simplest template stuff. Without the support of compiler, it<br>is kind of impossible to distinguish between union and non-union class type.</p>
<p>We have <code>is_union</code> (with help from the compiler)</p>
<ul>
<li>The definition is:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::bool_constant&lt;<span class="keyword">not</span> std::is_union_v&lt;T&gt;&gt;</span><br><span class="line"><span class="built_in">is_class_or_union</span>(<span class="type">int</span> T::*);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We only want to use the return type of `is_class_or_union`</span></span><br><span class="line"><span class="comment">// function. So we don&#x27;t need to create implementation for this</span></span><br><span class="line"><span class="comment">// function.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::false_type <span class="title">is_class_or_union</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_class = <span class="keyword">decltype</span>(detail::<span class="built_in">is_class_or_union</span>&lt;T&gt;(<span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>

<p>Implement <code>is_class</code> using <code>constexpr</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_class_or_union</span><span class="params">(<span class="type">int</span> T::*)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">not</span> std::is_union&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_class_or_union</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_class =</span><br><span class="line">    std::bool_constant&lt;detail::<span class="built_in">is_class_or_union</span>&lt;T&gt;(<span class="literal">nullptr</span>)&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> is_const =</span><br><span class="line">    <span class="keyword">decltype</span>(detail::<span class="built_in">isconst</span>(std::declval&lt;TypeIdentity&lt;T&gt;&gt;()));</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>decltype</strong> — tells you to pretend that compiler will evaluate this expression, and give me the<br>result the type that you would get from the evaluated expression.</li>
<li><strong>declval</strong> — is there so you can grab a reference to any type. It just gives you a reference<br>to something as if you had created one as if you had one. So it just declaration, it’s there’s no<br>implementation.</li>
</ul>
<h2 id="is-in-pack"><a href="#is-in-pack" class="headerlink" title="is_in_pack"></a>is_in_pack</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Template declaration, with no definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInPack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base case --- no more elements</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInPack</span>&lt;TargetT&gt; : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NOTES: is_in_pack uses partial specialization to match</span></span><br><span class="line"><span class="comment">// the two same types. If the first one matches the target,</span></span><br><span class="line"><span class="comment">// we are done.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInpack</span>&lt;TargetT, TargetT, Ts...&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise, check the remaining ones.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInpack</span>&lt;TargetT, T, Ts...&gt; : IsInPack&lt;Target, Ts...&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>Examples</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(IsInPack&lt;<span class="type">int</span>, <span class="type">double</span>,<span class="type">char</span>,<span class="type">int</span>,<span class="type">float</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">not</span> IsInPack&lt;<span class="type">long</span>, <span class="type">double</span>,<span class="type">char</span>,<span class="type">int</span>,<span class="type">float</span>&gt;::value);</span><br></pre></td></tr></table></figure>

<p>The version of using <code>is_base_of</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeIdentitiy</span> &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsInPackImpl</span> : TypeIdentity&lt;Ts&gt;... &#123;&#125;;</span><br><span class="line"></span><br><span class="line">tmeplate &lt;<span class="keyword">typename</span> TargetT, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">using</span> IsInpack = std::is_base_of&lt;</span><br><span class="line">    TypeIdentity&lt;TargetT&gt;,</span><br><span class="line">    detail::IsInPackImpl&lt;Ts...&gt;&gt;;</span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br></pre></td></tr></table></figure>

<p>Examples</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(IsInPack&lt;<span class="type">int</span>, <span class="type">double</span>,<span class="type">char</span>,<span class="type">int</span>,<span class="type">float</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="keyword">not</span> IsInPack&lt;<span class="type">long</span>, <span class="type">double</span>,<span class="type">char</span>,<span class="type">int</span>,<span class="type">float</span>&gt;::value);</span><br></pre></td></tr></table></figure>

<h2 id="is-base-of"><a href="#is-base-of" class="headerlink" title="is_base_of"></a>is_base_of</h2><p>If Derived is derived from Base or if both are the same non-union class (in both cases<br>cv-qualification), provides the member constant value equal to <code>true</code>. Otherwise value is <code>false</code>.</p>
<p>The possible definition of <code>is_base_of</code> is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function">std::true_type <span class="title">test_pre_ptr_convertible</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> B*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="function">std::false_type <span class="title">test_pre_ptr_convertible</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test_pre_is_base_of</span><span class="params">(...)</span> -&gt; std::true_type</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> B, <span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test_pre_is_base_of</span><span class="params">(<span class="type">int</span>)</span> -&gt;</span></span><br><span class="line"><span class="function">  <span class="title">decltype</span><span class="params">(test_pre_ptr_convertible&lt;B&gt;(<span class="keyword">static_cast</span>&lt;D*&gt;(<span class="literal">nullptr</span>)))</span></span>;</span><br><span class="line">&#125; <span class="comment">// end of namespace detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Base, <span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_base_of</span> :</span><br><span class="line">    std::integral_constant&lt;</span><br><span class="line">        <span class="type">bool</span>,</span><br><span class="line">        std::is_class&lt;Base&gt;::value &amp;&amp; std::is_class&lt;Derived&gt;::<span class="function">value &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">decltype</span><span class="params">(details::test_pre_is_base_of&lt;Base, Derived&gt;(<span class="number">0</span>))</span>::value</span></span><br><span class="line"><span class="function">    &gt; </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Learning-materials"><a href="#Learning-materials" class="headerlink" title="Learning materials."></a>Learning materials.</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=tiAVWcjIF6o">Template Metaprogramming: Type Traits Part I</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dLZcocFOb5Q">Template Metaprogramming: Type Traits Part II</a></li>
</ul>
<ul>
<li>Modern Template Metaprogramming: A Compendium, Part I, Walter E. Brown,<br> CppCon 2014,<br>Link: <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Am2is2QCvxY">Part  I</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=a0FliKwcwXE">Part II</a></li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/maybez/maybe/blob/master/Books/C%2B%2B/Modern%20C%2B%2B%20Design/Modern%20C%2B%2B%20Design_ENG.pdf">Modern C++ Design</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ghjang/cpp_practical_tmp_study">About C++ Template Metaprogramming</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/Template-Metaprogramming-with-CPP">Template Metaprogramming with C++</a></li>
<li><a target="_blank" rel="noopener" href="https://hrjiang.github.io/fopl/13_templates-generics.pdf">Generic programming in OO Languages</a></li>
<li><a target="_blank" rel="noopener" href="https://ptgmedia.pearsoncmg.com/images/9780137647842/samplepages/9780137647842_Sample.pdf">30 Core Guidelines for Writting Clean, Safe, and Fast Code</a></li>
<li><a target="_blank" rel="noopener" href="https://2018.cppconf-piter.ru/talks/day-2/track-a/1.pdf">Reflective Metaprogramming in C++</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qmickecs/article/details/70574506">Tag Dispatching</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Template Metaprogramming---Type Traits</p><p><a href="https://wtffqbpl.github.io/2022/11/06/Template-Metaprogramming-Type-Traits/">https://wtffqbpl.github.io/2022/11/06/Template-Metaprogramming-Type-Traits/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yuanjun Ren</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-11-06</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-13</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a><a class="link-muted mr-2" rel="tag" href="/tags/Meta-Programming/">Meta-Programming</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay-qrcode.jpg" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechat-qrcode.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/11/06/LLVM-Series/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">LLVM Series</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/10/31/CMAKE-Multiple-directories/"><span class="level-item">CMAKE---Multiple directories</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "b7bc625f9884adf4925ec45bb315c493",
            repo: "wtffqbpl.github.io",
            owner: "wtffqbpl",
            clientID: "91ed89a1c2b6427b0731",
            clientSecret: "133fc04688d9a06b6d46e34f1e40909bd5780033",
            admin: ["wtffqbpl"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.jpg" alt="Yuanjun Ren"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yuanjun Ren</p><p class="is-size-6 is-block">C++ Programmer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an/China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wtffqbpl" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wtffqbpl"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/yuanjun-ren-5a7949bb"><i class="fab fa-linkedin"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#The-Aims"><span class="level-left"><span class="level-item">1</span><span class="level-item">The Aims</span></span></a></li><li><a class="level is-mobile" href="#What-is-Meta-Programming"><span class="level-left"><span class="level-item">2</span><span class="level-item">What is Meta-Programming</span></span></a></li><li><a class="level is-mobile" href="#Why-Care-About-Metaprogramming-and-type-traits-in-particular"><span class="level-left"><span class="level-item">3</span><span class="level-item">Why Care About Metaprogramming (and type traits in particular)</span></span></a></li><li><a class="level is-mobile" href="#Meta-Functions"><span class="level-left"><span class="level-item">4</span><span class="level-item">Meta-Functions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#The-Definition-of-meta-function"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">The Definition of meta-function</span></span></a></li><li><a class="level is-mobile" href="#Return-From-a-Meta-Function"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Return From a Meta-Function</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Value-Meta-functions"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">Value Meta-functions</span></span></a></li><li><a class="level is-mobile" href="#Type-Meta-Functions"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">Type Meta-Functions</span></span></a></li><li><a class="level is-mobile" href="#Calling-Type-Meta-Functions"><span class="level-left"><span class="level-item">4.2.3</span><span class="level-item">Calling Type Meta-Functions</span></span></a></li><li><a class="level is-mobile" href="#Convenience-Calling-Conventions"><span class="level-left"><span class="level-item">4.2.4</span><span class="level-item">Convenience Calling Conventions</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Type-Traits"><span class="level-left"><span class="level-item">5</span><span class="level-item">Type Traits</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Some-Useful-Meta-Functions"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Some Useful Meta-Functions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-integral-constant"><span class="level-left"><span class="level-item">5.1.1</span><span class="level-item">std::integral_constant</span></span></a></li><li><a class="level is-mobile" href="#std-bool-constant"><span class="level-left"><span class="level-item">5.1.2</span><span class="level-item">std::bool_constant</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Standard-Type-Trait-Requirements"><span class="level-left"><span class="level-item">6</span><span class="level-item">Standard Type Trait Requirements</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Cpp17-Unary-Type-Trait"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Cpp17 Unary Type Trait</span></span></a></li><li><a class="level is-mobile" href="#Cpp17BinaryTypeTrait"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Cpp17BinaryTypeTrait</span></span></a></li><li><a class="level is-mobile" href="#Cpp17TransformationTrait"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">Cpp17TransformationTrait</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Specialization"><span class="level-left"><span class="level-item">7</span><span class="level-item">Specialization</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#is-void-Unary-Type-Trait"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">is_void (Unary Type Trait)</span></span></a></li><li><a class="level is-mobile" href="#remove-const-Transformation-Trait"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">remove_const (Transformation Trait)</span></span></a></li><li><a class="level is-mobile" href="#conditional"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">conditional</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Primary-Type-Categories"><span class="level-left"><span class="level-item">8</span><span class="level-item">Primary Type Categories</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#is-null-pointer"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">is_null_pointer</span></span></a></li><li><a class="level is-mobile" href="#is-floating-point"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">is_floating_point</span></span></a></li><li><a class="level is-mobile" href="#is-integral"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">is_integral</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Meta-Function-Abstractions"><span class="level-left"><span class="level-item">9</span><span class="level-item">Meta-Function Abstractions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#remove-volatile"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">remove_volatile</span></span></a></li><li><a class="level is-mobile" href="#remove-cv"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">remove_cv</span></span></a></li><li><a class="level is-mobile" href="#is-same"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">is_same</span></span></a></li><li><a class="level is-mobile" href="#is-same-raw"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">is_same_raw</span></span></a></li><li><a class="level is-mobile" href="#is-floating-point-redux"><span class="level-left"><span class="level-item">9.5</span><span class="level-item">is_floating_point: redux</span></span></a></li><li><a class="level is-mobile" href="#is-integral-redux"><span class="level-left"><span class="level-item">9.6</span><span class="level-item">is_integral: redux</span></span></a></li><li><a class="level is-mobile" href="#is-array"><span class="level-left"><span class="level-item">9.7</span><span class="level-item">is_array</span></span></a></li><li><a class="level is-mobile" href="#is-pointer"><span class="level-left"><span class="level-item">9.8</span><span class="level-item">is_pointer</span></span></a></li><li><a class="level is-mobile" href="#is-union"><span class="level-left"><span class="level-item">9.9</span><span class="level-item">is_union</span></span></a></li><li><a class="level is-mobile" href="#is-class-or-union"><span class="level-left"><span class="level-item">9.10</span><span class="level-item">is_class_or_union</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Funciton-Overload-Resolution"><span class="level-left"><span class="level-item">10</span><span class="level-item">Funciton Overload Resolution</span></span></a></li><li><a class="level is-mobile" href="#SFINAE-Substitution-Failure-Is-Not-An-Error"><span class="level-left"><span class="level-item">11</span><span class="level-item">SFINAE (Substitution Failure Is Not An Error)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#is-class"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">is_class</span></span></a></li><li><a class="level is-mobile" href="#is-in-pack"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">is_in_pack</span></span></a></li><li><a class="level is-mobile" href="#is-base-of"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">is_base_of</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Learning-materials"><span class="level-left"><span class="level-item">12</span><span class="level-item">Learning materials.</span></span></a></li><li><a class="level is-mobile" href="#References"><span class="level-left"><span class="level-item">13</span><span class="level-item">References</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><!--!--><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-14/"><span class="tag">C++14</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-17/"><span class="tag">C++17</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-20/"><span class="tag">C++20</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CMake/"><span class="tag">CMake</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CUB/"><span class="tag">CUB</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CUDA/"><span class="tag">CUDA</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Interview/"><span class="tag">Interview</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLVM/"><span class="tag">LLVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Meta-Programming/"><span class="tag">Meta-Programming</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Perfect-Forwarding/"><span class="tag">Perfect Forwarding</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RAII/"><span class="tag">RAII</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Thrust/"><span class="tag">Thrust</span><span class="tag">3</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-13T09:18:48.000Z">2023-05-13</time></p><p class="title"><a href="/2023/05/13/perfect-Forwarding/">Perfect Forwarding</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-13T05:30:31.000Z">2023-05-13</time></p><p class="title"><a href="/2023/05/13/cpp-std-functional/">C++ functional Library Introduction</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-13T05:24:37.000Z">2023-05-13</time></p><p class="title"><a href="/2023/05/13/RAII/">RAII</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-13T03:53:14.000Z">2023-05-13</time></p><p class="title"><a href="/2023/05/13/CRTP/">Curiously Recurring Template Pattern --- CRTP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-13T03:14:52.000Z">2023-05-13</time></p><p class="title"><a href="/2023/05/13/C-Interview-Questions/">C++ Interview Questions</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://coderchenlin.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lin&#039;s Blog</span></span><span class="level-right"><span class="level-item tag">coderchenlin.github.io</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Yuanjun&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Yuanjun Ren</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wtffqbpl/wtffqbpl.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><style>.searchbox .searchbox-body { background: white; }</style><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"><gcse:searchresults-only></gcse:searchresults-only></div></div><script>(function() {
            var cx = 'd795d66993bb247ae';
            var gcse = document.createElement('script');
            gcse.type = 'text/javascript';
            gcse.async = true;
            gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(gcse, s);
        })();</script></div><script src="/js/google_cse.js"></script></body></html>