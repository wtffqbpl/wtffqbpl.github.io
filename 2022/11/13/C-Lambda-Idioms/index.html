<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C++ Lambda Idioms - Yuanjun&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Yuanjun&#039;s Blog"><meta name="msapplication-TileImage" content="/img/logo.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Yuanjun&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Have you ever inherited from a lambda? Can you think of three different ways to call a lambda recursively? Do you know what happens if we assign an immediately-invoked lambda expression to a static va"><meta property="og:type" content="blog"><meta property="og:title" content="C++ Lambda Idioms"><meta property="og:url" content="https://wtffqbpl.github.io/2022/11/13/C-Lambda-Idioms/"><meta property="og:site_name" content="Yuanjun&#039;s Blog"><meta property="og:description" content="Have you ever inherited from a lambda? Can you think of three different ways to call a lambda recursively? Do you know what happens if we assign an immediately-invoked lambda expression to a static va"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://wtffqbpl.github.io/img/cpp/lambda-expression.png"><meta property="article:published_time" content="2022-11-12T18:34:20.000Z"><meta property="article:modified_time" content="2022-11-13T12:41:19.655Z"><meta property="article:author" content="Yuanjun Ren"><meta property="article:tag" content="C++"><meta property="article:tag" content="Lambda"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://wtffqbpl.github.io/img/cpp/lambda-expression.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wtffqbpl.github.io/2022/11/13/C-Lambda-Idioms/"},"headline":"C++ Lambda Idioms","image":["https://wtffqbpl.github.io/img/cpp/lambda-expression.png"],"datePublished":"2022-11-12T18:34:20.000Z","dateModified":"2022-11-13T12:41:19.655Z","author":{"@type":"Person","name":"Yuanjun Ren"},"publisher":{"@type":"Organization","name":"Yuanjun's Blog","logo":{"@type":"ImageObject","url":"https://wtffqbpl.github.io/img/logo.png"}},"description":"Have you ever inherited from a lambda? Can you think of three different ways to call a lambda recursively? Do you know what happens if we assign an immediately-invoked lambda expression to a static va"}</script><link rel="canonical" href="https://wtffqbpl.github.io/2022/11/13/C-Lambda-Idioms/"><link rel="icon" href="/img/logo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Yuanjun&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wtffqbpl/wtffqbpl.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/cpp/lambda-expression.png" alt="C++ Lambda Idioms"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-12T18:34:20.000Z" title="11/13/2022, 2:34:20 AM">2022-11-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-11-13T12:41:19.655Z" title="11/13/2022, 8:41:19 PM">2022-11-13</time></span><span class="level-item">29 minutes read (About 4314 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">C++ Lambda Idioms</h1><div class="content"><p>The closure type for a <code>lambda-expression</code> has a public inline function call operator(for a non-generic lambda) or function call operator template (for a generic lambda) whose parameters and return type are described by the <code>lambda-expression</code>‘s <code>parameter-declaration-clause</code> and <code>trailing-returning-type</code> respectively, and whose <code>template-parameter-list</code> consists of the specified <code>template-parameter-list</code>, if any. The <code>requires-clause</code> of the function call operator template is the <code>requires-clause</code> immediately following &lt; <code>template-parameter-list</code> &gt;, if any. The trailing <code>requires-clause</code> of the function call operator or operator template is the <code>requires-clause</code> of the <code>lambda-declarator</code>, if any.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">const</span> Person &amp;lhs, <span class="type">const</span> Person &amp;rhs) &#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.name &lt; rhs.name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The version after compiled.</p>
<ul>
<li>Lambda has no default <code>noexcept</code> attribute, if you want the call operator to be <code>noexcept</code>, you have to write <code>noexcept</code> keyword.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_1</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Person &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name &lt; rhs.name;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// not default-constructible!</span></span><br><span class="line">  __lambda_1() = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">// not assignable!</span></span><br><span class="line">  __lambda_1&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __lambda_1&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call a lambda</span></span><br><span class="line"><span class="comment">// this instance is auto-generated by the</span></span><br><span class="line"><span class="comment">// compiler, so no error.</span></span><br><span class="line">__lambda_1();</span><br></pre></td></tr></table></figure>

<h1 id="Do-not-capture-anything"><a href="#Do-not-capture-anything" class="headerlink" title="Do not capture anything."></a>Do not capture anything.</h1><p>Lambdas do not have a state, so if the <code>[]</code> is empty, the lambda have an implicit conversion to raw function pointer. So we have some kind of legacy call here like C APIs do that very often they take a raw function pointer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">legacy_call</span><span class="params">(<span class="type">int</span>(*f)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">7</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// OK, implicit conversion to function pointer.</span></span><br><span class="line">  <span class="built_in">legacy_call</span>([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">  &#125;); <span class="comment">// prints 49</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Something like this: <code>__func_type</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_1</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; lhs,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Person&amp; rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name &lt; rhs.name;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// not default-constructible</span></span><br><span class="line">  __lambda_1() = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">// not copyable or assignable!</span></span><br><span class="line">  __lambda_1&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __lambda_1&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> __func_type = <span class="built_in">bool</span>(*)(<span class="type">const</span> Person&amp;,</span><br><span class="line">                              <span class="type">const</span> Person&amp;);</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">operator</span> __func_type() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;__invoke;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __invoke(<span class="type">const</span> Person&amp; lhs,</span><br><span class="line">                              <span class="type">const</span> Person&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.name &lt; rhs.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Idiom-1-Unary-Plus-Trick"><a href="#Idiom-1-Unary-Plus-Trick" class="headerlink" title="Idiom 1: Unary Plus Trick"></a>Idiom 1: Unary Plus Trick</h1><p>DO NOT USE THIS IN PRODUCTION CODE.</p>
<p>It’s kind of really interesting it teaches us something about lambda does work. We’ve already known that no-capturing lambda would implicitly convert to function pointer but what if we need explicit conversion to function pointer?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// this will introduce error since compiler cannot</span></span><br><span class="line">  <span class="comment">// deduce auto * type from i * i.</span></span><br><span class="line">  <span class="keyword">auto</span> *fptr = [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// So we can use static_cast for explicitly casting.</span></span><br><span class="line">  <span class="keyword">auto</span> *fptr = <span class="built_in">static_cast</span>&lt;<span class="built_in">int</span>(*)(<span class="type">int</span>)&gt;([](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">auto</span> *fptr = +[](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The unary operator is obviously not defined for lambdas. However, the unary plus operator is defined for pointers including pointers to function. So if the compiler sees the unary plus operator, it says okay well that only works for pointers, therefore I’m going to implicitly convert this to a pointer. So your lambda is going to be implicitly converted to function pointer, and then a unary plus operator is going to be applied to that function pointer. And what does the unary plus operator do? When it applies to a pointer, nothing will do exactly. So all it does is it’s going to static_cast the lambda to a function pointer.</p>
<h1 id="Lambda-Captures"><a href="#Lambda-Captures" class="headerlink" title="Lambda Captures"></a>Lambda Captures</h1><p><code>Capture</code> is when you capture a variable from the scope where the lambda expression is. So it means the lambda now has states.</p>
<h2 id="Capture-by-Value"><a href="#Capture-by-Value" class="headerlink" title="Capture by Value"></a>Capture by Value</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=] &#123; reutrn i == j; &#125;;</span><br></pre></td></tr></table></figure>

<p>After compiled:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_2</span> &#123;</span><br><span class="line">  __lambda_2(<span class="type">int</span> i, <span class="type">int</span> j) : __i(i), __j(j) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __i == __j;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> __i;</span><br><span class="line">  <span class="type">int</span> __j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__lambda_2(i, j);</span><br></pre></td></tr></table></figure>

<p>When the lambda captures two variables i and j, then compiler is going to add two private members data non-static data members to your closure type, and it’s going to initialize those data members with the values of the variables that you have captured. For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified.</p>
<h2 id="Capture-by-Reference"><a href="#Capture-by-Reference" class="headerlink" title="Capture by Reference"></a>Capture by Reference</h2><p>When you capture by reference.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;] &#123; reutrn i == j; &#125;;</span><br></pre></td></tr></table></figure>

<p>After compiled:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_2</span> &#123;</span><br><span class="line">  __lambda_2(<span class="type">int</span> &amp;i, <span class="type">int</span> &amp;j) : __i(i), __j(j) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __i == __j;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> &amp;__i;</span><br><span class="line">  <span class="type">int</span> &amp;__j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__lambda_2(i, j);</span><br></pre></td></tr></table></figure>
<p>When the lambda captures two variables i and j by reference, then compiler will add two private reference members. An entity is <em>captured by reference</em> if it is implicitly or explicitly captured but not captured by copy. It is unspecified whether additional unnamed non-static data members are declared in the closure type for entities captured by reference. If declared, such non-static data member shall be of literal type.</p>
<h2 id="Capture-this"><a href="#Capture-this" class="headerlink" title="Capture this"></a>Capture <code>this</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">callAsync</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>After compiled:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__lambda_3</span> &#123;</span><br><span class="line">      __lambda_3(X* _this) : __this(_this) &#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; __this-&gt;i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      X* __this;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">callAsync</span>(__lambda_3(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If you capture <code>this</code>, then you get to call members and member functions that object that you are in so that you can have lambda inside a member function of a class and just naturally refer to other members of that class inside that.</p>
<h2 id="Lambda-Capture-Gotchas"><a href="#Lambda-Capture-Gotchas" class="headerlink" title="Lambda Capture Gotchas"></a>Lambda Capture Gotchas</h2><p><font color="red">One really important thing is that you can only capture local variables</font>. For example, you can not capture the static variable <code>i</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="comment">// This capture fails since lambda cannot capture</span></span><br><span class="line">  <span class="comment">// non-static variables.</span></span><br><span class="line">  <span class="keyword">auto</span> f = [=] &#123; ++i; &#125;;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> i; <span class="comment">// return 43!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You actually don’t capture <code>global variable</code>, you are just accessing it. For example, the code is as follows,  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> f = [] &#123; ++i; &#125;;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> i; <span class="comment">// return 43!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You also don’t capture variables even if they are local if the lambda doesn’t <code>ODR</code> use them. You only capture the things that are <code>ODR</code> used inside the lambda. ODR are used is kind of a term from the standards you can again look it up what it means exactly.</p>
<p>Such as the following case, the lambda expression uses <code>constexpr</code> variable. Because the constexpr is a compile-time expression that is not an ODR use of the variable, that means you don’t have to capture I. So again, the capture is empty, but you can use i for printing. However, if you want to take the address of that variable</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="comment">// OK: &#x27;i&#x27; is not odr-used</span></span><br><span class="line">  <span class="keyword">auto</span> f = [] &#123; std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="comment">// ERROR: `i` is odr-used but not captured.</span></span><br><span class="line">  <span class="keyword">auto</span> f = [] &#123; std::cout &lt;&lt; &amp;i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Besides, <code>const int</code> variable also can not be captured by lambda expression since <code>const</code> is implicit <code>constexpr</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="comment">// ERROR: `i` is odr-used but not captured.</span></span><br><span class="line">  <span class="keyword">auto</span> f = [] &#123; std::cout &lt;&lt; &amp;i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If it has a <code>const float</code> not an integer type, therefore, this logic doesn’t apply. You must capture it if you want to use it inside the lambda.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> f = <span class="number">42</span>;</span><br><span class="line">  <span class="comment">// ERROR: `f` is not captured.</span></span><br><span class="line">  []&#123; std::cout &lt;&lt; f &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The right way to use <code>const float</code> variable inside the lambda is as follows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> f = <span class="number">42</span>;</span><br><span class="line">  <span class="comment">// OK: `f` should be captured explicitly.</span></span><br><span class="line">  [&amp;f] &#123; std::cout &lt;&lt; f &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Idiom-2-Immediately-Invoked-Function-Expressions-IIFE"><a href="#Idiom-2-Immediately-Invoked-Function-Expressions-IIFE" class="headerlink" title="Idiom 2: Immediately Invoked Function Expressions (IIFE)"></a>Idiom 2: Immediately Invoked Function Expressions (IIFE)</h1><p>This idiom is so useful and it’s really practice and I think it can be useful in many situations. For example:</p>
<p>What is <code>Immediately Invoked Function Expressions</code>? We don’t necessarily have to assign a lambda expression to a variable. So if we have a lambda expression hever, we can also instead just call it right there. This immediately invoked lambda are really useful.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  [] &#123; std::cout &lt;&lt; <span class="string">&quot;Hello world\n&quot;</span>; &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following code is not a good practice for <code>foo</code> variable initialization. This <code>if-else</code> statement may introduce undefined behavior. Besides, if <code>Foo</code> class is not default-constructible,  this code may not be compiled. The third issue is that if <code>const Foo foo</code>, we cannot assign to a const object using <code>if-else</code> statement. In java, if we use <code>final</code> keyword, this means <code>foo</code> variable is only be assigned once, so the following code could be compiled in java. But in C++, the const keyword means you only get to initialize it once and it has to be at the point where you declare it. So we have problem if we declare <code>foo</code> as const.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some code...</span></span><br><span class="line">  <span class="type">const</span> Foo foo; <span class="comment">// Foo does not have default-constructible.</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (hasDatabase) &#123;</span><br><span class="line">    <span class="comment">// Error: cannot assign to const object.</span></span><br><span class="line">    foo = <span class="built_in">getFooFromDatabase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Error: cannot assign to const object.</span></span><br><span class="line">    foo = <span class="built_in">getFooFromElsewhere</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Without lambda, we can use following method to solve this problem. But the code like this is ugly and unreadable.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Foo foo = hasDatabase ?</span><br><span class="line">      ? <span class="built_in">getFooFromDatabase</span>()</span><br><span class="line">      : <span class="built_in">getFooFromElsewhere</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The other method is that we can extract <code>foo</code> initialization process into a real function. This can split logic into other function, and initialization process is not localization anymore. If the initialization depends on local variables, you now have to pass these local variables as a parameter to function. So it all just gets messy.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">getFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasDatabase)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getFooFromDatabase</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getFooFromElsewhere</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some code...</span></span><br><span class="line">  <span class="type">const</span> Foo foo = <span class="built_in">getFoo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we use lambda, it should be great. Using immediately invoked lambda, you can just assign return value to foo, and this solves the problem. This also gets benefits for <code>make_shared</code>&#x2F;<code>make_unique</code> all of that stuff.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some code...</span></span><br><span class="line">  <span class="type">const</span> Foo foo = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasDatabase)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getFooFromDatabase</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getFooFromElsewhere</span>();</span><br><span class="line">  &#125;(); <span class="comment">// immediately invoke lambda.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using <code>std::invoke</code> function, it takes a function and calls it right away. This looks a little bit more visible because it’s like right there in the beginning. You actually could do more cool stuff with these immediately invoked lambdas.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some code...</span></span><br><span class="line">  std::vector&lt;Foo&gt; foos;</span><br><span class="line">  foos.<span class="built_in">emplace_back</span>(std::<span class="built_in">invoke</span>([] &#123; <span class="comment">// since C++17</span></span><br><span class="line">    <span class="keyword">if</span> (hasDatabase)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getFooFromDatabase</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getFooFromElsewhere</span>();</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Idiom-3-Call-Once-Lambda"><a href="#Idiom-3-Call-Once-Lambda" class="headerlink" title="Idiom 3: Call-Once Lambda"></a>Idiom 3: Call-Once Lambda</h1><blockquote>
<p>Daisy Hollman: “What you can learn from being too cute.”</p>
</blockquote>
<p>For example, here you have some kind of struct X and has a constructor. And you want to run this code when you construct an object but only once, and then never again. When we have more than one initialization calls, we still want this code bo only be called at the first time and never again. How you will do this? </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Called once!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X x1;</span><br><span class="line">  X x2;</span><br><span class="line">  X x3;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using <code>static immediately invoked lambda</code>, you can exactly only execute constructor once. Since C++11 if you initialize a static object, it’s guaranteed to be initialized exactly once. And this initialization is also <font color="red">thread safe</font>. So which means you can actually initialize these X objects from multiple threads simultaneously, and you will still only call this constructor only once, and it’s going to be <font color="red">thread-safe</font>. So the compiler will insert invisible locks to make sure it’s all thread-safe and to make sure that this code is only going to be called only once. There is one caveat here which is if you run this constructor a second time, there will be an implicit check which is some kind of atomic flag whether this has already been called yet in order to make sure that it’s not going to be called again. So this is going to be a little bit of a runtime overhead.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="built_in">X</span>() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> _ = [] &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Called once!\n&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X x1;</span><br><span class="line">  X x2;</span><br><span class="line">  X x3;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-14-Generic-Lambdas"><a href="#C-14-Generic-Lambdas" class="headerlink" title="C++14 Generic Lambdas"></a>C++14 Generic Lambdas</h1><p>We can use <code>auto</code> keyword as lambda’s parameter type. This is really cool because the compiler is going to deduce the type for us.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; httpErrors = &#123;</span><br><span class="line">    &#123;<span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">401</span>, <span class="string">&quot;Unauthorised&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::for_each(</span><br><span class="line">    httpErrors.<span class="built_in">begin</span>(), httpErrors.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> <span class="keyword">auto</span> &amp;item) &#123;</span><br><span class="line">      std::cout &lt;&lt; item.first &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">                &lt;&lt; item.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>For example, if we have the following lambda code like this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>After compiled this code, you may get the following closure.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_6</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">using</span> __func_type = <span class="built_in">void</span>(*)(T i);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">operator</span> __func_type&lt;T&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;__invoke&lt;T&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> __invoke(T i) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__lambda_6();</span><br></pre></td></tr></table></figure>

<p>So if you write generic lambda, it creates a call operator which is a function template. </p>
<p>Besides, if your lambda does not capture anyone, you can still get the implicit conversion to function pointer. But now that conversion operator is also going to be a template.</p>
<p>However, the <code>+</code> operator doesn’t work anymore because the compiler literally does not know what type you need what type you’re trying to create here, what’s the concrete function pointer type, it’s not clear. So that’s not going to work.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Error: can&#x27;t deduce template argument.</span></span><br><span class="line">  <span class="keyword">auto</span> *fptr = +[](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The another cool thing about generic lambda is that they support the perfect forwarding. So if you write the auto ref ref, that’s a forwarding reference.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> f [&amp;v](<span class="keyword">auto</span>&amp;&amp; item) &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(std::forward&lt;<span class="keyword">decltype</span>(item)&gt;(item));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The compiler generates code is more or less like this. You get a function template calling operator.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_7</span> &#123;</span><br><span class="line">  __lambda_7(std::vector&lt;std::string&amp; _v)</span><br><span class="line">    : _v(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp;&amp; item)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    __v.<span class="built_in">push_back</span>(std::forward&lt;<span class="keyword">decltype</span>(item)&gt;(item));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::string&gt;&amp; __v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It also supports variate lambdas.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f [](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="comment">// Fold expression (since C+17).</span></span><br><span class="line">  (std::cout &lt;&lt; ... &lt;&lt; args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">1.5</span>);</span><br></pre></td></tr></table></figure>

<p>Because you can use auto keyword, you can pass lambdas into other lambdas. You can have a lambda that takes another lambda as its argument using <font color="red">auto</font> keyword. You can do many cool meta-programming stuff with this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> twice = [](<span class="keyword">auto</span>&amp;&amp; f) &#123;</span><br><span class="line">  <span class="keyword">return</span> [=] &#123; <span class="built_in">f</span>(); <span class="built_in">f</span>(); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> print_hihi = <span class="built_in">twice</span>([] &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">print_hihi</span>(); <span class="comment">// hihi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Idiom-4-Variable-Template-Lambda"><a href="#Idiom-4-Variable-Template-Lambda" class="headerlink" title="Idiom 4: Variable Template Lambda"></a>Idiom 4: Variable Template Lambda</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;v](<span class="keyword">auto</span>&amp;&amp; item) &#123;</span><br><span class="line">  v.<span class="built_in">push_back</span>(std::forward&lt;<span class="keyword">decltype</span>(item)&gt;(item));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If you have a generic lambda, the call operator is going to be a template.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_7</span> &#123;</span><br><span class="line">  __lambda_7(std::vector&lt;std::string&gt;&amp; _v)</span><br><span class="line">    : _v(v) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp;&amp; item)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    __v.<span class="built_in">push_back</span>(std::forward&lt;<span class="keyword">decltype</span>(item)&gt;(item));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::string&gt;&amp; __v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>What if we could make the lambda itself also a template.</p>
<p>That you can make a lambda a variable template and access the template parameter in it.</p>
<p>We define a variable template, and then we assign a generic lambda to it, and now what happens conceptually?</p>
<ul>
<li><p><strong>Your Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> c_cast = [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">  <span class="built_in">return</span> (T)x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Compiler</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_9</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(U x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T)x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">auto</span> c_cast = __lambda_9&lt;T&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Now we have a lambda template definition. Besides, we have a template call operator  with different type of lambda template’s type since we use generic lambda.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_9</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(U x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This can be useful in a very particular scenario.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ms = std::chrono::milliseconds;</span><br><span class="line"><span class="keyword">using</span> us = std::chrono::microseconds;</span><br><span class="line"><span class="keyword">using</span> ns = std::chrono::nanoseconds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we have a struct for storing a time point</span></span><br><span class="line"><span class="comment">// for some reason we use a variant(like union).</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Time</span> &#123;</span><br><span class="line">  std::variant&lt;ms, ns&gt; time;</span><br><span class="line">  <span class="comment">// this convert function takes a convert function</span></span><br><span class="line">  <span class="comment">// and applies it to the variant using std::visit.</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">convert</span><span class="params">(<span class="type">const</span> <span class="keyword">auto</span> &amp;converter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">visit</span>(converter, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Time <span class="title">t</span><span class="params">(ns(<span class="number">3000</span>))</span></span>;</span><br><span class="line">  std::cout &lt;&lt; t.<span class="built_in">convert</span>(std::chrono::duration_cast&lt;us&gt;).<span class="built_in">count</span>();</span><br><span class="line">  <span class="comment">// Error: This will get error since</span></span><br><span class="line">  <span class="comment">// `std::chrono::duration_cast&lt;&gt;` has three template parameters.</span></span><br><span class="line">  <span class="comment">// we cannot deduce the other two template parameters since</span></span><br><span class="line">  <span class="comment">// this duration_cast function is used as a argument</span></span><br><span class="line">  <span class="comment">// for other function.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We should specify conversion types for <code>duration_cast</code> using variable template. We can wrap the <code>duration_cast</code> into a helper struct. You can split template parameters into two parts:</p>
<ol>
<li>the template parameters that you should specify explicitly;</li>
<li>the template parameters that should be deduced during callsite.</li>
</ol>
<p>So this is a good practice for splitting template parameters into two parts, and using a helper variable template to specify the explicit parameters and deduce the other template parameters.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Time</span> &#123;</span><br><span class="line">  std::variant&lt;ms, ns&gt; time;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">convert</span><span class="params">(<span class="type">const</span> <span class="keyword">auto</span> &amp;converter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">visit</span>(converter, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> duration_cast = [](<span class="keyword">auto</span> d) &#123;</span><br><span class="line">  <span class="comment">// The first template parameter is specified</span></span><br><span class="line">  <span class="comment">// explicitly. And the other two parameters</span></span><br><span class="line">  <span class="comment">// are deduced when this duration_cast</span></span><br><span class="line">  <span class="comment">// function called.</span></span><br><span class="line">  <span class="keyword">return</span> std::chrono::<span class="built_in">duration_cast</span>&lt;T&gt;(d);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Time <span class="title">t</span><span class="params">(ns(<span class="number">3000</span>))</span></span>;</span><br><span class="line">  <span class="comment">// Works.</span></span><br><span class="line">  std::cout &lt;&lt; t.<span class="built_in">convert</span>(duration_cast&lt;us&gt;).<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-14-Init-Capture"><a href="#C-14-Init-Capture" class="headerlink" title="C++14 Init Capture"></a>C++14 Init Capture</h1><p>Using <code>Init Capture</code>, we can capture some non-copyable object.</p>
<ul>
<li><p><strong>Your Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// move happens here.</span></span><br><span class="line"><span class="keyword">auto</span> f = [ptr = std::<span class="built_in">move</span>(ptr)] &#123;</span><br><span class="line">  std::cout &lt;&lt; ptr.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(ptr == <span class="literal">nullptr</span>); <span class="comment">// assert passes</span></span><br><span class="line"><span class="built_in">f</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Compiler</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_8</span> &#123;</span><br><span class="line">  __lambda_8(std::unique_ptr&lt;Widget&gt; _ptr)</span><br><span class="line">    : __ptr(std::<span class="built_in">move</span>(_ptr)) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; __ptr.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// type deduced as if by &#x27;auto&#x27; decl.</span></span><br><span class="line">  std::unique_ptr&lt;Widget&gt; __ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__lambda_8(std::<span class="built_in">move</span>(ptr));</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Idiom-5-Init-Capture-Optimization"><a href="#Idiom-5-Init-Capture-Optimization" class="headerlink" title="Idiom 5: Init Capture Optimization"></a>Idiom 5: Init Capture Optimization</h1><blockquote>
<p>Reference Book: Bartlomiej Filipek: “C++ Lambda Story”</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;std::string&gt; vs = &#123;<span class="string">&quot;apple&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;foobar&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;lemon&quot;</span>&#125;;</span><br><span class="line"><span class="type">const</span> std::string prefix = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = std::<span class="built_in">find_if</span>(</span><br><span class="line">    vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(),</span><br><span class="line">    [&amp;prefix](<span class="type">const</span> std::string &amp;s) &#123;</span><br><span class="line">      <span class="keyword">return</span> s == prefix + <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != vs.<span class="built_in">end</span>()</span><br><span class="line">  std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot;-something found!\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>In the upper case, we concatenate a new string using <code>prefix</code> and <code>&quot;bar&quot;</code> in every loop iteration. But the result is always the same. So if we use the <code>Init Capture</code>, we can optimize this operation. The concatenation operation is performed only once. In this way, you saved a lot of CPU cycles because we can just do this operation once.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;std::string&gt; vs = &#123;<span class="string">&quot;apple&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;foobar&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;lemon&quot;</span>&#125;;</span><br><span class="line"><span class="type">const</span> std::string prefix = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = std::<span class="built_in">find_if</span>(</span><br><span class="line">    vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(),</span><br><span class="line">    [str = prefix + <span class="string">&quot;bar&quot;</span>](<span class="type">const</span> std::string&amp; s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s == str;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">if</span> (result != vs.<span class="built_in">end</span>())</span><br><span class="line">  std::cout &lt;&lt; prefix &lt;&lt; <span class="string">&quot;-something found!\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="C-17-constexpr"><a href="#C-17-constexpr" class="headerlink" title="C++17 constexpr"></a>C++17 constexpr</h1><p>In C++17, we can use <code>constexpr</code> because you can execute them at compile time. The result of a lambda as a non-type template parameter.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []() <span class="keyword">constexpr</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, f()&gt; arr = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Class-Template-Argument-Deducton-CTAD"><a href="#Class-Template-Argument-Deducton-CTAD" class="headerlink" title="Class Template Argument Deducton (CTAD)"></a>Class Template Argument Deducton (CTAD)</h1><p>You don’t need to specify all template parameters since compiler can deduce these parameters.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::vector&lt;int&gt; deduced.</span></span><br><span class="line">std::vector vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Idiom-6-Lambda-Overload-Set"><a href="#Idiom-6-Lambda-Overload-Set" class="headerlink" title="Idiom 6: Lambda Overload Set"></a>Idiom 6: Lambda Overload Set</h1><p>This is a very cool tool to have in your toolbox. If you want to create an object that is a callable object. So you can call it using the usual function called syntax, but it acts as an overload set. we also have a set of lambdas for overload. Because lambda is a struct type after compiler compile it. So you can inherit a lambda. This is really cool technique. You can do is you can write a variadic template which takes a bunch of template parameters by a bunch of types, and it’s going to inherit from all of these types. And then it’s going to use the call operator of all these types. So which means if you write using Ts operator. <code>using Ts::operator()...</code> means it’s kind of inheriting the call operators. The other interesting thing is that overload is an aggregate because it has no user-defined Constructors, it has no private members or anything like this, which means it’s an aggregate and the elements of the aggregate are the base classes. So what we can do is we can initialize an overload object with aggregate initialization using the braces. You can give it a bunch of lambdas, and those lambdas are going to be the base classes of that overload class, and it’s going to inherit the call operator from them.</p>
<p>We also need to write a deduction guide which is like two more lines.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">overload</span> : Ts... &#123;</span><br><span class="line">  <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++17 should declare a deduction guide,</span></span><br><span class="line"><span class="comment">// C++20 doesn&#x27;t need it anymore.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="built_in">overload</span>(Ts...) -&gt; overload&lt;Ts...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// aggregate initialization.</span></span><br><span class="line">  overload f = &#123;</span><br><span class="line">      [](<span class="type">int</span> f) &#123; std::cout &lt;&lt; <span class="string">&quot;int thingy&quot;</span>; &#125;,</span><br><span class="line">      [](<span class="type">float</span> f) &#123; std::cout &lt;&lt; <span class="string">&quot;float thingy&quot;</span>; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-20"><a href="#C-20" class="headerlink" title="C++20"></a>C++20</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="type">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [x, y] = <span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">auto</span> f = [=] &#123;</span><br><span class="line">  std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Lambda can capture parameter packs.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(<span class="keyword">auto</span>... args)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">delay_invoke_foo</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [args...]() -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(args...);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda can be <code>constval</code>. This means it can only be called at compile-time.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> i) constval &#123;</span><br><span class="line">  <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">5</span>); <span class="comment">// OK, constant expression.</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// Error: call to immediate function &#x27;f&#x27;</span></span><br><span class="line">      <span class="comment">//        is not a constant expression.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Template-Lambda"><a href="#Template-Lambda" class="headerlink" title="Template Lambda"></a>Template Lambda</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">erase_if</span>(</span><br><span class="line">    data,</span><br><span class="line">    <span class="comment">// in generate lambda, you do not</span></span><br><span class="line">    <span class="comment">// need to specify types.</span></span><br><span class="line">    [](<span class="keyword">auto</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure>

<p>In C++20, you can explicitly use template lambda.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">erase_if</span>(</span><br><span class="line">    data,</span><br><span class="line">    []&lt;<span class="keyword">typename</span> T&gt;(T i) &#123; <span class="keyword">return</span> i % <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure>

<p>Some interesting lambda expression features in C++20.</p>
<ul>
<li>Lambdas allowed in unevaluated contexts.</li>
<li>Lambdas without captures are now:<ul>
<li>default-constructible</li>
<li>assignable</li>
</ul>
</li>
</ul>
<p>Before C++20, it is not possible to have a lambda be a data member of a class, because you cannot write this </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="comment">// Error: non-static data member</span></span><br><span class="line">  <span class="comment">//        cannot be &#x27;auto&#x27;.</span></span><br><span class="line">  <span class="keyword">auto</span> f = [] &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Since C++20, you can write a lambda in an undivided context like this using <code>decltype</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="keyword">decltype</span>([]&#123;&#125;) f; <span class="comment">// OK, since C++20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This can be useful when </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyPtr =</span><br><span class="line">    std::unique_ptr&lt;T, <span class="keyword">decltype</span>([](T *t) &#123;</span><br><span class="line">      <span class="built_in">myDeleter</span>(t);</span><br><span class="line">    &#125;)&gt;;</span><br><span class="line"></span><br><span class="line">MyPtr&lt;Widget&gt; ptr;</span><br></pre></td></tr></table></figure>

<h2 id="Some-tricky-questions"><a href="#Some-tricky-questions" class="headerlink" title="Some tricky questions."></a>Some tricky questions.</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = [] &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = [] &#123;&#125;;</span><br><span class="line"><span class="comment">// f1 and f2 have different types since compiler</span></span><br><span class="line"><span class="comment">// generates different struct closure for each</span></span><br><span class="line"><span class="comment">// lambda respectively.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = [] &#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = f1;</span><br><span class="line"><span class="comment">// f1 and f2 have the same type.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = [] &#123;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(f1) f2;</span><br><span class="line"><span class="comment">// f1 and f2 have the same type. Because there is</span></span><br><span class="line"><span class="comment">// only one lambda type.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> t = <span class="keyword">decltype</span>([] &#123;&#125;);</span><br><span class="line">t f1;</span><br><span class="line">t f2;</span><br><span class="line"><span class="comment">// f1 and f2 have the same type.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>([] &#123;&#125;) f1;</span><br><span class="line"><span class="keyword">decltype</span>([] &#123;&#125;) f2;</span><br><span class="line"><span class="comment">// f1 and f2 have different lambda types.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> = []&#123;&#125;&gt;</span><br><span class="line">    <span class="keyword">struct</span> X &#123;&#125;;</span><br><span class="line"></span><br><span class="line">X x1;</span><br><span class="line">X x2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x1 and x2 have different types.</span></span><br><span class="line"><span class="comment">// Because every time you define a lambda,</span></span><br><span class="line"><span class="comment">// compiler will generate a new struct</span></span><br><span class="line"><span class="comment">// closure, then there will be a different type.</span></span><br></pre></td></tr></table></figure>

<h1 id="Idiom-7-Unique-types-generator"><a href="#Idiom-7-Unique-types-generator" class="headerlink" title="Idiom 7: Unique types generator"></a>Idiom 7: Unique types generator</h1><p>Since C++20.</p>
<h1 id="Idiom-8-Recursive-Lambdas"><a href="#Idiom-8-Recursive-Lambdas" class="headerlink" title="Idiom 8: Recursive Lambdas"></a>Idiom 8: Recursive Lambdas</h1><p>Naive approach:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> f = [](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Error: &#x27;f&#x27; declared with &#x27;auto&#x27;</span></span><br><span class="line">    <span class="comment">// cannot appear in its own initializer!</span></span><br><span class="line">    <span class="keyword">return</span> i * <span class="built_in">f</span>(i - <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using <code>std::function</code>(Still not great).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="built_in">f</span>(i - <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We cannot name the lambda within itself, but we can template it on the function that it’s going to be calling within itself. And then we can pass itself to itself like this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// We can pass itself to itself like this.</span></span><br><span class="line">    <span class="comment">// But this looks awkward that this does not</span></span><br><span class="line">    <span class="comment">// look like a normal function call because</span></span><br><span class="line">    <span class="comment">// you always have to pass the lambda to itself</span></span><br><span class="line">    <span class="comment">// by argument.</span></span><br><span class="line">    <span class="keyword">return</span> i * <span class="built_in">self</span>(self, i - <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">f</span>(f, <span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints 120</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ deducing this: it just works</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// this is an implicit argument, we don&#x27;t need to</span></span><br><span class="line">  <span class="comment">// pass it, we just call f act like a normal</span></span><br><span class="line">  <span class="comment">// function call. Because if the compiler is going</span></span><br><span class="line">  <span class="comment">// to be like you want to have this implicit first</span></span><br><span class="line">  <span class="comment">// parameter which is this pointer, let&#x27;s deduce</span></span><br><span class="line">  <span class="comment">// what it is, let&#x27;s deduce the type and now you</span></span><br><span class="line">  <span class="comment">// can name this parameter. That&#x27;s a good convention</span></span><br><span class="line">  <span class="comment">// that&#x27;s what python people use. This must be good.</span></span><br><span class="line">  <span class="keyword">auto</span> f = [](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="built_in">self</span>(i - <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// prints 120</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Idiom-6-8-Recursive-Lambda-Overload-Set"><a href="#Idiom-6-8-Recursive-Lambda-Overload-Set" class="headerlink" title="Idiom 6 + 8: Recursive Lambda Overload Set"></a>Idiom 6 + 8: Recursive Lambda Overload Set</h1><blockquote>
<p>Ben Deane: Deducing this patterns</p>
</blockquote>
<p>This is an example where you want to tree traversal. You have a binary tree. You are going to implement it as a variant. So every tree is either a leaf or a node, and it’s kind of recursive. And then what you want to traverse the tree you recursively and count the number of leaves. We can use the recursive lambda overload pattern here. Do this varient and we are going to have two lambdas here, one overload for the leaf, and one for the node, and if you have a node, you count the least by taking the left child and counting the leaves and taking the right child and counting leaves, so you are going to call it recursively. And the really cool thing here is that if you call this thing from within itself recursively using reducing this. Deducing this because it’s using the normal rules of function template argument deduction it’s going to deduce the fully derived like in so far as it s known at compile time, which in this case it is. So if you refer to self here, the self is not the lambda. The self is the fully derived type which is the whole overload set.<br>This is a classic job interview question. So next time somebody wanted to implement tree traverse, you can write it like this and you can really impress your interviewer. This is only supported in Microsoft compiler.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Leaf</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>;</span><br><span class="line"><span class="keyword">using</span> Tree = std::variant&lt;Leaf, Node*&gt;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  Tree left, right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">overload</span> : Ts... &#123; <span class="function"><span class="keyword">using</span> <span class="title">Ts::operator</span><span class="params">()</span>...</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++17 should define a guide deduction,</span></span><br><span class="line"><span class="comment">// C++20 doesn&#x27;t need it anymore.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="built_in">overload</span>(Ts...) -&gt; overload&lt;Ts...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countLeaves</span><span class="params">(<span class="type">const</span> Tree &amp;tree)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">visit</span>(overload&#123;</span><br><span class="line">    [](<span class="type">const</span> Leaf&amp;) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;,</span><br><span class="line">    [](<span class="keyword">this</span> <span class="type">const</span> <span class="keyword">auto</span> &amp;self, <span class="type">const</span> Node *node) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">visit</span>(self, node-&gt;left) +</span><br><span class="line">             <span class="built_in">visit</span>(self, node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, tree);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a target="_blank" rel="noopener" href="https://eel.is/c++draft/expr.prim.lambda">expr.prim.lambda</a></li>
<li><a target="_blank" rel="noopener" href="https://timur.audio/">Timur Audio’s Blog</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>C++ Lambda Idioms</p><p><a href="https://wtffqbpl.github.io/2022/11/13/C-Lambda-Idioms/">https://wtffqbpl.github.io/2022/11/13/C-Lambda-Idioms/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yuanjun Ren</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-11-13</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-13</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a><a class="link-muted mr-2" rel="tag" href="/tags/Lambda/">Lambda</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay-qrcode.jpg" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechat-qrcode.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/11/13/Aggregate-Initialization/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Aggregate Initialization</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/11/08/Lambda-Expression/"><span class="level-item">Lambda Expression</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "dae0cbc03415a34bb3291317dff9f2d2",
            repo: "wtffqbpl.github.io",
            owner: "wtffqbpl",
            clientID: "91ed89a1c2b6427b0731",
            clientSecret: "133fc04688d9a06b6d46e34f1e40909bd5780033",
            admin: ["wtffqbpl"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.jpg" alt="Yuanjun Ren"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yuanjun Ren</p><p class="is-size-6 is-block">C++ Programmer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an/China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wtffqbpl" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wtffqbpl"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/yuanjun-ren-5a7949bb"><i class="fab fa-linkedin"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Do-not-capture-anything"><span class="level-left"><span class="level-item">1</span><span class="level-item">Do not capture anything.</span></span></a></li><li><a class="level is-mobile" href="#Idiom-1-Unary-Plus-Trick"><span class="level-left"><span class="level-item">2</span><span class="level-item">Idiom 1: Unary Plus Trick</span></span></a></li><li><a class="level is-mobile" href="#Lambda-Captures"><span class="level-left"><span class="level-item">3</span><span class="level-item">Lambda Captures</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Capture-by-Value"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Capture by Value</span></span></a></li><li><a class="level is-mobile" href="#Capture-by-Reference"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Capture by Reference</span></span></a></li><li><a class="level is-mobile" href="#Capture-this"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Capture this</span></span></a></li><li><a class="level is-mobile" href="#Lambda-Capture-Gotchas"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Lambda Capture Gotchas</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Idiom-2-Immediately-Invoked-Function-Expressions-IIFE"><span class="level-left"><span class="level-item">4</span><span class="level-item">Idiom 2: Immediately Invoked Function Expressions (IIFE)</span></span></a></li><li><a class="level is-mobile" href="#Idiom-3-Call-Once-Lambda"><span class="level-left"><span class="level-item">5</span><span class="level-item">Idiom 3: Call-Once Lambda</span></span></a></li><li><a class="level is-mobile" href="#C-14-Generic-Lambdas"><span class="level-left"><span class="level-item">6</span><span class="level-item">C++14 Generic Lambdas</span></span></a></li><li><a class="level is-mobile" href="#Idiom-4-Variable-Template-Lambda"><span class="level-left"><span class="level-item">7</span><span class="level-item">Idiom 4: Variable Template Lambda</span></span></a></li><li><a class="level is-mobile" href="#C-14-Init-Capture"><span class="level-left"><span class="level-item">8</span><span class="level-item">C++14 Init Capture</span></span></a></li><li><a class="level is-mobile" href="#Idiom-5-Init-Capture-Optimization"><span class="level-left"><span class="level-item">9</span><span class="level-item">Idiom 5: Init Capture Optimization</span></span></a></li><li><a class="level is-mobile" href="#C-17-constexpr"><span class="level-left"><span class="level-item">10</span><span class="level-item">C++17 constexpr</span></span></a></li><li><a class="level is-mobile" href="#Class-Template-Argument-Deducton-CTAD"><span class="level-left"><span class="level-item">11</span><span class="level-item">Class Template Argument Deducton (CTAD)</span></span></a></li><li><a class="level is-mobile" href="#Idiom-6-Lambda-Overload-Set"><span class="level-left"><span class="level-item">12</span><span class="level-item">Idiom 6: Lambda Overload Set</span></span></a></li><li><a class="level is-mobile" href="#C-20"><span class="level-left"><span class="level-item">13</span><span class="level-item">C++20</span></span></a></li><li><a class="level is-mobile" href="#Template-Lambda"><span class="level-left"><span class="level-item">14</span><span class="level-item">Template Lambda</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Some-tricky-questions"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">Some tricky questions.</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Idiom-7-Unique-types-generator"><span class="level-left"><span class="level-item">15</span><span class="level-item">Idiom 7: Unique types generator</span></span></a></li><li><a class="level is-mobile" href="#Idiom-8-Recursive-Lambdas"><span class="level-left"><span class="level-item">16</span><span class="level-item">Idiom 8: Recursive Lambdas</span></span></a></li><li><a class="level is-mobile" href="#Idiom-6-8-Recursive-Lambda-Overload-Set"><span class="level-left"><span class="level-item">17</span><span class="level-item">Idiom 6 + 8: Recursive Lambda Overload Set</span></span></a></li><li><a class="level is-mobile" href="#References"><span class="level-left"><span class="level-item">18</span><span class="level-item">References</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><!--!--><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-11/"><span class="tag">C++11</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-14/"><span class="tag">C++14</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-17/"><span class="tag">C++17</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-20/"><span class="tag">C++20</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CMake/"><span class="tag">CMake</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CUB/"><span class="tag">CUB</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CUDA/"><span class="tag">CUDA</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Interview/"><span class="tag">Interview</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLVM/"><span class="tag">LLVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Meta-Programming/"><span class="tag">Meta-Programming</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Perfect-Forwarding/"><span class="tag">Perfect Forwarding</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RAII/"><span class="tag">RAII</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Thrust/"><span class="tag">Thrust</span><span class="tag">3</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-14T04:29:51.000Z">2023-05-14</time></p><p class="title"><a href="/2023/05/14/C-Value-Categories/">C++ Value Categories</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-14T03:54:22.000Z">2023-05-14</time></p><p class="title"><a href="/2023/05/14/C-Basics/">C++ Basics</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-14T03:20:57.000Z">2023-05-14</time></p><p class="title"><a href="/2023/05/14/C-Iterator-System/">C++ Iterator System</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-14T01:30:17.000Z">2023-05-14</time></p><p class="title"><a href="/2023/05/14/C-Best-Practices/">C++ Best Practices</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-13T11:03:04.000Z">2023-05-13</time></p><p class="title"><a href="/2023/05/13/Argument-Dependent-Lookup/">Argument Dependent Lookup</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://coderchenlin.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lin&#039;s Blog</span></span><span class="level-right"><span class="level-item tag">coderchenlin.github.io</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Yuanjun&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Yuanjun Ren</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wtffqbpl/wtffqbpl.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><style>.searchbox .searchbox-body { background: white; }</style><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"><gcse:searchresults-only></gcse:searchresults-only></div></div><script>(function() {
            var cx = 'd795d66993bb247ae';
            var gcse = document.createElement('script');
            gcse.type = 'text/javascript';
            gcse.async = true;
            gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(gcse, s);
        })();</script></div><script src="/js/google_cse.js"></script></body></html>