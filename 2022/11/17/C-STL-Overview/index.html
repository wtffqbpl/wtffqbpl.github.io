<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C++ STL Overview - Yuanjun&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Yuanjun&#039;s Blog"><meta name="msapplication-TileImage" content="/img/logo.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Yuanjun&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="If you want to know all STL algorithms, or you want to learn how to master STL algorithms. Please click this article for more details."><meta property="og:type" content="blog"><meta property="og:title" content="C++ STL Overview"><meta property="og:url" content="https://wtffqbpl.github.io/2022/11/17/C-STL-Overview/"><meta property="og:site_name" content="Yuanjun&#039;s Blog"><meta property="og:description" content="If you want to know all STL algorithms, or you want to learn how to master STL algorithms. Please click this article for more details."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://wtffqbpl.github.io/img/cpp/cpp-basics-5.jpg"><meta property="article:published_time" content="2022-11-16T16:34:10.000Z"><meta property="article:modified_time" content="2022-11-19T10:53:20.443Z"><meta property="article:author" content="Yuanjun Ren"><meta property="article:tag" content="C++"><meta property="article:tag" content="STL"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://wtffqbpl.github.io/img/cpp/cpp-basics-5.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wtffqbpl.github.io/2022/11/17/C-STL-Overview/"},"headline":"C++ STL Overview","image":["https://wtffqbpl.github.io/img/cpp/cpp-basics-5.jpg"],"datePublished":"2022-11-16T16:34:10.000Z","dateModified":"2022-11-19T10:53:20.443Z","author":{"@type":"Person","name":"Yuanjun Ren"},"publisher":{"@type":"Organization","name":"Yuanjun's Blog","logo":{"@type":"ImageObject","url":"https://wtffqbpl.github.io/img/logo.png"}},"description":"If you want to know all STL algorithms, or you want to learn how to master STL algorithms. Please click this article for more details."}</script><link rel="canonical" href="https://wtffqbpl.github.io/2022/11/17/C-STL-Overview/"><link rel="icon" href="/img/logo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Yuanjun&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wtffqbpl/wtffqbpl.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/cpp/cpp-basics-5.jpg" alt="C++ STL Overview"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-16T16:34:10.000Z" title="11/17/2022, 12:34:10 AM">2022-11-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-11-19T10:53:20.443Z" title="11/19/2022, 6:53:20 PM">2022-11-19</time></span><span class="level-item">37 minutes read (About 5534 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">C++ STL Overview</h1><div class="content"><p><strong>STL algorithms can make code more expressive</strong></p>
<ul>
<li>Raising levels of abstraction</li>
<li>Sometimes, it can be spectacular.</li>
</ul>
<p><strong>Avoid common mistakes</strong></p>
<ul>
<li>off-by-one</li>
<li>empty loops</li>
<li>naive complexity</li>
</ul>
<p>When writing our own for-loops is about complexity. Some algorithms that they can be implemented naively in quadratic complexity, and in a more astute manner in a linear complexity.</p>
<p><strong>Used by lots of people</strong></p>
<ul>
<li>A common vocabulary</li>
<li>Whatever the version of your compiler</li>
</ul>
<p>Also, STL algorithms are used by billions of people every day. You don’t need to afraid of them. I think we should level up to STL algorithms and not the other way around.<br>So even if you are running an older C++ version, you can still get most of the STL algorithms, like for example, if you are in C++03 for example, and you want to use <code>all_of</code>, <code>any_of</code> or <code>none_of</code> which appeared in C++11. Well you can just grab that code, and copy it into your codebase and just start using them. So most of them are within your reach whichever version of C++ you are on right now.</p>
<p>Many more of the STL algorithms that let you express more nuance when you write your code. I’m going to show you something to illustrate the fact that there’s much more than <code>for_each</code> in the STL algorithms library.</p>
<p>Here is the world of C++ STL algorithms</p>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/stl_map.png" alt="The World of C++ STL Algorithms"></p>
<p>The <code>Queries</code> means the stl algorithms which in this area just extract some piece of information, and they don’t actually modify it. The most of the stl algorithms would somehow change the collection, like sort or partition or whatever. But most of them are just <code>read-only</code> operations.</p>
<h1 id="Heaps"><a href="#Heaps" class="headerlink" title="Heaps"></a>Heaps</h1><p>A <code>Heap</code> is a data structure that looks like a tree, but that has a property is that every node must be smaller than its children. This is called <code>max heap</code>.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117010011.png" alt="Heaps-image"><br>So one extremely interesting property of the heap is taht we can squash it down into a range like below.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117010400.png"></p>
<h2 id="std-make-heap"><a href="#std-make-heap" class="headerlink" title="std::make_heap"></a>std::make_heap</h2><p>When you do this, there is a nice property that it’s a range. So we can represent it with a vector, for example which is quite convenient to work with. And also, to go froma node to its left child, it is essentially taking its index and multiplying it by twos, nearly that. So it’s a way to represent a tree into a range. If you have a range, we have a beginning and an end and we can use STL algorithms.<br>So first thing we can do is taking values that are not particularly a heap, and rearrange them so that they respect the heap property. We use <code>std::make_heap</code> to make a heap. We rearrange the element inside of a collection. This is our first algorithm.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117010904.png"></p>
<h2 id="std-push-heap"><a href="#std-push-heap" class="headerlink" title="std::push_heap"></a>std::push_heap</h2><p>When we want to add a new value into a heap, we should move up the new value to right position in case to meet the heap criteria.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117011138.png"></p>
<p>When we squash the heap into a vector, we add something to the end, and then we need something to make it bubble its way up to its final position, and that is <code>std::push_heap</code>.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117011400.png"></p>
<h2 id="std-pop-heap"><a href="#std-pop-heap" class="headerlink" title="std::pop_heap"></a>std::pop_heap</h2><p>When we want to remove something from the heap. Usually we want to get the maximum value from this heap, <code>std::pop_heap</code> can be used to get this maximum value.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117011803.png"><br>To do this, we swap the first one and the last one. At this point, we need to make it bubble its way down to its final position, and that’s what pop_heap does. And if we want to remove, actually remove that value, we pop it back from the vector.</p>
<p>If we pop each value from heap, then we get a sorted collection, and that is what <code>std::sort_heap</code>.</p>
<h1 id="SORTING"><a href="#SORTING" class="headerlink" title="SORTING"></a>SORTING</h1><h2 id="std-sort"><a href="#std-sort" class="headerlink" title="std::sort"></a>std::sort</h2><p>Rearrange the collection, and we get a sorted order collection.</p>
<h2 id="std-partial-sort"><a href="#std-partial-sort" class="headerlink" title="std::partial_sort"></a>std::partial_sort</h2><p>Now if we only want to sort the beginning of a collection, this is a <code>partial_sort</code>. partial sort is kind of like a middle, something inside of the collection, and sorts the collection from the beginning to that point, and the rest is in unspecified order.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117012627.png"></p>
<h2 id="std-nth-element"><a href="#std-nth-element" class="headerlink" title="std::nth_element"></a>std::nth_element</h2><p><code>nth_element</code> is a partial sorting algorithm that rearranges elements in [first, last).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 RandomIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 RandomIt last, Cmpare comp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy, <span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(ExecutionPolicy&amp;&amp; policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                 RandomIt first, RandomIt nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 RandomIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                           RandomIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy, <span class="keyword">typename</span> RandomIt,</span><br><span class="line">          <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(ExecutionPolicy&amp;&amp; policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                 RandomIt first, RandomIt nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                 RandomIt last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117013337.png"></p>
<h2 id="std-sort-heap"><a href="#std-sort-heap" class="headerlink" title="std::sort_heap"></a>std::sort_heap</h2><h2 id="std-inplace-merge"><a href="#std-inplace-merge" class="headerlink" title="std::inplace_merge"></a>std::inplace_merge</h2><p><code>inplace_merge</code> is the incremental step in a merge sort. Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy, <span class="keyword">typename</span> BidirIt&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inplace_merge</span><span class="params">(ExecutionPolicy&amp;&amp; policy, BidirIt first,</span></span></span><br><span class="line"><span class="params"><span class="function">                   BidirIt middle, BidirIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy, <span class="keyword">typename</span> BidirIt,</span><br><span class="line">          <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inplace_merge</span><span class="params">(ExecutionPolicy&amp;&amp; policy, BidirIt first,</span></span></span><br><span class="line"><span class="params"><span class="function">                   BidirIt middle, BidirIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                   Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="PARTITIONING"><a href="#PARTITIONING" class="headerlink" title="PARTITIONING"></a>PARTITIONING</h1><p>To partition a collection is to look at it through a predicate, something that returns a <code>Boolean</code>. If the <em>blue</em> is the predicates. The original collection is depicted as follows.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117014115.png"></p>
<p>Then we do partition, then the predicates are at the beginning, and other not-blue ones at the end.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117014423.png"></p>
<p>The border between the blue ones and the not-blue ones is called a partition point, that’s the end of the blue range and that’s also the beginning of the not blue range.</p>
<h1 id="PERMUTATIONS"><a href="#PERMUTATIONS" class="headerlink" title="PERMUTATIONS"></a>PERMUTATIONS</h1><p>The elements move around the collection, even if they don’t change value.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117124819.png"></p>
<h2 id="std-rotate"><a href="#std-rotate" class="headerlink" title="std::rotate"></a>std::rotate</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// since C++11 and until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">rotate</span><span class="params">(ForwardIt first, ForwardIt n_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ForwardIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy, <span class="keyword">class</span> <span class="title class_">ForwardIt</span>&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">rotate</span><span class="params">(ExecutionPolicy&amp;&amp; policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ForwardIt first, ForwardIt n_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ForwardIt last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Performs a left rotation on a range of elements. Specifically, <code>std::rotate</code> swaps the elements in the range[first, last) in such a way that the element n_first becomes the first element of the new range and <code>n_first - 1</code> becomes the last element.</p>
<h2 id="std-shuffle"><a href="#std-shuffle" class="headerlink" title="std::shuffle"></a>std::shuffle</h2><p><code>std::shuffle</code> is used to randomly change elements in a container. So <code>std::shuffle</code> takes a collection with elements in a certain order, and takes something that generates random numbers, and rearranges the collection in random order. </p>
<h2 id="std-next-permutation-x2F-std-prev-permutation"><a href="#std-next-permutation-x2F-std-prev-permutation" class="headerlink" title="std::next_permutation&#x2F;std::prev_permutation"></a>std::next_permutation&#x2F;std::prev_permutation</h2><p>Given a collection of object, we can order them, order all their possible arrangements, and an intuitive way to see that is thinking about an alphabetical order.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirIt&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirIt first, BidirIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirIt first, BidirIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Compare comp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirIt first,</span></span></span><br><span class="line"><span class="params"><span class="function">                                BidirIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirIt first,</span></span></span><br><span class="line"><span class="params"><span class="function">                                BidirIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Permutes the range [first, last) into the next permutation, where the set of all permutations is ordered lexicographically with respect to operator <code>&lt;</code> or comp. Returns true if such a “next permutation” exists; otherwise transforms the range into the lexicographically first permutation (as if by <code>std::sort(first, last, comp)</code>) and returns <code>false</code>.<br>That’s interesting for every possible arrangement of a collection, we can repeatedly call <code>std::next_permutation</code> until you’ve cycled back to the beginning.</p>
<h1 id="SECRET-RUNES"><a href="#SECRET-RUNES" class="headerlink" title="SECRET RUNES"></a>SECRET RUNES</h1><p>The secret runes are things that you can combine with other algorithms to generate new algorithms. I called them runs because it’s like going to see runes to augment your powers and also because I find that kind of cool as a name.</p>
<h2 id="PARTITIONING-SORT-HEAP"><a href="#PARTITIONING-SORT-HEAP" class="headerlink" title="PARTITIONING-SORT-HEAP"></a>PARTITIONING-SORT-HEAP</h2><h3 id="stable-rune"><a href="#stable-rune" class="headerlink" title="stable_* rune"></a>stable_* rune</h3><p>When we will see all the algorithm that go with the <code>stable</code> rune, so <code>stable</code> when you tack it onto an algorithm, it does what this algorithm does, but keep the relative order. Think <code>std::partition</code> for example, it put all the blue ones at the beginning that’s for sure, but maybe in the process, some of them got swapped around. With <code>std::stable_partition</code>, they all keep the same relative order. Same thing with <code>std::stable_sort</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stable_* ---&gt; stable_sort</span><br><span class="line">         \</span><br><span class="line">           --&gt; stable_partition</span><br></pre></td></tr></table></figure>

<h3 id="is-rune"><a href="#is-rune" class="headerlink" title="is_* rune"></a>is_* rune</h3><p>The <code>is_*</code> rune checks for a predicate on the collection. We know what sort, partition, heap, means is_sort&#x2F;is_partition&#x2F;is_heap and returns a boolean. To indicate whether it’s a sorted&#x2F;partitioned&#x2F;heap that we are looking at.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_*   -----| is_sorted</span><br><span class="line">            | is_partitioned </span><br><span class="line">            | is_heap</span><br></pre></td></tr></table></figure>

<h3 id="is-until"><a href="#is-until" class="headerlink" title="is_*_until"></a>is_*_until</h3><p><code>is_*_until</code> returns an iterator that’s the first position where that predicate doesn’t hold anymore. So for example, if we have a sorted collection, and then we call <code>std::is_sorted_until</code> we’ll get the end of that collection.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_*_until -----| is_sorted_until</span><br><span class="line">                | is_partitioned_until</span><br><span class="line">                | is_heap_until</span><br></pre></td></tr></table></figure>

<h1 id="QUERIES"><a href="#QUERIES" class="headerlink" title="QUERIES"></a>QUERIES</h1><p>So one thing you can extract out of a collection is some sort of value.</p>
<h2 id="std-count"><a href="#std-count" class="headerlink" title="std::count"></a>std::count</h2><p>For example, the simplest one is probably <code>std::count</code> that takes a begin and an end a value, and returns how many times this value occurs in the collection.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117131456.png"></p>
<h2 id="std-accumulate-x2F-transform-reduce"><a href="#std-accumulate-x2F-transform-reduce" class="headerlink" title="std::accumulate&#x2F;(transform_)reduce"></a>std::accumulate&#x2F;(transform_)reduce</h2><p>The <code>accumulate</code> makes some elements of the collection calling operator plus, or any custom function you’d pass it. In C++17, there’s <code>std::reduce</code> appeared, that does practically the same thing as accumulate, except it has a slightly different interface. It can accept to take no initial value, and it can also be run in parallel, but essentially, it’s the same as <code>std::accumulate</code>.</p>
<p><code>std::transform_reduce</code> takes a function and applies that function to the element of the collection before calling the <code>reduce</code>.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117131511.png"></p>
<h2 id="std-partial-sum"><a href="#std-partial-sum" class="headerlink" title="std::partial_sum"></a>std::partial_sum</h2><p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221117133825.png"><br>I think this is the <code>pre-sum</code> algorithm in std algorithms.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> OutputIt&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">partial_sum</span><span class="params">(InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                     OutputIt d_first)</span></span>;</span><br><span class="line"><span class="comment">// until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> OutputIt,</span><br><span class="line">          <span class="keyword">typename</span> BinaryOperation&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">partial_sum</span><span class="params">(InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                     OutputIt d_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                     BinaryOperation op)</span></span>;</span><br><span class="line"><span class="comment">// since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> OutputIt&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">partial_sum</span><span class="params">(InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                     OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> OutputIt,</span><br><span class="line">          <span class="keyword">typename</span> BinaryOperation&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> OutputIt <span class="title">partial_sum</span><span class="params">(InputIt first,</span></span></span><br><span class="line"><span class="params"><span class="function">                               InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                               OutputIt d_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                               BinaryOperation op)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>std::partial_sum</code>, it sums the all the elements starting from the beginning to the current point of the collection. So here, <code>partial_sum</code> would return a collection with, in the first position, what was in the first position of the original collection. and the second one would plus the seco</p>
<p>Computes the partial sums of the elements in the sub-ranges of the range[first, last) and writes them to the range beginning at <code>d_dirst</code>. This is equivalent operation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*(d_first)     = *first;</span><br><span class="line">*(d_first + <span class="number">1</span>) = *first + *(first + <span class="number">1</span>);</span><br><span class="line">*(d_first + <span class="number">2</span>) = *first + *(first + <span class="number">1</span>) + *(first + <span class="number">2</span>);</span><br><span class="line">*(d_first + <span class="number">3</span>) = *first + *(first + <span class="number">1</span>) + *(first + <span class="number">2</span>) + *(first + <span class="number">3</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>In C++17, there are <code>std::(transform_)inclusive_scan</code> and <code>std::(transform_)exclusive_scan</code>. <code>inclusive_scan</code> is the same thing as <code>partial_sum</code>, except it can run in parallel. <code>exclusive_scan</code> is the same as <code>inclusive_scan</code>, except it doesn’t include the current element. So for example, with <code>exclusive_scan</code>, the second value is the same to the first element of the original collection. The third would be one plus second, so-on and so-forth.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *(d_first)     = ;</span></span><br><span class="line">*(d_first + <span class="number">1</span>) = *first;</span><br><span class="line">*(d_first + <span class="number">2</span>) = *first + *(first + <span class="number">1</span>);</span><br><span class="line">*(d_first + <span class="number">3</span>) = *first + *(first + <span class="number">1</span>) + *(first + <span class="number">2</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="std-inner-product"><a href="#std-inner-product" class="headerlink" title="std::inner_product"></a>std::inner_product</h2><p>TODO<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118124956.png"></p>
<h2 id="std-adjacent-difference"><a href="#std-adjacent-difference" class="headerlink" title="std::adjacent_difference"></a>std::adjacent_difference</h2><p>TODO<br><code>std::adjacent_difference</code> makes the difference between every two neighbors in the collection .<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118125042.png"></p>
<h2 id="std-sample"><a href="#std-sample" class="headerlink" title="std::sample"></a>std::sample</h2><p><code>std::sample</code>, introduced since C++17, takes something that can return some, that can generate random numbers, and it takes a number, say N, and it produces n elements of that collection, selected randomly.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118125416.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PopulationIterator,</span><br><span class="line">          <span class="keyword">typename</span> SampleIterator,</span><br><span class="line">          <span class="keyword">typename</span> Distance, <span class="keyword">typename</span> URBG&gt;</span><br><span class="line"><span class="function">SampleIterator <span class="title">sample</span><span class="params">(PopulationIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                      PopulationIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                      SampleIterator out, Distance n,</span></span></span><br><span class="line"><span class="params"><span class="function">                      URGB&amp;&amp; g)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Selects n elements from the sequence [first, last)(without replacement) such that each possible sample has equal probability of appearance, and writes those selected elements into the output iterator out. Random numbers are generated using the random number generator g.<br>If n is greater than the number of elements in the sequence, selects <code>last-first</code> elements.<br>The algorithm is stable only if <code>PopulationIterator</code> meets the requirements of <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>.</p>
<h1 id="QUERYING-A-PROPERTY"><a href="#QUERYING-A-PROPERTY" class="headerlink" title="QUERYING A PROPERTY"></a>QUERYING A PROPERTY</h1><p>There are three std algorithms: <code>std::all_of</code>, <code>std::any_of</code>, <code>std::none_of</code>. These three functions are really useful in everyday code.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118130413.png"></p>
<ul>
<li><code>std::all_of</code> takes collection and a predicate, returns if all elements satisfy that predicate. If the collector is empty, <code>std::all_of</code> returns <code>true</code>.</li>
<li><code>std::any_of</code> at least one element satisfy that predicate. If the collector is empty, <code>std::any_of</code> returns <code>false</code>.</li>
<li><code>std::none_of</code> if no element satisfy that predicate.  If the collector is empty, <code>std::none_of</code> returns <code>true</code>.</li>
</ul>
<h1 id="QUERYING-A-PROPERTY-ON-2-RANGES"><a href="#QUERYING-A-PROPERTY-ON-2-RANGES" class="headerlink" title="QUERYING A PROPERTY ON 2 RANGES"></a>QUERYING A PROPERTY ON 2 RANGES</h1><p>We can also query a property on two ranges, which is essentially different ways of comparing them. </p>
<h2 id="std-equal"><a href="#std-equal" class="headerlink" title="std::equal"></a>std::equal</h2><p>The simplest way to compare two ranges is to see if they have the exact same contents, and returns the boolean result.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118131011.png"><br>Besides, we’d like to know if the two collections contain the same elements but not necessarily in the same order, that’s <code>std::is_permutation</code>.</p>
<h2 id="std-lexicographical-compare"><a href="#std-lexicographical-compare" class="headerlink" title="std::lexicographical_compare"></a>std::lexicographical_compare</h2><p>Now we can also compare ranges and say which one is smaller than the other one. To define the smaller, we could go with size. That’s not very precise, there’s another way to do that is going back to the alphabetical, lexicographical ordering.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118131257.png"></p>
<h2 id="std-mismatch"><a href="#std-mismatch" class="headerlink" title="std::mismatch"></a>std::mismatch</h2><p>The last algorithm of comparing two ranges is to traverse them both and stop whenever they start to differ. This is <code>std::mismatch</code>. And returns the <code>std::pair&lt;Iterator, Iterator&gt;</code> iterators pointing to the respective position of where they start to differ in the two collections.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118131543.png"></p>
<h1 id="SEARCHING-A-VALUE"><a href="#SEARCHING-A-VALUE" class="headerlink" title="SEARCHING A VALUE"></a>SEARCHING A VALUE</h1><p>A classic thing to extract in a collection is a position, like looking for something, or to look for something in a collection now, essentially, two ways to do that. It depends on whether the collection is sorted or not sorted. If it’s sorted, we can use a binary search. If not sorted, we have to go through the collection from the beginning.</p>
<h2 id="std-find"><a href="#std-find" class="headerlink" title="std::find"></a>std::find</h2><p><code>std::find</code> takes <code>begin</code>, <code>end</code> and <code>value</code>, and returns the iterator where pointing to that value, or <code>end</code> if that value is not found. Now, it has a sort of like twin brother that’s much less famous, but quite useful as well, and it’s called <code>std::adjacent_find</code>, and that returns the first position where two adjacent value occur and are equal to the value search. So <code>std::adjacent_find</code> takes a <code>beginning</code> and an <code>end</code> and a <code>value</code> and returns the first position where two of those values appear in a row.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118132431.png"></p>
<p>On the sorted range, we are not really looking for a value, because searching for a given value, it could be at several places, and since it’s sorted, they would be lumped together.</p>
<ul>
<li><code>std::equal_range</code>: returns a sub-range which all elements in this sub-range are equal to the given value.</li>
<li><code>std::lower_bound</code>&#x2F;<code>std::upper_bound</code>: and that only indicate position to insert elements.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221118132851.png"></p>
<ul>
<li><code>std::binary_search</code>: It takes a beginning and an end and a value, and only tells you whether it’s there or not, but doesn’t tell you where it found it. And it uses a binary search which is a good thing.</li>
</ul>
<h1 id="SEARCHING-A-RANGE"><a href="#SEARCHING-A-RANGE" class="headerlink" title="SEARCHING A RANGE"></a>SEARCHING A RANGE</h1><p>It is looking for a sub-range in a bigger range. To do that, there’s an algorithm that has a very bizarre name, because it’s called search. Search says it will try to find it. It searches a sub-range into a range.</p>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119141600.png"></p>
<ul>
<li><code>std::search</code>: Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first, last).</li>
<li><code>std::find_end</code>: Searches for the last occurrence of the sequence [s_first, s_last) in the range [first, last).</li>
<li><code>std::find_first_of</code>: Searches the range [first, last) for any of the elements in the range [s_first, s_last).</li>
</ul>
<h1 id="SEARCHING-A-RELATIVE-VALUE"><a href="#SEARCHING-A-RELATIVE-VALUE" class="headerlink" title="SEARCHING A RELATIVE VALUE"></a>SEARCHING A RELATIVE VALUE</h1><p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119142231.png"></p>
<ul>
<li><code>std::max_element</code>: Finds the greatest element in the range [first, last). Elements are compared using operator <code>&lt;</code>. Or elements are compared using the given binary comparison function <code>comp</code>. It returns an iterator which points to the max element.</li>
<li><code>std::min_element</code>: Finds the smallest element in the range[first, last). It also uses either operator <code>&lt;</code> or given binary comparison function <code>comp</code>. It returns an iterator which points to the min element.</li>
<li><code>std::minmax_element</code>: Finds the smallest and greatest element in the range [first, last). It uses operator <code>&lt;</code> or specified comparison function <code>comp</code>. It returns a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns <code>std::make_pair(first, first)</code> if the range is empty.</li>
</ul>
<h1 id="ALGORITHMS-ON-SETS"><a href="#ALGORITHMS-ON-SETS" class="headerlink" title="ALGORITHMS ON SETS"></a>ALGORITHMS ON SETS</h1><p>What is sets? It includes <code>std::set</code>, but not only. In C++, we call any sorted collection as <code>set</code>. So a <code>std::set</code> is sorted and is a set, but sorted vector, for the purpose of the STL algorithms, is also considered as a set.</p>
<h2 id="std-set-difference"><a href="#std-set-difference" class="headerlink" title="std::set_difference"></a><code>std::set_difference</code></h2><p>Copies the elements from the sorted range [first1, last1) which are not found in the sorted range [first2, last2) to the range beginning at d_first.</p>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119143248.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt1, <span class="keyword">typename</span> InputIt2,</span><br><span class="line">          <span class="keyword">typename</span> OutputIt&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_difference</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IntputIt1, <span class="keyword">typename</span> InputIt2,</span><br><span class="line">          <span class="keyword">typename</span> OutputIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">set_difference</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        OutputIt d_first, Compare comp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt1, <span class="keyword">typename</span> InputIt2,</span><br><span class="line">          <span class="keyword">typename</span> OutputIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> OutputIt</span></span><br><span class="line"><span class="function"><span class="title">set_difference</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">               InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">               OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IntputIt1, <span class="keyword">typename</span> InputIt2,</span><br><span class="line">          <span class="keyword">typename</span> OutputIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> OutputIt</span></span><br><span class="line"><span class="function"><span class="title">set_difference</span><span class="params">(InputIt1 first1, InputIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">               InputIt2 first2, InputIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">               OutputIt d_first, Compare comp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy, <span class="keyword">typename</span> ForwardIt1,</span><br><span class="line">          <span class="keyword">typename</span> ForwardIt2, <span class="keyword">typename</span> ForwardIt3,</span><br><span class="line">          <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function">ForwardIt3 <span class="title">set_difference</span><span class="params">(ExecutionPolicy &amp;&amp;policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ForwardIt1 first1, ForwardIt1 last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ForwardIt2 first2, ForwardIt2 last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ForwardIt3 d_first, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>This is a common usage like this. During <code>set_difference</code>, the new value would be <code>push_back</code> into the <code>result</code> vector. It’s an inner complexity because it uses the fact that the input that sorted and also its output is sorted.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; results;</span><br><span class="line">std::<span class="built_in">set_difference</span>(std::<span class="built_in">begin</span>(A), std::<span class="built_in">end</span>(A),</span><br><span class="line">                    std::<span class="built_in">begin</span>(B), std::<span class="built_in">end</span>(B),</span><br><span class="line">                    std::<span class="built_in">back_inserter</span>(results));</span><br></pre></td></tr></table></figure>
<h2 id="std-set-difference-1"><a href="#std-set-difference-1" class="headerlink" title="std::set_difference"></a>std::set_difference</h2><p><code>std::set_difference</code> has siblings <code>std::set_intersection</code> that returns collections that they are both in <code>A</code> and <code>B</code> sets.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119144329.png"></p>
<h2 id="std-set-union"><a href="#std-set-union" class="headerlink" title="std::set_union"></a>std::set_union</h2><p><code>std::set_union</code> returns elements that are in <code>A</code> or <code>B</code>.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119144512.png"></p>
<h2 id="std-set-symmetric-difference"><a href="#std-set-symmetric-difference" class="headerlink" title="std::set_symmetric_difference"></a>std::set_symmetric_difference</h2><p><code>std::set_symmetric_difference</code>  that returns the elements are in <code>A</code> and not in <code>B</code> and those that are in <code>B</code> and not in <code>A</code>.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119144527.png"></p>
<h2 id="std-includes"><a href="#std-includes" class="headerlink" title="std::includes"></a>std::includes</h2><p><code>std::includes</code> that returns a boolean that indicates whether all the elements of B are also in <code>A</code>.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119144719.png"></p>
<h2 id="std-merge"><a href="#std-merge" class="headerlink" title="std::merge"></a>std::merge</h2><p><code>std::merge</code> that takes two sorted collections, and puts them together into one big sorted collections.</p>
<h1 id="MOVERS"><a href="#MOVERS" class="headerlink" title="MOVERS"></a>MOVERS</h1><p>Movers are algorithms that move thins around.</p>
<h2 id="std-copy"><a href="#std-copy" class="headerlink" title="std::copy"></a>std::copy</h2><p>The simplest way to move things around is probably to copy them.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119145357.png"></p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p><code>std::move</code> is the algorithm that it takes a beginning and an end and an output iterator just like <code>std::copy</code>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since C++11, until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> OutputIt&gt;</span><br><span class="line"><span class="function">OutputIt <span class="title">move</span><span class="params">(InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">              OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IntputIt, <span class="keyword">typename</span> OutputIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> OutputIt <span class="title">move</span><span class="params">(InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                        OutputIt d_first)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy,</span><br><span class="line">          <span class="keyword">typename</span> ForwardIt1, <span class="keyword">typename</span> ForwardIt2&gt;</span><br><span class="line"><span class="function">ForwardIt2 <span class="title">move</span><span class="params">(ExecutionPolicy &amp;&amp;policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                ForwardIt1 first, ForwardIt1 last,</span></span></span><br><span class="line"><span class="params"><span class="function">                ForwardIt2 d_first)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Moves the elements in the range [first, last), to another range beginning at d_first, starting from <code>first</code> and proceeding to <code>last - 1</code>.</p>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119153024.png"></p>
<h2 id="std-swap-ranges"><a href="#std-swap-ranges" class="headerlink" title="std::swap_ranges"></a>std::swap_ranges</h2><p><code>std::swap_ranges</code> swap the contents of two ranges. Obviously have to be the same size.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119153222.png"></p>
<h2 id="std-copy-backward"><a href="#std-copy-backward" class="headerlink" title="std::copy_backward"></a>std::copy_backward</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirIt1, <span class="keyword">typename</span> BidirIt2&gt;</span><br><span class="line"><span class="function">BidirIt2 <span class="title">copy_backward</span><span class="params">(BidirIt1 first, BidirIt1 last,</span></span></span><br><span class="line"><span class="params"><span class="function">                       BidirIt2 d_last)</span></span>;</span><br><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirIt1, <span class="keyword">typename</span> BidirIt2&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> BidirIt2 <span class="title">copy_backward</span><span class="params">(BidirIt1 first, BidirIt1 last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 BidirIt2 d_last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Copies the elements from the range, defined by[first, last), to another range ending at d_last. The elements are copied in reverse order (the last element is copies first), but their relative order is preserved.</p>
<p>The possible implementation is like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirIt1, BidirIt2&gt;</span><br><span class="line"><span class="function">BidirIt2 <span class="title">copy_backward</span><span class="params">(BidirIt1, first, BidirIt1 last,</span></span></span><br><span class="line"><span class="params"><span class="function">                       BidirIt2 d_last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last)</span><br><span class="line">    *(--d_last) = *(--last);</span><br><span class="line">  <span class="keyword">return</span> d_last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is as same as <code>std::move_backward</code> except <code>std:move_backward</code> moves elements to the new container.</p>
<h1 id="VALUE-MODIFIERS"><a href="#VALUE-MODIFIERS" class="headerlink" title="VALUE MODIFIERS"></a>VALUE MODIFIERS</h1><p><code>std::fill</code>&#x2F;<code>std::iota</code>&#x2F;<code>std::generate</code>&#x2F;<code>std::replace</code>, these four algorithms actually changes the collection.</p>
<h2 id="std-fill"><a href="#std-fill" class="headerlink" title="std::fill"></a>std::fill</h2><p><code>std::fill</code> puts the same value in every collection.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119154527.png"></p>
<h2 id="std-generate"><a href="#std-generate" class="headerlink" title="std::generate"></a>std::generate</h2><p><code>std::generate</code> uses a function that can be called with no arguments, and we call that function once for every element of the collection.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119154743.png"></p>
<h2 id="std-iota"><a href="#std-iota" class="headerlink" title="std::iota"></a>std::iota</h2><p><code>std::iota</code> is the another to feed a collection and that’s quite useful to have a quickly a sequence of values <code>std::iota</code>(pronounce: io-ta). It put that value at the beginning and then increment it and increment it until it fills the whole collection with increments.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119155132.png"></p>
<h2 id="std-replace"><a href="#std-replace" class="headerlink" title="std::replace"></a>std::replace</h2><p><code>std::replace</code> replaces the values in a collection like replace <code>42</code> to <code>43</code> in the whole collection <code>std::replace(first, last, 42, 43);</code>.</p>
<h1 id="STRUCTURE-CHANGERS"><a href="#STRUCTURE-CHANGERS" class="headerlink" title="STRUCTURE CHANGERS"></a>STRUCTURE CHANGERS</h1><p>These algorithms that after I’ve down that drove the collection does not look the same even from a far so. There are two of them <code>std::remove</code> and <code>std::unique</code>.</p>
<h2 id="std-remove"><a href="#std-remove" class="headerlink" title="std::remove"></a>std::remove</h2><p><code>std::remove</code> is used to remove values but has something peculiar with it since STL algorithms only access the iterators of a collection and not the collections themselves. They can not change the size. So the <code>std::remove</code> does is to pull up the collection by leaving only those that should not be removed. So if we want to remove a value, we use to remove this value, and pull up other values. And what is at the end is not specified. We can’t rely on it. This depends on compiler how to do this.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119160317.png"><br><code>std::remove</code> returns an iterator that points to the first that’s crossed out.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// erase all values that equals to 99.</span></span><br><span class="line">coll.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(std::<span class="built_in">bein</span>(coll),</span><br><span class="line">                       std::<span class="built_in">end</span>(coll), <span class="number">99</span>),</span><br><span class="line">           std::<span class="built_in">end</span>(coll));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Another version of erase. This is </span></span><br><span class="line"><span class="comment">// equivalent to the upper code.</span></span><br><span class="line">std::<span class="built_in">erase</span>(coll, <span class="number">99</span>);</span><br></pre></td></tr></table></figure>

<h2 id="std-erase"><a href="#std-erase" class="headerlink" title="std::erase"></a>std::erase</h2><p>Erase all elements that compare equal to value from the container.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::vector&lt;T, Alloc&gt;::<span class="function">size_type</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">(std::vector&lt;T, Alloc&gt;&amp; c, <span class="type">const</span> U&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">typename</span> Pred&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::vector&lt;T, Alloc&gt;::<span class="function">size_type</span></span><br><span class="line"><span class="function"><span class="title">erase_if</span><span class="params">(std::vector&lt;T, Alloc&gt;&amp; c, Pred pred)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This is equivalent to the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">remove</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(), value);</span><br><span class="line"><span class="keyword">auto</span> r = std::<span class="built_in">distance</span>(it, coll.<span class="built_in">end</span>());</span><br><span class="line">c.<span class="built_in">erase</span>(it, coll.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure>

<p>Erases all elements that satisfy the predicate pred from the container. Equivalent to:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">remove_if</span>(coll.<span class="built_in">begin</span>(), coll.<span class="built_in">end</span>(), pred);</span><br><span class="line"><span class="keyword">auto</span> r = std::<span class="built_in">distance</span>(it, coll.<span class="built_in">end</span>());</span><br><span class="line">coll.<span class="built_in">erase</span>(it, coll.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure>
<p>Returns the number of erased elements.</p>
<h2 id="std-unique"><a href="#std-unique" class="headerlink" title="std::unique"></a>std::unique</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collection.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(std::<span class="built_in">begin</span>(coll),</span><br><span class="line">                             std::<span class="built_in">end</span>(coll)),</span><br><span class="line">                 std::<span class="built_in">end</span>(coll));</span><br></pre></td></tr></table></figure>

<h2 id="COPY"><a href="#COPY" class="headerlink" title="*_COPY"></a>*_COPY</h2><p>We have seen all the algorithms that are combined with <code>_copy</code> in the STL algorithms library. You can tack it on an algorithm like those algorithms, it creates new algorithms that do the same thing but in a new collection, like remove or unique or replace or whatever, they operate in-place. Those <code>_copy</code> version, they leave the collection untouched and they take an output iterator, and they produce the output to that output iterator.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::remove_copy</span><br><span class="line">std::unique_copy</span><br><span class="line">std::reverse_copy</span><br><span class="line">std::rotate_copy</span><br><span class="line">std::replace_copy</span><br><span class="line">std::partition_copy</span><br><span class="line">std::partial_sort_copy</span><br></pre></td></tr></table></figure>

<h2 id="IF"><a href="#IF" class="headerlink" title="*_IF"></a>*_IF</h2><p><code>*_if</code> acts like a predicate. For example, find, <code>std::find_if</code> takes a value, and a predicate.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::find_if</span><br><span class="line">std::find_if_not</span><br><span class="line">std::count_if</span><br><span class="line">std::remove_if</span><br><span class="line">std::remove_copy_if</span><br><span class="line">std::replace_if</span><br><span class="line">std::replace_copy_if</span><br><span class="line">std::copy_if</span><br></pre></td></tr></table></figure>

<h1 id="LONELY-ISLANDS"><a href="#LONELY-ISLANDS" class="headerlink" title="LONELY ISLANDS"></a>LONELY ISLANDS</h1><p>There are two algorithms: <code>std::for_each</code> and <code>std::transform</code>.</p>
<h2 id="std-transform"><a href="#std-transform" class="headerlink" title="std::transform"></a>std::transform</h2><p><code>std::transform</code> applies a function to the elements of a collection. So it takes a collection, begin, end, a function f, and an output like an output iterator. And it produces the application of that function to every element of the collection.</p>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119164412.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(std::<span class="built_in">begin</span>(coll), std::<span class="built_in">end</span>(coll),</span><br><span class="line">               std::<span class="built_in">back_inserter</span>(results),</span><br><span class="line">               f);</span><br></pre></td></tr></table></figure>

<p>What’s a bit less famous about transform, it can take two collections as parameters. It applies that function just like transform with one input collection to the two collection by feeding the two collection into f for each element and producing the output.<br><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119164611.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(std::<span class="built_in">begin</span>(coll), std::<span class="built_in">end</span>(coll),</span><br><span class="line">               std::<span class="built_in">begin</span>(ys),</span><br><span class="line">               std::<span class="built_in">back_inserter</span>(results),</span><br><span class="line">               f);</span><br></pre></td></tr></table></figure>

<p>For example, if you like to sum the elements of two collection two by two, you can do that with one line of coding with transform and function f is <code>std::plus</code> which in the <code>&lt;functional&gt;</code> header file.</p>
<h2 id="std-for-each"><a href="#std-for-each" class="headerlink" title="std::for_each"></a>std::for_each</h2><p><code>std::for_each</code> takes a beginning, and an end, and some piece of code, a function, it could be a lambda or a regular function. So for puror of <code>for_each</code>, <code>f</code> might as well return <code>void</code>.</p>
<p><code>std::for_each</code> is made to perform side-effects.</p>
<p>Using <code>std::for_each</code> for making anything else, such as a partition or a find or whatever, is not the right usage of <code>for_each</code>. There are algorithms that are more appropriate than <code>for_each</code>, and if there’s no algorithm more appropriate than <code>for_each</code> in the STL algorithms, then the algorithms outside of the STL algorithm.</p>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119170449.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Until C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> UnaryFunction&gt;</span><br><span class="line"><span class="function">UnaryFunction <span class="title">for_each</span><span class="params">(InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                       UnaryFunction f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++20</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> UnarFunction&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> UnaryFunction <span class="title">for_each</span><span class="params">(InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 UnaryFunction f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy <span class="keyword">typename</span> ForwardIt,</span><br><span class="line">          <span class="keyword">typename</span> UnaryFunction2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(ExecutionPolicy &amp;&amp;policy,</span></span></span><br><span class="line"><span class="params"><span class="function">              ForwardIt first, ForwardIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">              UnaryFunction2 f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This Applies the given function object f to the result of de-referencing every iterator in the range [first, last), in order.</p>
<p>The possible implementation is like this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> UnaryFunction&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> UnaryFunction <span class="title">for_each</span><span class="params">(InputIt first, InputIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 UnaryFunction f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">    <span class="built_in">f</span>(*first);</span><br><span class="line">  <span class="keyword">return</span> f; <span class="comment">// implicit move since C++11.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::for_each(std::<span class="built_in">begin</span>(coll), std::<span class="built_in">end</span>(coll), f);</span><br></pre></td></tr></table></figure>

<h1 id="RAW-MEMORY"><a href="#RAW-MEMORY" class="headerlink" title="RAW MEMORY"></a>RAW MEMORY</h1><p>There are three algorithms, <code>std::fill</code>&#x2F;<code>std::copy</code>&#x2F;<code>std::move</code>, which are performed on raw memory. They have one thing in common, it’s that they use the assignment operator.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::fill -&gt; operator= ---&gt; uninitialized_fill (calls ctor)</span><br><span class="line">std::copy -&gt; operator= ---&gt; uninitialized_copy (calls copy ctor)</span><br><span class="line">std::move -&gt; operator= ---&gt; unititialized_move (calls move ctor)</span><br></pre></td></tr></table></figure>

<p>Now if we use an assignment operator,  it means that the object has been constructed, and hopefully that’s true. But in some rare cases, we have objects that are not constructed yet. If we have just the memory, just chunks of memory that we got from somewhere, and we’d like to construct instead of calling the assignment operator, we’d like to call constructor on those chunks of memory. For that, we use the <code>unitialized</code> counterpart. This is the constructor that takes a value. So, in practice, you get a chunk of memory from somewhere, like shared memory or wherever. And you would like to fill it with values but you can’t call fill because you can’t call the assignment operator because there is just raw memory, it hasn’t been initialized yet. So we need to call the constructor. This is what <code>std::unitialized_fill</code> does. It takes two pointers for at the beginning and the end, and calls the value constructor, leading to an initialization of that chunk of memory.</p>
<p><img src="https://raw.githubusercontent.com/wtffqbpl/blog-images/main/20221119172120.png"></p>
<p>Now, once we are done with it, we want to call the destructor, if we are in charge to call the destructor. That’s what <code>std::destroy</code> does. But we don’t really use it on a day-to-day basis.</p>
<p><code>std:::destroy(first, last)</code></p>
<p>The definition of <code>std::unitialized_fill</code> is as follows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIt, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unitialized_fill</span><span class="params">(ForwardIt first, ForwardIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionPolicy, <span class="keyword">typename</span> ForwardIt,</span><br><span class="line">          <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unitialized_fill</span><span class="params">(ExecutionPolicy &amp;&amp;policy,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ForwardIt first, ForwardIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Copies the given value to an uninitialized memory are, defined by the range[first, last) as if by:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">  ::<span class="keyword">new</span>(<span class="comment">/*VOIDIFY*/</span>(*first))</span><br><span class="line">  <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIt&gt;::<span class="built_in">value_type</span>(value);</span><br></pre></td></tr></table></figure>
<p>Where <code>/*VOIDIFY*/(e)</code> is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;e); <span class="comment">// until C++11</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(std::<span class="built_in">addressof</span>(e)); <span class="comment">// Since C++11, Until C++20</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span>*&gt;(std::<span class="built_in">addressof</span>(e))); <span class="comment">// Since C++20</span></span><br></pre></td></tr></table></figure>

<p>The possible implementation is as follows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIt, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIt first, ForwardIt last,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> V = tyepname std::iterator_traits&lt;ForwardIt&gt;::value_type;</span><br><span class="line">  ForwardIt current = first;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; current != last; ++current) &#123;</span><br><span class="line">      ::<span class="keyword">new</span> (<span class="built_in">const_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span>*&gt;(</span><br><span class="line">          std::<span class="built_in">addressof</span>(*current)))) <span class="built_in">V</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != current; ++first)</span><br><span class="line">      first-&gt;~<span class="built_in">V</span>();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The examples:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string* p;</span><br><span class="line">  std::<span class="type">size_t</span> sz;</span><br><span class="line">  std::<span class="built_in">tie</span>(p, sz) = std::<span class="built_in">get_temporary_buffer</span>&lt;std::string&gt;(<span class="number">4</span>);</span><br><span class="line">  </span><br><span class="line">  std::<span class="built_in">uninitialized_fill</span>(p, p + sz, <span class="string">&quot;Example&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (std::string *i = p; i != p + sz; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    i-&gt;~<span class="built_in">basic_string</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">return_temporary_buffer</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Another case is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> n&#123;<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">alignas</span>(<span class="built_in">alignof</span>(std::string)) <span class="type">char</span> out[<span class="function">n * <span class="title">sizeof</span><span class="params">(std::string)</span>]</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> first&#123;<span class="built_in">reinterpret_cast</span>&lt;std::string*&gt;(out)&#125;;</span><br><span class="line">    <span class="keyword">auto</span> last&#123;first + n&#125;;</span><br><span class="line">    std::ranges::<span class="built_in">unitialized_fill</span>(first, last, <span class="string">&quot;▄▀▄▀▄▀▄▀&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it&#123;first&#125;; it != last; ++it)</span><br><span class="line">      std::cout &lt;&lt; count++ &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::ranges::<span class="built_in">destroy</span>(first, last);</span><br><span class="line">  &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Exception!\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="N"><a href="#N" class="headerlink" title="*_N"></a>*_N</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">copy_n</span><br><span class="line">fill_n</span><br><span class="line">generate_n</span><br><span class="line">search_n</span><br><span class="line">for_each_n</span><br><span class="line">uninitialized_copy_n</span><br><span class="line">uninitialized_fill_n</span><br><span class="line">uninitialized_move_n</span><br><span class="line">uninitialized_default_construct_n</span><br><span class="line">uninitialized_value_construct_n</span><br><span class="line">destroy_n</span><br></pre></td></tr></table></figure>

<p>For example, we perform the <code>std::fill</code> on a collector. If we use <code>std::fill_n</code> takes beginning, size, and a value, and it fills the first five elements starting from the beginning.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">fill</span>(std::<span class="built_in">begin</span>(coll), std::<span class="built_in">end</span>(coll), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This fills 5 elements in coll with 42</span></span><br><span class="line"><span class="comment">// from the beginning, </span></span><br><span class="line">std::<span class="built_in">fill_n</span>(std::<span class="built_in">begin</span>(coll), <span class="number">5</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">fill_n</span>(std::<span class="built_in">back_inserter</span>(coll), <span class="number">5</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h1 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h1><p>STL algorithms can make code more expressive. There are serval tips for your code to use STL algorithms more.</p>
<ul>
<li>Replace your <code>for</code>-loops by the right algorithm.<br>By an STL algorithm to make it smoother to work with.</li>
<li>More algorithms<br>Boost.Algorithms: <code>gather</code>, <code>sort_subrange</code>, <code>is_palindrome</code>, <code>boyer_moore</code>, <code>one_of</code>, etc.</li>
<li>Understand in depths the STL algorithms.<br>Algorithmic complexity<br>Pre&#x2F;post - requisites, like think about sorted collections for example.<br>Look at the implementation. See how they are implemented, that is often quite instructive.</li>
<li>Get inspired. If you can get inspired, you can have a better intuition of what abstractions work well. That’s the fundamental of writing code, and that intuition, you can use that in our own code. Once you are familiar enough, you can start thinking about writing your own algorithms. Well, we can combine an algorithm, an existing algorithm with a rune, like <code>sort_copy</code> doesn’t exist. Besides, you can enrich a family, like <code>set_segregate</code>. Also, you can start a new STL family.</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>C++ STL Overview</p><p><a href="https://wtffqbpl.github.io/2022/11/17/C-STL-Overview/">https://wtffqbpl.github.io/2022/11/17/C-STL-Overview/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yuanjun Ren</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-11-17</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a><a class="link-muted mr-2" rel="tag" href="/tags/STL/">STL</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay-qrcode.jpg" alt="Alipay"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechat-qrcode.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/11/14/C-learning-lists/"><span class="level-item">C++ learning lists</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "f2a137eccfc73fd28d6e7f953dce5925",
            repo: "wtffqbpl.github.io",
            owner: "wtffqbpl",
            clientID: "91ed89a1c2b6427b0731",
            clientSecret: "133fc04688d9a06b6d46e34f1e40909bd5780033",
            admin: ["wtffqbpl"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/profile.jpg" alt="Yuanjun Ren"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yuanjun Ren</p><p class="is-size-6 is-block">C++ Programmer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an/China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wtffqbpl" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wtffqbpl"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/yuanjun-ren-5a7949bb"><i class="fab fa-linkedin"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Heaps"><span class="level-left"><span class="level-item">1</span><span class="level-item">Heaps</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-make-heap"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">std::make_heap</span></span></a></li><li><a class="level is-mobile" href="#std-push-heap"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">std::push_heap</span></span></a></li><li><a class="level is-mobile" href="#std-pop-heap"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">std::pop_heap</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SORTING"><span class="level-left"><span class="level-item">2</span><span class="level-item">SORTING</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-sort"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">std::sort</span></span></a></li><li><a class="level is-mobile" href="#std-partial-sort"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">std::partial_sort</span></span></a></li><li><a class="level is-mobile" href="#std-nth-element"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">std::nth_element</span></span></a></li><li><a class="level is-mobile" href="#std-sort-heap"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">std::sort_heap</span></span></a></li><li><a class="level is-mobile" href="#std-inplace-merge"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">std::inplace_merge</span></span></a></li></ul></li><li><a class="level is-mobile" href="#PARTITIONING"><span class="level-left"><span class="level-item">3</span><span class="level-item">PARTITIONING</span></span></a></li><li><a class="level is-mobile" href="#PERMUTATIONS"><span class="level-left"><span class="level-item">4</span><span class="level-item">PERMUTATIONS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-rotate"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">std::rotate</span></span></a></li><li><a class="level is-mobile" href="#std-shuffle"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">std::shuffle</span></span></a></li><li><a class="level is-mobile" href="#std-next-permutation-x2F-std-prev-permutation"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">std::next_permutation/std::prev_permutation</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SECRET-RUNES"><span class="level-left"><span class="level-item">5</span><span class="level-item">SECRET RUNES</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#PARTITIONING-SORT-HEAP"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">PARTITIONING-SORT-HEAP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#stable-rune"><span class="level-left"><span class="level-item">5.1.1</span><span class="level-item">stable_* rune</span></span></a></li><li><a class="level is-mobile" href="#is-rune"><span class="level-left"><span class="level-item">5.1.2</span><span class="level-item">is_* rune</span></span></a></li><li><a class="level is-mobile" href="#is-until"><span class="level-left"><span class="level-item">5.1.3</span><span class="level-item">is_*_until</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#QUERIES"><span class="level-left"><span class="level-item">6</span><span class="level-item">QUERIES</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-count"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">std::count</span></span></a></li><li><a class="level is-mobile" href="#std-accumulate-x2F-transform-reduce"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">std::accumulate/(transform_)reduce</span></span></a></li><li><a class="level is-mobile" href="#std-partial-sum"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">std::partial_sum</span></span></a></li><li><a class="level is-mobile" href="#std-inner-product"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">std::inner_product</span></span></a></li><li><a class="level is-mobile" href="#std-adjacent-difference"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">std::adjacent_difference</span></span></a></li><li><a class="level is-mobile" href="#std-sample"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">std::sample</span></span></a></li></ul></li><li><a class="level is-mobile" href="#QUERYING-A-PROPERTY"><span class="level-left"><span class="level-item">7</span><span class="level-item">QUERYING A PROPERTY</span></span></a></li><li><a class="level is-mobile" href="#QUERYING-A-PROPERTY-ON-2-RANGES"><span class="level-left"><span class="level-item">8</span><span class="level-item">QUERYING A PROPERTY ON 2 RANGES</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-equal"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">std::equal</span></span></a></li><li><a class="level is-mobile" href="#std-lexicographical-compare"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">std::lexicographical_compare</span></span></a></li><li><a class="level is-mobile" href="#std-mismatch"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">std::mismatch</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SEARCHING-A-VALUE"><span class="level-left"><span class="level-item">9</span><span class="level-item">SEARCHING A VALUE</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-find"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">std::find</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SEARCHING-A-RANGE"><span class="level-left"><span class="level-item">10</span><span class="level-item">SEARCHING A RANGE</span></span></a></li><li><a class="level is-mobile" href="#SEARCHING-A-RELATIVE-VALUE"><span class="level-left"><span class="level-item">11</span><span class="level-item">SEARCHING A RELATIVE VALUE</span></span></a></li><li><a class="level is-mobile" href="#ALGORITHMS-ON-SETS"><span class="level-left"><span class="level-item">12</span><span class="level-item">ALGORITHMS ON SETS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-set-difference"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">std::set_difference</span></span></a></li><li><a class="level is-mobile" href="#std-set-difference-1"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">std::set_difference</span></span></a></li><li><a class="level is-mobile" href="#std-set-union"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">std::set_union</span></span></a></li><li><a class="level is-mobile" href="#std-set-symmetric-difference"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">std::set_symmetric_difference</span></span></a></li><li><a class="level is-mobile" href="#std-includes"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">std::includes</span></span></a></li><li><a class="level is-mobile" href="#std-merge"><span class="level-left"><span class="level-item">12.6</span><span class="level-item">std::merge</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MOVERS"><span class="level-left"><span class="level-item">13</span><span class="level-item">MOVERS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-copy"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">std::copy</span></span></a></li><li><a class="level is-mobile" href="#std-move"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">std::move</span></span></a></li><li><a class="level is-mobile" href="#std-swap-ranges"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">std::swap_ranges</span></span></a></li><li><a class="level is-mobile" href="#std-copy-backward"><span class="level-left"><span class="level-item">13.4</span><span class="level-item">std::copy_backward</span></span></a></li></ul></li><li><a class="level is-mobile" href="#VALUE-MODIFIERS"><span class="level-left"><span class="level-item">14</span><span class="level-item">VALUE MODIFIERS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-fill"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">std::fill</span></span></a></li><li><a class="level is-mobile" href="#std-generate"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">std::generate</span></span></a></li><li><a class="level is-mobile" href="#std-iota"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">std::iota</span></span></a></li><li><a class="level is-mobile" href="#std-replace"><span class="level-left"><span class="level-item">14.4</span><span class="level-item">std::replace</span></span></a></li></ul></li><li><a class="level is-mobile" href="#STRUCTURE-CHANGERS"><span class="level-left"><span class="level-item">15</span><span class="level-item">STRUCTURE CHANGERS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-remove"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">std::remove</span></span></a></li><li><a class="level is-mobile" href="#std-erase"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">std::erase</span></span></a></li><li><a class="level is-mobile" href="#std-unique"><span class="level-left"><span class="level-item">15.3</span><span class="level-item">std::unique</span></span></a></li><li><a class="level is-mobile" href="#COPY"><span class="level-left"><span class="level-item">15.4</span><span class="level-item">*_COPY</span></span></a></li><li><a class="level is-mobile" href="#IF"><span class="level-left"><span class="level-item">15.5</span><span class="level-item">*_IF</span></span></a></li></ul></li><li><a class="level is-mobile" href="#LONELY-ISLANDS"><span class="level-left"><span class="level-item">16</span><span class="level-item">LONELY ISLANDS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#std-transform"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">std::transform</span></span></a></li><li><a class="level is-mobile" href="#std-for-each"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">std::for_each</span></span></a></li></ul></li><li><a class="level is-mobile" href="#RAW-MEMORY"><span class="level-left"><span class="level-item">17</span><span class="level-item">RAW MEMORY</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#N"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">*_N</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CONCLUSION"><span class="level-left"><span class="level-item">18</span><span class="level-item">CONCLUSION</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><!--!--><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-14/"><span class="tag">C++14</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-17/"><span class="tag">C++17</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C-20/"><span class="tag">C++20</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CMake/"><span class="tag">CMake</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLVM/"><span class="tag">LLVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Meta-Programming/"><span class="tag">Meta-Programming</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-16T16:34:10.000Z">2022-11-17</time></p><p class="title"><a href="/2022/11/17/C-STL-Overview/">C++ STL Overview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-13T18:18:06.000Z">2022-11-14</time></p><p class="title"><a href="/2022/11/14/C-learning-lists/">C++ learning lists</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-13T10:35:17.000Z">2022-11-13</time></p><p class="title"><a href="/2022/11/13/Aggregate-Initialization/">Aggregate Initialization</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-12T18:34:20.000Z">2022-11-13</time></p><p class="title"><a href="/2022/11/13/C-Lambda-Idioms/">C++ Lambda Idioms</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-08T04:54:15.000Z">2022-11-08</time></p><p class="title"><a href="/2022/11/08/Lambda-Expression/">Lambda Expression</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://coderchenlin.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lin&#039;s Blog</span></span><span class="level-right"><span class="level-item tag">coderchenlin.github.io</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Yuanjun&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Yuanjun Ren</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wtffqbpl/wtffqbpl.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><style>.searchbox .searchbox-body { background: white; }</style><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"><gcse:searchresults-only></gcse:searchresults-only></div></div><script>(function() {
            var cx = 'd795d66993bb247ae';
            var gcse = document.createElement('script');
            gcse.type = 'text/javascript';
            gcse.async = true;
            gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(gcse, s);
        })();</script></div><script src="/js/google_cse.js"></script></body></html>