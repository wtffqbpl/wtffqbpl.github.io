{"posts":[{"title":"Aggregate Initialization","text":"An aggregate is one of the following types: array type class type (typically, struct or union), that has no private or protected non-static data members no user-declared constructors no user-provided, inherited, or explicit constructors no user-declared or inherited constructors no virtual, private, or protected base classes no virtual member functions no default member initializers If we have a struct which has a single integer in it. We would need to do something like initialize the integer class member. If we use the C++03 standard, we must have a constructor for this initialization. The code is as follows. 123456789struct S { S(int s_i) : i(s_i) {} int i;};int main() { S s(1); return s.i;} Now the C++11, we were given the ability to do this uniform initialization syntax. So instead of doing a constructor, we can do this brace initialization syntax. And this works for however many elements you happen to have. 123456789101112struct S { int i; float f;};int main() { S s{1, 5.4f}; // We can see a truncation of the floating point value // 5.4 -&gt; 5 on the return statement from main here. return s.f;} Well, what happens when we introduce class hierarchy here. We have a base class. We get an error if we actually use inheritance from our struct S and that there is no matching constructor for initialization of s. Because we don’t have any way to initialize the base class. 12345678910111213141516struct B { double d;};struct S : B { int i; float f;};int main() { S s{1, 2.3}; // Error: no matching constructor for // initialization of 'S'. return s.f;} So what C++17 is giving us is the ability to explicitly specify that we want the base class initialized also. 1234567891011121314151617181920212223242526#include &lt;iostream&gt;struct B { double d;};struct S : B { int i; float f;};int main() { // Here, we use the default initialization of // the members of struct B. S s{{}, 1, 2.3}; // Here when we return d in base class B, we // return 0 since d is the default initialization. std::cout &lt;&lt; int(s.d) &lt;&lt; std::endl; // 0 // If we specify the value for d in base class B, // then we've got truncated value as we would expect. S s2{{54.3}, 1, 2.3}; std::cout &lt;&lt; int(s2.d) &lt;&lt; std::endl; // 54 return 0;} So we now have with our uniform initialization syntax a way of initializing base class objects Aggregate InitializationAggregate initialization, for example, an array initialize. So we could always initialize like this with a list initialization which is then going to perform aggreagte initialization. So list initialization means you have these braces. In C++20, we can now instead of the braces use parents which is direct initialization. 123// aggregate initializationint a1[]{1, 2, 3};int a1[](1, 2, 3); Why C++ committee do this? Because you couldn’t really perfect forward aggregates before C++20, that just wasn’t possible. Now you can implement emplace_back so now you can in-place aggregates in C++20. The other thing you can now do which is a little bit more like rare. You couldn’t really do aggregate initialization inside a macro because if you had inside the macro if you have curlies and then you have a comma in there the compiler would think that that’s then the next macro argument after the comma and then the puzzle will just explode. Now you can use parents so that actually compiles and now works since C++20. 1234567891011struct A { int i; bool b;};int main() { std::vector&lt;A&gt; v; v.emplace_back(42, true); // works since C++20 return 0;} Aggregate init inside a macro.123456789101112131415struct A { int i; bool b; bool isValid() const { return i == 42; }};int main() { // Error: parser explodes :( assert(A{42, true}.isValid()); // OK since C++20 assert(A(42, true).isValid()); return 0;} So introduce this feature, we solved two problems. Narrowing conversions.123456789struct A { int i; bool b;};// Error: narrowing conversion from 'double' to 'int'.A a1{42.5, true};// OKA a2(42.5, true); Brace elision. If you have a brace elision like that you have a nested aggregate. So you have an aggregate inside an aggregate. If you do curlys, you get brace solutions so you can basically do the flat right out the flat initializations and it’s going to recurse into the sub aggregates. But the parents doesn’t work. 123456789101112struct A { int i; bool b;};struct AA { A a1; A a2;};AA aa1{42, true, 43, false}; // OKAA aa1(42, true, 43, false); // Error Lifetime Extension of Temporary ObjectYou have a reference member, so what list initialization is going to do if you do aggregation via list initialization, it’s going to actually extend the lifetime of the reference if you initialize it with a temporary. 12345678910111213141516struct A { int&amp;&amp; i; bool b;};int main() { A a1{42, true}; // OK return a1.i; // returns 42 // If you use the parents, then you got // Dangling reference error, and then you // got a behavior and that is going to be // sad. A a2(42, true); // Dangling reference return a2.i; // Undefined behavior} Another case.If you have a struct A, which has one aggregation member, and have a non-aggregation member since struct C has a user-defined constructor. Then if you want to initialize this aggregate with a list initialization by just initialization both of these members. That works with curlys and works with parens. 123456789101112131415161718192021222324struct C { explicit C() = default;};struct A { int i; C c; // This is not aggregation member // since struct C has a user-defined // constructor.};auto a1 = A{42, C{}}; // OKauto a2 = A{42, C()}; // OK// Error: can't call explicit ctor.auto a3 = A{42};auto a4 = A(42);// Error: can't call explicit ctor.auto a5 = A{};// OK: value initialization,// NOT aggregate initialization!auto a6 = A(); auto a5 = A{}; is wrong, because you get an implicit initialized aggregate member, and if you do that with curlies, it is going to copy initialize that aggregate member as if by copy initialization from an empty braced init list. And copy initialization doesn’t work with explicit constructors, so you get a compiler error. auto a6 = A(); is OK. This is actually has a meaning, it has the meaning of value initialization since C++03, which is going to do zero initialization. This has the same meaning as before, so that’s going to just zero out the struct, and that’s fine. References Direct Aggregate Initialization - Timur Doumler C++17’s Aggregate Initializations Aggregate Initialization","link":"/2022/11/13/Aggregate-Initialization/"},{"title":"C++ Lambda Idioms","text":"The closure type for a lambda-expression has a public inline function call operator(for a non-generic lambda) or function call operator template (for a generic lambda) whose parameters and return type are described by the lambda-expression‘s parameter-declaration-clause and trailing-returning-type respectively, and whose template-parameter-list consists of the specified template-parameter-list, if any. The requires-clause of the function call operator template is the requires-clause immediately following &lt; template-parameter-list &gt;, if any. The trailing requires-clause of the function call operator or operator template is the requires-clause of the lambda-declarator, if any. 123[](const Person &amp;lhs, const Person &amp;rhs) { return lhs.name &lt; rhs.name;}; The version after compiled. Lambda has no default noexcept attribute, if you want the call operator to be noexcept, you have to write noexcept keyword. 12345678910111213141516struct __lambda_1 { inline bool operator()(const Person &amp;lhs, const Person &amp;rhs) const { return lhs.name &lt; rhs.name; }; // not default-constructible! __lambda_1() = delete; // not assignable! __lambda_1&amp; operator=(const __lambda_1&amp;) = delete;};// call a lambda// this instance is auto-generated by the// compiler, so no error.__lambda_1(); Do not capture anything.Lambdas do not have a state, so if the [] is empty, the lambda have an implicit conversion to raw function pointer. So we have some kind of legacy call here like C APIs do that very often they take a raw function pointer. 1234567891011void legacy_call(int(*f)(int)) { std::cout &lt;&lt; f(7) &lt;&lt; '\\n';}int main() { // OK, implicit conversion to function pointer. legacy_call([](int i) { return i * i; }); // prints 49 } Something like this: __func_type. 1234567891011121314151617181920212223struct __lambda_1 { inline bool operator()(const Person&amp; lhs, const Person&amp; rhs) const { return lhs.name &lt; rhs.name; }; // not default-constructible __lambda_1() = delete; // not copyable or assignable! __lambda_1&amp; operator=(const __lambda_1&amp;) = delete; using __func_type = bool(*)(const Person&amp;, const Person&amp;); inline operator __func_type() const noexcept { return &amp;__invoke; } private: static inline bool __invoke(const Person&amp; lhs, const Person&amp; rhs) { return lhs.name &lt; rhs.name; }}; Idiom 1: Unary Plus TrickDO NOT USE THIS IN PRODUCTION CODE. It’s kind of really interesting it teaches us something about lambda does work. We’ve already known that no-capturing lambda would implicitly convert to function pointer but what if we need explicit conversion to function pointer? 12345678910111213int main() { // this will introduce error since compiler cannot // deduce auto * type from i * i. auto *fptr = [](int i) { return i * i; }; // So we can use static_cast for explicitly casting. auto *fptr = static_cast&lt;int(*)(int)&gt;([](int i) { return i * i; }); // auto *fptr = +[](int i) { return i * i; }} The unary operator is obviously not defined for lambdas. However, the unary plus operator is defined for pointers including pointers to function. So if the compiler sees the unary plus operator, it says okay well that only works for pointers, therefore I’m going to implicitly convert this to a pointer. So your lambda is going to be implicitly converted to function pointer, and then a unary plus operator is going to be applied to that function pointer. And what does the unary plus operator do? When it applies to a pointer, nothing will do exactly. So all it does is it’s going to static_cast the lambda to a function pointer. Lambda CapturesCapture is when you capture a variable from the scope where the lambda expression is. So it means the lambda now has states. Capture by Value123int i = 0;int j = 0;auto f = [=] { reutrn i == j; }; After compiled: 123456789101112struct __lambda_2 { __lambda_2(int i, int j) : __i(i), __j(j) {} inline bool operator()() const { return __i == __j; } private: int __i; int __j;};__lambda_2(i, j); When the lambda captures two variables i and j, then compiler is going to add two private members data non-static data members to your closure type, and it’s going to initialize those data members with the values of the variables that you have captured. For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified. Capture by ReferenceWhen you capture by reference. 123int i = 0;int j = 0;auto f = [&amp;] { reutrn i == j; }; After compiled: 123456789101112struct __lambda_2 { __lambda_2(int &amp;i, int &amp;j) : __i(i), __j(j) {} inline bool operator()() const { return __i == __j; } private: int &amp;__i; int &amp;__j;};__lambda_2(i, j); When the lambda captures two variables i and j by reference, then compiler will add two private reference members. An entity is captured by reference if it is implicitly or explicitly captured but not captured by copy. It is unspecified whether additional unnamed non-static data members are declared in the closure type for entities captured by reference. If declared, such non-static data member shall be of literal type. Capture this12345678910struct X { void printAsync() { callAsync([this] { std::cout &lt;&lt; i &lt;&lt; '\\n'; }); } private: int i = 42;}; After compiled: 1234567891011121314151617struct X { void printAsync() { struct __lambda_3 { __lambda_3(X* _this) : __this(_this) {} void operator()() const { std::cout &lt;&lt; __this-&gt;i &lt;&lt; '\\n'; } private: X* __this; }; callAsync(__lambda_3(this)); } private: int i = 42;}; If you capture this, then you get to call members and member functions that object that you are in so that you can have lambda inside a member function of a class and just naturally refer to other members of that class inside that. Lambda Capture GotchasOne really important thing is that you can only capture local variables. For example, you can not capture the static variable i. 123456789int main() { static int i = 42; // This capture fails since lambda cannot capture // non-static variables. auto f = [=] { ++i; }; f(); return i; // return 43!} You actually don’t capture global variable, you are just accessing it. For example, the code is as follows, 12345678int i = 42;int main() { auto f = [] { ++i; }; f(); return i; // return 43!} You also don’t capture variables even if they are local if the lambda doesn’t ODR use them. You only capture the things that are ODR used inside the lambda. ODR are used is kind of a term from the standards you can again look it up what it means exactly. Such as the following case, the lambda expression uses constexpr variable. Because the constexpr is a compile-time expression that is not an ODR use of the variable, that means you don’t have to capture I. So again, the capture is empty, but you can use i for printing. However, if you want to take the address of that variable 12345678910111213int main() { constexpr int i = 42; // OK: 'i' is not odr-used auto f = [] { std::cout &lt;&lt; i &lt;&lt; '\\n'; }; f();}int main() { constexpr int i = 42; // ERROR: `i` is odr-used but not captured. auto f = [] { std::cout &lt;&lt; &amp;i &lt;&lt; '\\n'; }; f();} Besides, const int variable also can not be captured by lambda expression since const is implicit constexpr. 123456int main() { const int i = 42; // ERROR: `i` is odr-used but not captured. auto f = [] { std::cout &lt;&lt; &amp;i &lt;&lt; '\\n'; }; f();} If it has a const float not an integer type, therefore, this logic doesn’t apply. You must capture it if you want to use it inside the lambda. 12345int main() { const float f = 42; // ERROR: `f` is not captured. []{ std::cout &lt;&lt; f &lt;&lt; '\\n'; }();} The right way to use const float variable inside the lambda is as follows. 12345int main() { const float f = 42; // OK: `f` should be captured explicitly. [&amp;f] { std::cout &lt;&lt; f &lt;&lt; '\\n'; }();} Idiom 2: Immediately Invoked Function Expressions (IIFE)This idiom is so useful and it’s really practice and I think it can be useful in many situations. For example: What is Immediately Invoked Function Expressions? We don’t necessarily have to assign a lambda expression to a variable. So if we have a lambda expression hever, we can also instead just call it right there. This immediately invoked lambda are really useful. 123int main() { [] { std::cout &lt;&lt; &quot;Hello world\\n&quot;; }();} The following code is not a good practice for foo variable initialization. This if-else statement may introduce undefined behavior. Besides, if Foo class is not default-constructible, this code may not be compiled. The third issue is that if const Foo foo, we cannot assign to a const object using if-else statement. In java, if we use final keyword, this means foo variable is only be assigned once, so the following code could be compiled in java. But in C++, the const keyword means you only get to initialize it once and it has to be at the point where you declare it. So we have problem if we declare foo as const. 123456789101112int main() { // some code... const Foo foo; // Foo does not have default-constructible. if (hasDatabase) { // Error: cannot assign to const object. foo = getFooFromDatabase(); } else { // Error: cannot assign to const object. foo = getFooFromElsewhere(); }} Without lambda, we can use following method to solve this problem. But the code like this is ugly and unreadable. 12345int main() { const Foo foo = hasDatabase ? ? getFooFromDatabase() : getFooFromElsewhere();} The other method is that we can extract foo initialization process into a real function. This can split logic into other function, and initialization process is not localization anymore. If the initialization depends on local variables, you now have to pass these local variables as a parameter to function. So it all just gets messy. 1234567891011Foo getFoo() { if (hasDatabase) return getFooFromDatabase(); else return getFooFromElsewhere();}int main() { // some code... const Foo foo = getFoo();} If we use lambda, it should be great. Using immediately invoked lambda, you can just assign return value to foo, and this solves the problem. This also gets benefits for make_shared/make_unique all of that stuff. 123456789int main() { // some code... const Foo foo = [&amp;] { if (hasDatabase) return getFooFromDatabase(); else return getFooFromElsewhere(); }(); // immediately invoke lambda.} Using std::invoke function, it takes a function and calls it right away. This looks a little bit more visible because it’s like right there in the beginning. You actually could do more cool stuff with these immediately invoked lambdas. 12345678910int main() { // some code... std::vector&lt;Foo&gt; foos; foos.emplace_back(std::invoke([] { // since C++17 if (hasDatabase) return getFooFromDatabase(); else return getFooFromElsewhere(); }));} Idiom 3: Call-Once Lambda Daisy Hollman: “What you can learn from being too cute.” For example, here you have some kind of struct X and has a constructor. And you want to run this code when you construct an object but only once, and then never again. When we have more than one initialization calls, we still want this code bo only be called at the first time and never again. How you will do this? 12345678910struct X { X() { std::cout &lt;&lt; &quot;Called once!\\n&quot;; }};int main() { X x1; X x2; X x3; } Using static immediately invoked lambda, you can exactly only execute constructor once. Since C++11 if you initialize a static object, it’s guaranteed to be initialized exactly once. And this initialization is also thread safe. So which means you can actually initialize these X objects from multiple threads simultaneously, and you will still only call this constructor only once, and it’s going to be thread-safe. So the compiler will insert invisible locks to make sure it’s all thread-safe and to make sure that this code is only going to be called only once. There is one caveat here which is if you run this constructor a second time, there will be an implicit check which is some kind of atomic flag whether this has already been called yet in order to make sure that it’s not going to be called again. So this is going to be a little bit of a runtime overhead. 1234567891011121314struct X { X() { static auto _ = [] { std::cout &lt;&lt; &quot;Called once!\\n&quot;; return 0; } };();};int main() { X x1; X x2; X x3; } C++14 Generic LambdasWe can use auto keyword as lambda’s parameter type. This is really cool because the compiler is going to deduce the type for us. 12345678910111213std::map&lt;int, std::string&gt; httpErrors = { {400, &quot;Bad Request&quot;}, {401, &quot;Unauthorised&quot;}, {403, &quot;Forbidden&quot;}, {404, &quot;Not Found&quot;},};std::for_each( httpErrors.begin(), httpErrors.end(), [](const auto &amp;item) { std::cout &lt;&lt; item.first &lt;&lt; ':' &lt;&lt; item.second &lt;&lt; '\\n'; }); For example, if we have the following lambda code like this. 123[](auto i) { std::cout &lt;&lt; i &lt;&lt; '\\n';} After compiled this code, you may get the following closure. 123456789101112131415161718192021struct __lambda_6 { template &lt;typename T&gt; void operator()(T i) const { std::cout &lt;&lt; i &lt;&lt; '\\n'; } template &lt;typename T&gt; using __func_type = void(*)(T i); template &lt;typename T&gt; inline operator __func_type&lt;T&gt;() const noexcept { return &amp;__invoke&lt;T&gt;; } private: template &lt;typename T&gt; static void __invoke(T i) { std::cout &lt;&lt; i &lt;&lt; '\\n'; }};__lambda_6(); So if you write generic lambda, it creates a call operator which is a function template. Besides, if your lambda does not capture anyone, you can still get the implicit conversion to function pointer. But now that conversion operator is also going to be a template. However, the + operator doesn’t work anymore because the compiler literally does not know what type you need what type you’re trying to create here, what’s the concrete function pointer type, it’s not clear. So that’s not going to work. 123456int main() { // Error: can't deduce template argument. auto *fptr = +[](auto i) { return i * i; };} The another cool thing about generic lambda is that they support the perfect forwarding. So if you write the auto ref ref, that’s a forwarding reference. 1234std::vector&lt;std::string&gt; v;auto f [&amp;v](auto&amp;&amp; item) { v.push_back(std::forward&lt;decltype(item)&gt;(item));}; The compiler generates code is more or less like this. You get a function template calling operator. 123456789101112struct __lambda_7 { __lambda_7(std::vector&lt;std::string&amp; _v) : _v(v) {} template &lt;typename T&gt; void operator()(T&amp;&amp; item) const { __v.push_back(std::forward&lt;decltype(item)&gt;(item)); } private: std::vector&lt;std::string&gt;&amp; __v;}; It also supports variate lambdas. 123456auto f [](auto&amp;&amp;... args) { // Fold expression (since C+17). (std::cout &lt;&lt; ... &lt;&lt; args);};f(42, &quot;Hello&quot;, 1.5); Because you can use auto keyword, you can pass lambdas into other lambdas. You can have a lambda that takes another lambda as its argument using auto keyword. You can do many cool meta-programming stuff with this. 123456789auto twice = [](auto&amp;&amp; f) { return [=] { f(); f(); };};auto print_hihi = twice([] { std::cout &lt;&lt; &quot;hi&quot;;});print_hihi(); // hihi Idiom 4: Variable Template Lambda1234std::vector&lt;std::string&gt; v;auto f = [&amp;v](auto&amp;&amp; item) { v.push_back(std::forward&lt;decltype(item)&gt;(item));}; If you have a generic lambda, the call operator is going to be a template. 123456789101112struct __lambda_7 { __lambda_7(std::vector&lt;std::string&gt;&amp; _v) : _v(v) {} template &lt;typename T&gt; void operator()(T&amp;&amp; item) const { __v.push_back(std::forward&lt;decltype(item)&gt;(item)); } private: std::vector&lt;std::string&gt;&amp; __v;}; What if we could make the lambda itself also a template. That you can make a lambda a variable template and access the template parameter in it. We define a variable template, and then we assign a generic lambda to it, and now what happens conceptually? Your Code 1234template &lt;typename T&gt;constexpr auto c_cast = [](auto x) { return (T)x;}; Compiler 12345678910template &lt;typename T&gt;struct __lambda_9 { template &lt;typename U&gt; inline auto operator()(U x) const { return (T)x; }};template &lt;typename T&gt;auto c_cast = __lambda_9&lt;T&gt;(); Now we have a lambda template definition. Besides, we have a template call operator with different type of lambda template’s type since we use generic lambda. 123456789template &lt;typename T&gt;struct __lambda_9 { //... template &lt;typename U&gt; inline auto operator()(U x) const { // ... } //... }; This can be useful in a very particular scenario. 123456789101112131415161718192021222324using ms = std::chrono::milliseconds;using us = std::chrono::microseconds;using ns = std::chrono::nanoseconds;// we have a struct for storing a time point// for some reason we use a variant(like union).struct Time { std::variant&lt;ms, ns&gt; time; // this convert function takes a convert function // and applies it to the variant using std::visit. auto convert(const auto &amp;converter) { return std::visit(converter, time); }};int main() { Time t(ns(3000)); std::cout &lt;&lt; t.convert(std::chrono::duration_cast&lt;us&gt;).count(); // Error: This will get error since // `std::chrono::duration_cast&lt;&gt;` has three template parameters. // we cannot deduce the other two template parameters since // this duration_cast function is used as a argument // for other function.} We should specify conversion types for duration_cast using variable template. We can wrap the duration_cast into a helper struct. You can split template parameters into two parts: the template parameters that you should specify explicitly; the template parameters that should be deduced during callsite. So this is a good practice for splitting template parameters into two parts, and using a helper variable template to specify the explicit parameters and deduce the other template parameters. 123456789101112131415161718192021struct Time { std::variant&lt;ms, ns&gt; time; auto convert(const auto &amp;converter) { return std::visit(converter, time); }};template &lt;typename T&gt;constexpr auto duration_cast = [](auto d) { // The first template parameter is specified // explicitly. And the other two parameters // are deduced when this duration_cast // function called. return std::chrono::duration_cast&lt;T&gt;(d);};int main() { Time t(ns(3000)); // Works. std::cout &lt;&lt; t.convert(duration_cast&lt;us&gt;).count();} C++14 Init CaptureUsing Init Capture, we can capture some non-copyable object. Your Code 12345678910struct Widget {};auto ptr = std::make_unique&lt;Widget&gt;();// move happens here.auto f = [ptr = std::move(ptr)] { std::cout &lt;&lt; ptr.get() &lt;&lt; '\\n';};assert(ptr == nullptr); // assert passesf(); Compiler 12345678910111213struct __lambda_8 { __lambda_8(std::unique_ptr&lt;Widget&gt; _ptr) : __ptr(std::move(_ptr)) {} inline void operator()() const { std::cout &lt;&lt; __ptr.get() &lt;&lt; '\\n'; } private: // type deduced as if by 'auto' decl. std::unique_ptr&lt;Widget&gt; __ptr;};__lambda_8(std::move(ptr)); Idiom 5: Init Capture Optimization Reference Book: Bartlomiej Filipek: “C++ Lambda Story” 1234567891011121314const std::vector&lt;std::string&gt; vs = {&quot;apple&quot;, &quot;orange&quot;, &quot;foobar&quot;, &quot;lemon&quot;};const std::string prefix = &quot;foo&quot;;auto result = std::find_if( vs.begin(), vs.end(), [&amp;prefix](const std::string &amp;s) { return s == prefix + &quot;bar&quot;; });if (result != vs.end() std::cout &lt;&lt; prefix &lt;&lt; &quot;-something found!\\n&quot;; In the upper case, we concatenate a new string using prefix and &quot;bar&quot; in every loop iteration. But the result is always the same. So if we use the Init Capture, we can optimize this operation. The concatenation operation is performed only once. In this way, you saved a lot of CPU cycles because we can just do this operation once. 12345678910111213const std::vector&lt;std::string&gt; vs = {&quot;apple&quot;, &quot;orange&quot;, &quot;foobar&quot;, &quot;lemon&quot;};const std::string prefix = &quot;foo&quot;;auto result = std::find_if( vs.begin(), vs.end(), [str = prefix + &quot;bar&quot;](const std::string&amp; s) { return s == str; });if (result != vs.end()) std::cout &lt;&lt; prefix &lt;&lt; &quot;-something found!\\n&quot;; C++17 constexprIn C++17, we can use constexpr because you can execute them at compile time. The result of a lambda as a non-type template parameter. 12345auto f = []() constexpr { return sizeof(void*);};std::array&lt;int, f()&gt; arr = {}; Class Template Argument Deducton (CTAD)You don’t need to specify all template parameters since compiler can deduce these parameters. 12// std::vector&lt;int&gt; deduced.std::vector vec = {1, 2, 3, 4, 5, 6, 7}; Idiom 6: Lambda Overload SetThis is a very cool tool to have in your toolbox. If you want to create an object that is a callable object. So you can call it using the usual function called syntax, but it acts as an overload set. we also have a set of lambdas for overload. Because lambda is a struct type after compiler compile it. So you can inherit a lambda. This is really cool technique. You can do is you can write a variadic template which takes a bunch of template parameters by a bunch of types, and it’s going to inherit from all of these types. And then it’s going to use the call operator of all these types. So which means if you write using Ts operator. using Ts::operator()... means it’s kind of inheriting the call operators. The other interesting thing is that overload is an aggregate because it has no user-defined Constructors, it has no private members or anything like this, which means it’s an aggregate and the elements of the aggregate are the base classes. So what we can do is we can initialize an overload object with aggregate initialization using the braces. You can give it a bunch of lambdas, and those lambdas are going to be the base classes of that overload class, and it’s going to inherit the call operator from them. We also need to write a deduction guide which is like two more lines. 123456789101112131415161718template &lt;typename... Ts&gt;struct overload : Ts... { using Ts::operator()...;};// C++17 should declare a deduction guide,// C++20 doesn't need it anymore.template &lt;typename... Ts&gt;overload(Ts...) -&gt; overload&lt;Ts...&gt;;int main() { // aggregate initialization. overload f = { [](int f) { std::cout &lt;&lt; &quot;int thingy&quot;; }, [](float f) { std::cout &lt;&lt; &quot;float thingy&quot;; } }; } C++2012345678struct Widget { float x, y;};auto [x, y] = Widget();auto f = [=] { std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; '\\n';}; Lambda can capture parameter packs. 12345678910auto foo(auto... args) { std::cout &lt;&lt; sizeof...(args) &lt;&lt; '\\n';}template &lt;typename... Args&gt;auto delay_invoke_foo(Args... args) { return [args...]() -&gt; decltype(auto) { return foo(args...); };} Lambda can be constval. This means it can only be called at compile-time. 12345678auto f = [](int i) constval { return i * i;};f(5); // OK, constant expression.int x = 5;f(x); // Error: call to immediate function 'f' // is not a constant expression. Template Lambda123456std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};std::erase_if( data, // in generate lambda, you do not // need to specify types. [](auto i) { return i % 2; }); In C++20, you can explicitly use template lambda. 1234std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};std::erase_if( data, []&lt;typename T&gt;(T i) { return i % 2; }); Some interesting lambda expression features in C++20. Lambdas allowed in unevaluated contexts. Lambdas without captures are now: default-constructible assignable Before C++20, it is not possible to have a lambda be a data member of a class, because you cannot write this 12345class Widget { // Error: non-static data member // cannot be 'auto'. auto f = [] {};}; Since C++20, you can write a lambda in an undivided context like this using decltype. 123class Widget { decltype([]{}) f; // OK, since C++20}; This can be useful when 1234567template &lt;typename T&gt;using MyPtr = std::unique_ptr&lt;T, decltype([](T *t) { myDeleter(t); })&gt;;MyPtr&lt;Widget&gt; ptr; Some tricky questions.12345auto f1 = [] {};auto f2 = [] {};// f1 and f2 have different types since compiler// generates different struct closure for each// lambda respectively. 123auto f1 = [] {};auto f2 = f1;// f1 and f2 have the same type. 1234auto f1 = [] {};decltype(f1) f2;// f1 and f2 have the same type. Because there is// only one lambda type. 1234using t = decltype([] {});t f1;t f2;// f1 and f2 have the same type. 123decltype([] {}) f1;decltype([] {}) f2;// f1 and f2 have different lambda types. 12345678910template &lt;auto = []{}&gt; struct X {};X x1;X x2;// x1 and x2 have different types.// Because every time you define a lambda,// compiler will generate a new struct// closure, then there will be a different type. Idiom 7: Unique types generatorSince C++20. Idiom 8: Recursive LambdasNaive approach: 12345678910111213int main() { auto f = [](int i) { if (i == 0) return 1; // Error: 'f' declared with 'auto' // cannot appear in its own initializer! return i * f(i - 1); }; std::cout &lt;&lt; f(5) &lt;&lt; '\\n'; return 0;} Using std::function(Still not great). 12345678910int main() { std::function&lt;int(int)&gt; f = [&amp;](int i) { if (i == 0) return 1; return i * f(i - 1); }; std::cout &lt;&lt; f(5) &lt;&lt; '\\n'; return 0;} We cannot name the lambda within itself, but we can template it on the function that it’s going to be calling within itself. And then we can pass itself to itself like this. 1234567891011121314int main() { auto f = [](auto&amp;&amp; self, int i) { if (i == 0) return 1; // We can pass itself to itself like this. // But this looks awkward that this does not // look like a normal function call because // you always have to pass the lambda to itself // by argument. return i * self(self, i - 1); }; std::cout &lt;&lt; f(f, 5) &lt;&lt; '\\n'; // prints 120 return 0;} 123456789101112131415161718// C++ deducing this: it just worksint main() { // this is an implicit argument, we don't need to // pass it, we just call f act like a normal // function call. Because if the compiler is going // to be like you want to have this implicit first // parameter which is this pointer, let's deduce // what it is, let's deduce the type and now you // can name this parameter. That's a good convention // that's what python people use. This must be good. auto f = [](this auto&amp;&amp; self, int i) { if (i == 0) return 1; return i * self(i - 1); }; std::cout &lt;&lt; f(5) &lt;&lt; '\\n'; // prints 120 return 0;} Idiom 6 + 8: Recursive Lambda Overload Set Ben Deane: Deducing this patterns This is an example where you want to tree traversal. You have a binary tree. You are going to implement it as a variant. So every tree is either a leaf or a node, and it’s kind of recursive. And then what you want to traverse the tree you recursively and count the number of leaves. We can use the recursive lambda overload pattern here. Do this varient and we are going to have two lambdas here, one overload for the leaf, and one for the node, and if you have a node, you count the least by taking the left child and counting the leaves and taking the right child and counting leaves, so you are going to call it recursively. And the really cool thing here is that if you call this thing from within itself recursively using reducing this. Deducing this because it’s using the normal rules of function template argument deduction it’s going to deduce the fully derived like in so far as it s known at compile time, which in this case it is. So if you refer to self here, the self is not the lambda. The self is the fully derived type which is the whole overload set.This is a classic job interview question. So next time somebody wanted to implement tree traverse, you can write it like this and you can really impress your interviewer. This is only supported in Microsoft compiler. 12345678910111213141516171819202122232425struct Leaf {};struct Node;using Tree = std::variant&lt;Leaf, Node*&gt;;struct Node { Tree left, right;};template &lt;typename... Ts&gt;struct overload : Ts... { using Ts::operator()...; };// C++17 should define a guide deduction,// C++20 doesn't need it anymore.template &lt;typename... Ts&gt;overload(Ts...) -&gt; overload&lt;Ts...&gt;;int countLeaves(const Tree &amp;tree) { return std::visit(overload{ [](const Leaf&amp;) { return 1; }, [](this const auto &amp;self, const Node *node) -&gt; int { return visit(self, node-&gt;left) + visit(self, node-&gt;right); } }, tree); } References expr.prim.lambda Timur Audio’s Blog","link":"/2022/11/13/C-Lambda-Idioms/"},{"title":"C++ STL Overview","text":"STL algorithms can make code more expressive Raising levels of abstraction Sometimes, it can be spectacular. Avoid common mistakes off-by-one empty loops naive complexity When writing our own for-loops is about complexity. Some algorithms that they can be implemented naively in quadratic complexity, and in a more astute manner in a linear complexity. Used by lots of people A common vocabulary Whatever the version of your compiler Also, STL algorithms are used by billions of people every day. You don’t need to afraid of them. I think we should level up to STL algorithms and not the other way around.So even if you are running an older C++ version, you can still get most of the STL algorithms, like for example, if you are in C++03 for example, and you want to use all_of, any_of or none_of which appeared in C++11. Well you can just grab that code, and copy it into your codebase and just start using them. So most of them are within your reach whichever version of C++ you are on right now. Many more of the STL algorithms that let you express more nuance when you write your code. I’m going to show you something to illustrate the fact that there’s much more than for_each in the STL algorithms library. Here is the world of C++ STL algorithms The Queries means the stl algorithms which in this area just extract some piece of information, and they don’t actually modify it. The most of the stl algorithms would somehow change the collection, like sort or partition or whatever. But most of them are just read-only operations. HeapsA Heap is a data structure that looks like a tree, but that has a property is that every node must be smaller than its children. This is called max heap.So one extremely interesting property of the heap is taht we can squash it down into a range like below. std::make_heapWhen you do this, there is a nice property that it’s a range. So we can represent it with a vector, for example which is quite convenient to work with. And also, to go froma node to its left child, it is essentially taking its index and multiplying it by twos, nearly that. So it’s a way to represent a tree into a range. If you have a range, we have a beginning and an end and we can use STL algorithms.So first thing we can do is taking values that are not particularly a heap, and rearrange them so that they respect the heap property. We use std::make_heap to make a heap. We rearrange the element inside of a collection. This is our first algorithm. std::push_heapWhen we want to add a new value into a heap, we should move up the new value to right position in case to meet the heap criteria. When we squash the heap into a vector, we add something to the end, and then we need something to make it bubble its way up to its final position, and that is std::push_heap. std::pop_heapWhen we want to remove something from the heap. Usually we want to get the maximum value from this heap, std::pop_heap can be used to get this maximum value.To do this, we swap the first one and the last one. At this point, we need to make it bubble its way down to its final position, and that’s what pop_heap does. And if we want to remove, actually remove that value, we pop it back from the vector. If we pop each value from heap, then we get a sorted collection, and that is what std::sort_heap. SORTINGstd::sortRearrange the collection, and we get a sorted order collection. std::partial_sortNow if we only want to sort the beginning of a collection, this is a partial_sort. partial sort is kind of like a middle, something inside of the collection, and sorts the collection from the beginning to that point, and the rest is in unspecified order. std::nth_elementnth_element is a partial sorting algorithm that rearranges elements in [first, last). 123456789101112131415161718192021222324252627// Since C++20template &lt;typename RandomIt&gt;void nth_element(RandomIt first, RandomIt nth, RandomIt last);// Since C++20template &lt;typename RandomIt, typename Compare&gt;void nth_element(RandomIt first, RandomIt nth, RandomIt last, Cmpare comp);// Since C++17template &lt;typename ExecutionPolicy, typename RandomIt&gt;void nth_element(ExecutionPolicy&amp;&amp; policy, RandomIt first, RandomIt nth, RandomIt last);// Since C++20template &lt;typename RandomIt&gt;constexpr void nth_element(RandomIt first, RandomIt nth, RandomIt last);// Since C++17template &lt;typename ExecutionPolicy, typename RandomIt, typename Compare&gt;void nth_element(ExecutionPolicy&amp;&amp; policy, RandomIt first, RandomIt nth, RandomIt last, Compare comp); std::sort_heapstd::inplace_mergeinplace_merge is the incremental step in a merge sort. Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). 1234567891011// Since C++17template &lt;typename ExecutionPolicy, typename BidirIt&gt;void inplace_merge(ExecutionPolicy&amp;&amp; policy, BidirIt first, BidirIt middle, BidirIt last);// Since C++17template &lt;typename ExecutionPolicy, typename BidirIt, typename Compare&gt;void inplace_merge(ExecutionPolicy&amp;&amp; policy, BidirIt first, BidirIt middle, BidirIt last, Compare comp); PARTITIONINGTo partition a collection is to look at it through a predicate, something that returns a Boolean. If the blue is the predicates. The original collection is depicted as follows. Then we do partition, then the predicates are at the beginning, and other not-blue ones at the end. The border between the blue ones and the not-blue ones is called a partition point, that’s the end of the blue range and that’s also the beginning of the not blue range. PERMUTATIONSThe elements move around the collection, even if they don’t change value. std::rotate12345678910// since C++11 and until C++20template &lt;typename ForwardIt&gt;ForwardIt rotate(ForwardIt first, ForwardIt n_first, ForwardIt last);// since C++17template &lt;typename ExecutionPolicy, class ForwardIt&gt;ForwardIt rotate(ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt n_first, ForwardIt last); Performs a left rotation on a range of elements. Specifically, std::rotate swaps the elements in the range[first, last) in such a way that the element n_first becomes the first element of the new range and n_first - 1 becomes the last element. std::shufflestd::shuffle is used to randomly change elements in a container. So std::shuffle takes a collection with elements in a certain order, and takes something that generates random numbers, and rearranges the collection in random order. std::next_permutation/std::prev_permutationGiven a collection of object, we can order them, order all their possible arrangements, and an intuitive way to see that is thinking about an alphabetical order. 12345678910111213141516171819// until C++20template &lt;typename BidirIt&gt;bool next_permutation(BidirIt first, BidirIt last);// until C++20template &lt;typename BidirIt, typename Compare&gt;bool next_permutation(BidirIt first, BidirIt last, Compare comp);// since C++20template &lt;typename BidirIt&gt;constexpr bool next_permutation(BidirIt first, BidirIt last);// since C++20template &lt;typename BidirIt, typename Compare&gt;constexpr bool next_permutation(BidirIt first, BidirIt last, Compare comp); Permutes the range [first, last) into the next permutation, where the set of all permutations is ordered lexicographically with respect to operator &lt; or comp. Returns true if such a “next permutation” exists; otherwise transforms the range into the lexicographically first permutation (as if by std::sort(first, last, comp)) and returns false.That’s interesting for every possible arrangement of a collection, we can repeatedly call std::next_permutation until you’ve cycled back to the beginning. SECRET RUNESThe secret runes are things that you can combine with other algorithms to generate new algorithms. I called them runs because it’s like going to see runes to augment your powers and also because I find that kind of cool as a name. PARTITIONING-SORT-HEAPstable_* runeWhen we will see all the algorithm that go with the stable rune, so stable when you tack it onto an algorithm, it does what this algorithm does, but keep the relative order. Think std::partition for example, it put all the blue ones at the beginning that’s for sure, but maybe in the process, some of them got swapped around. With std::stable_partition, they all keep the same relative order. Same thing with std::stable_sort. 123stable_* ---&gt; stable_sort \\ --&gt; stable_partition is_* runeThe is_* rune checks for a predicate on the collection. We know what sort, partition, heap, means is_sort/is_partition/is_heap and returns a boolean. To indicate whether it’s a sorted/partitioned/heap that we are looking at. 123is_* -----| is_sorted | is_partitioned | is_heap is_*_untilis_*_until returns an iterator that’s the first position where that predicate doesn’t hold anymore. So for example, if we have a sorted collection, and then we call std::is_sorted_until we’ll get the end of that collection. 123is_*_until -----| is_sorted_until | is_partitioned_until | is_heap_until QUERIESSo one thing you can extract out of a collection is some sort of value. std::countFor example, the simplest one is probably std::count that takes a begin and an end a value, and returns how many times this value occurs in the collection. std::accumulate/(transform_)reduceThe accumulate makes some elements of the collection calling operator plus, or any custom function you’d pass it. In C++17, there’s std::reduce appeared, that does practically the same thing as accumulate, except it has a slightly different interface. It can accept to take no initial value, and it can also be run in parallel, but essentially, it’s the same as std::accumulate. std::transform_reduce takes a function and applies that function to the element of the collection before calling the reduce. std::partial_sumI think this is the pre-sum algorithm in std algorithms. 12345678910111213141516171819202122// until C++20template &lt;typename InputIt, typename OutputIt&gt;OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first);// until C++20template &lt;typename InputIt, typename OutputIt, typename BinaryOperation&gt;OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first, BinaryOperation op);// since C++20template &lt;typename InputIt, typename OutputIt&gt;OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first);// since C++20template &lt;typename InputIt, typename OutputIt, typename BinaryOperation&gt;constexpr OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first, BinaryOperation op); std::partial_sum, it sums the all the elements starting from the beginning to the current point of the collection. So here, partial_sum would return a collection with, in the first position, what was in the first position of the original collection. and the second one would plus the seco Computes the partial sums of the elements in the sub-ranges of the range[first, last) and writes them to the range beginning at d_dirst. This is equivalent operation: 12345*(d_first) = *first;*(d_first + 1) = *first + *(first + 1);*(d_first + 2) = *first + *(first + 1) + *(first + 2);*(d_first + 3) = *first + *(first + 1) + *(first + 2) + *(first + 3);// ... In C++17, there are std::(transform_)inclusive_scan and std::(transform_)exclusive_scan. inclusive_scan is the same thing as partial_sum, except it can run in parallel. exclusive_scan is the same as inclusive_scan, except it doesn’t include the current element. So for example, with exclusive_scan, the second value is the same to the first element of the original collection. The third would be one plus second, so-on and so-forth. 12345// *(d_first) = ;*(d_first + 1) = *first;*(d_first + 2) = *first + *(first + 1);*(d_first + 3) = *first + *(first + 1) + *(first + 2);// ... std::inner_productTODO std::adjacent_differenceTODOstd::adjacent_difference makes the difference between every two neighbors in the collection . std::samplestd::sample, introduced since C++17, takes something that can return some, that can generate random numbers, and it takes a number, say N, and it produces n elements of that collection, selected randomly. 1234567template &lt;typename PopulationIterator, typename SampleIterator, typename Distance, typename URBG&gt;SampleIterator sample(PopulationIterator first, PopulationIterator last, SampleIterator out, Distance n, URGB&amp;&amp; g); Selects n elements from the sequence [first, last)(without replacement) such that each possible sample has equal probability of appearance, and writes those selected elements into the output iterator out. Random numbers are generated using the random number generator g.If n is greater than the number of elements in the sequence, selects last-first elements.The algorithm is stable only if PopulationIterator meets the requirements of LegacyForwardIterator. QUERYING A PROPERTYThere are three std algorithms: std::all_of, std::any_of, std::none_of. These three functions are really useful in everyday code. std::all_of takes collection and a predicate, returns if all elements satisfy that predicate. If the collector is empty, std::all_of returns true. std::any_of at least one element satisfy that predicate. If the collector is empty, std::any_of returns false. std::none_of if no element satisfy that predicate. If the collector is empty, std::none_of returns true. QUERYING A PROPERTY ON 2 RANGESWe can also query a property on two ranges, which is essentially different ways of comparing them. std::equalThe simplest way to compare two ranges is to see if they have the exact same contents, and returns the boolean result.Besides, we’d like to know if the two collections contain the same elements but not necessarily in the same order, that’s std::is_permutation. std::lexicographical_compareNow we can also compare ranges and say which one is smaller than the other one. To define the smaller, we could go with size. That’s not very precise, there’s another way to do that is going back to the alphabetical, lexicographical ordering. std::mismatchThe last algorithm of comparing two ranges is to traverse them both and stop whenever they start to differ. This is std::mismatch. And returns the std::pair&lt;Iterator, Iterator&gt; iterators pointing to the respective position of where they start to differ in the two collections. SEARCHING A VALUEA classic thing to extract in a collection is a position, like looking for something, or to look for something in a collection now, essentially, two ways to do that. It depends on whether the collection is sorted or not sorted. If it’s sorted, we can use a binary search. If not sorted, we have to go through the collection from the beginning. std::findstd::find takes begin, end and value, and returns the iterator where pointing to that value, or end if that value is not found. Now, it has a sort of like twin brother that’s much less famous, but quite useful as well, and it’s called std::adjacent_find, and that returns the first position where two adjacent value occur and are equal to the value search. So std::adjacent_find takes a beginning and an end and a value and returns the first position where two of those values appear in a row. On the sorted range, we are not really looking for a value, because searching for a given value, it could be at several places, and since it’s sorted, they would be lumped together. std::equal_range: returns a sub-range which all elements in this sub-range are equal to the given value. std::lower_bound/std::upper_bound: and that only indicate position to insert elements. std::binary_search: It takes a beginning and an end and a value, and only tells you whether it’s there or not, but doesn’t tell you where it found it. And it uses a binary search which is a good thing. SEARCHING A RANGEIt is looking for a sub-range in a bigger range. To do that, there’s an algorithm that has a very bizarre name, because it’s called search. Search says it will try to find it. It searches a sub-range into a range. std::search: Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first, last). std::find_end: Searches for the last occurrence of the sequence [s_first, s_last) in the range [first, last). std::find_first_of: Searches the range [first, last) for any of the elements in the range [s_first, s_last). SEARCHING A RELATIVE VALUE std::max_element: Finds the greatest element in the range [first, last). Elements are compared using operator &lt;. Or elements are compared using the given binary comparison function comp. It returns an iterator which points to the max element. std::min_element: Finds the smallest element in the range[first, last). It also uses either operator &lt; or given binary comparison function comp. It returns an iterator which points to the min element. std::minmax_element: Finds the smallest and greatest element in the range [first, last). It uses operator &lt; or specified comparison function comp. It returns a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns std::make_pair(first, first) if the range is empty. ALGORITHMS ON SETSWhat is sets? It includes std::set, but not only. In C++, we call any sorted collection as set. So a std::set is sorted and is a set, but sorted vector, for the purpose of the STL algorithms, is also considered as a set. std::set_differenceCopies the elements from the sorted range [first1, last1) which are not found in the sorted range [first2, last2) to the range beginning at d_first. 1234567891011121314151617181920212223242526272829303132333435363738// Until C++20template &lt;typename InputIt1, typename InputIt2, typename OutputIt&gt;OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);// Until C++20template &lt;typename IntputIt1, typename InputIt2, typename OutputIt, typename Compare&gt;OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);// Since C++20template &lt;typename InputIt1, typename InputIt2, typename OutputIt&gt;constexpr OutputItset_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);// Since C++20template &lt;typename IntputIt1, typename InputIt2, typename OutputIt, typename Compare&gt;constexpr OutputItset_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);// Since C++17template &lt;typename ExecutionPolicy, typename ForwardIt1, typename ForwardIt2, typename ForwardIt3, typename Compare&gt;ForwardIt3 set_difference(ExecutionPolicy &amp;&amp;policy, ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2, ForwardIt3 d_first, Compare comp); This is a common usage like this. During set_difference, the new value would be push_back into the result vector. It’s an inner complexity because it uses the fact that the input that sorted and also its output is sorted. 1234std::vector&lt;int&gt; results;std::set_difference(std::begin(A), std::end(A), std::begin(B), std::end(B), std::back_inserter(results)); std::set_differencestd::set_difference has siblings std::set_intersection that returns collections that they are both in A and B sets. std::set_unionstd::set_union returns elements that are in A or B. std::set_symmetric_differencestd::set_symmetric_difference that returns the elements are in A and not in B and those that are in B and not in A. std::includesstd::includes that returns a boolean that indicates whether all the elements of B are also in A. std::mergestd::merge that takes two sorted collections, and puts them together into one big sorted collections. MOVERSMovers are algorithms that move thins around. std::copyThe simplest way to move things around is probably to copy them. std::movestd::move is the algorithm that it takes a beginning and an end and an output iterator just like std::copy 12345678910111213141516// Since C++11, until C++20template &lt;typename InputIt, typename OutputIt&gt;OutputIt move(InputIt first, InputIt last, OutputIt d_first);// Since C++20template &lt;typename IntputIt, typename OutputIt&gt;constexpr OutputIt move(InputIt first, InputIt last, OutputIt d_first);// Since C++17template &lt;typename ExecutionPolicy, typename ForwardIt1, typename ForwardIt2&gt;ForwardIt2 move(ExecutionPolicy &amp;&amp;policy, ForwardIt1 first, ForwardIt1 last, ForwardIt2 d_first); Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. std::swap_rangesstd::swap_ranges swap the contents of two ranges. Obviously have to be the same size. std::copy_backward12345678// Until C++20template &lt;typename BidirIt1, typename BidirIt2&gt;BidirIt2 copy_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last);// Since C++20template &lt;typename BidirIt1, typename BidirIt2&gt;constexpr BidirIt2 copy_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last); Copies the elements from the range, defined by[first, last), to another range ending at d_last. The elements are copied in reverse order (the last element is copies first), but their relative order is preserved. The possible implementation is like this: 1234567template &lt;typename BidirIt1, BidirIt2&gt;BidirIt2 copy_backward(BidirIt1, first, BidirIt1 last, BidirIt2 d_last) { while (first != last) *(--d_last) = *(--last); return d_last;} This is as same as std::move_backward except std:move_backward moves elements to the new container. VALUE MODIFIERSstd::fill/std::iota/std::generate/std::replace, these four algorithms actually changes the collection. std::fillstd::fill puts the same value in every collection. std::generatestd::generate uses a function that can be called with no arguments, and we call that function once for every element of the collection. std::iotastd::iota is the another to feed a collection and that’s quite useful to have a quickly a sequence of values std::iota(pronounce: io-ta). It put that value at the beginning and then increment it and increment it until it fills the whole collection with increments. std::replacestd::replace replaces the values in a collection like replace 42 to 43 in the whole collection std::replace(first, last, 42, 43);. STRUCTURE CHANGERSThese algorithms that after I’ve down that drove the collection does not look the same even from a far so. There are two of them std::remove and std::unique. std::removestd::remove is used to remove values but has something peculiar with it since STL algorithms only access the iterators of a collection and not the collections themselves. They can not change the size. So the std::remove does is to pull up the collection by leaving only those that should not be removed. So if we want to remove a value, we use to remove this value, and pull up other values. And what is at the end is not specified. We can’t rely on it. This depends on compiler how to do this.std::remove returns an iterator that points to the first that’s crossed out. 12345678// erase all values that equals to 99.coll.erase(std::remove(std::bein(coll), std::end(coll), 99), std::end(coll));// Another version of erase. This is // equivalent to the upper code.std::erase(coll, 99); std::eraseErase all elements that compare equal to value from the container. 123456789// Since C++20template &lt;typename T, typename Alloc, typename U&gt;constexpr typename std::vector&lt;T, Alloc&gt;::size_typeerase(std::vector&lt;T, Alloc&gt;&amp; c, const U&amp; value);// Since C++20template &lt;typename T, typename Alloc, typename Pred&gt;constexpr typename std::vector&lt;T, Alloc&gt;::size_typeerase_if(std::vector&lt;T, Alloc&gt;&amp; c, Pred pred); This is equivalent to the following code: 1234auto it = std::remove(coll.begin(), coll.end(), value);auto r = std::distance(it, coll.end());c.erase(it, coll.end());return r; Erases all elements that satisfy the predicate pred from the container. Equivalent to: 1234auto it = std::remove_if(coll.begin(), coll.end(), pred);auto r = std::distance(it, coll.end());coll.erase(it, coll.end());return r; Returns the number of erased elements. std::unique123collection.erase(std::unique(std::begin(coll), std::end(coll)), std::end(coll)); *_COPYWe have seen all the algorithms that are combined with _copy in the STL algorithms library. You can tack it on an algorithm like those algorithms, it creates new algorithms that do the same thing but in a new collection, like remove or unique or replace or whatever, they operate in-place. Those _copy version, they leave the collection untouched and they take an output iterator, and they produce the output to that output iterator. 1234567std::remove_copystd::unique_copystd::reverse_copystd::rotate_copystd::replace_copystd::partition_copystd::partial_sort_copy *_IF*_if acts like a predicate. For example, find, std::find_if takes a value, and a predicate. 12345678std::find_ifstd::find_if_notstd::count_ifstd::remove_ifstd::remove_copy_ifstd::replace_ifstd::replace_copy_ifstd::copy_if LONELY ISLANDSThere are two algorithms: std::for_each and std::transform. std::transformstd::transform applies a function to the elements of a collection. So it takes a collection, begin, end, a function f, and an output like an output iterator. And it produces the application of that function to every element of the collection. 123std::transform(std::begin(coll), std::end(coll), std::back_inserter(results), f); What’s a bit less famous about transform, it can take two collections as parameters. It applies that function just like transform with one input collection to the two collection by feeding the two collection into f for each element and producing the output. 1234std::transform(std::begin(coll), std::end(coll), std::begin(ys), std::back_inserter(results), f); For example, if you like to sum the elements of two collection two by two, you can do that with one line of coding with transform and function f is std::plus which in the &lt;functional&gt; header file. std::for_eachstd::for_each takes a beginning, and an end, and some piece of code, a function, it could be a lambda or a regular function. So for puror of for_each, f might as well return void. std::for_each is made to perform side-effects. Using std::for_each for making anything else, such as a partition or a find or whatever, is not the right usage of for_each. There are algorithms that are more appropriate than for_each, and if there’s no algorithm more appropriate than for_each in the STL algorithms, then the algorithms outside of the STL algorithm. 12345678910111213141516// Until C++20template &lt;typename InputIt, typename UnaryFunction&gt;UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f);// Since C++20template &lt;typename InputIt, typename UnarFunction&gt;constexpr UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f);// Since C++17template &lt;typename ExecutionPolicy typename ForwardIt, typename UnaryFunction2&gt;void for_each(ExecutionPolicy &amp;&amp;policy, ForwardIt first, ForwardIt last, UnaryFunction2 f); This Applies the given function object f to the result of de-referencing every iterator in the range [first, last), in order. The possible implementation is like this. 1234567template &lt;typename InputIt, typename UnaryFunction&gt;constexpr UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f) { for (; first != last; ++first) f(*first); return f; // implicit move since C++11.} 1std::for_each(std::begin(coll), std::end(coll), f); RAW MEMORYThere are three algorithms, std::fill/std::copy/std::move, which are performed on raw memory. They have one thing in common, it’s that they use the assignment operator. 123std::fill -&gt; operator= ---&gt; uninitialized_fill (calls ctor)std::copy -&gt; operator= ---&gt; uninitialized_copy (calls copy ctor)std::move -&gt; operator= ---&gt; unititialized_move (calls move ctor) Now if we use an assignment operator, it means that the object has been constructed, and hopefully that’s true. But in some rare cases, we have objects that are not constructed yet. If we have just the memory, just chunks of memory that we got from somewhere, and we’d like to construct instead of calling the assignment operator, we’d like to call constructor on those chunks of memory. For that, we use the unitialized counterpart. This is the constructor that takes a value. So, in practice, you get a chunk of memory from somewhere, like shared memory or wherever. And you would like to fill it with values but you can’t call fill because you can’t call the assignment operator because there is just raw memory, it hasn’t been initialized yet. So we need to call the constructor. This is what std::unitialized_fill does. It takes two pointers for at the beginning and the end, and calls the value constructor, leading to an initialization of that chunk of memory. Now, once we are done with it, we want to call the destructor, if we are in charge to call the destructor. That’s what std::destroy does. But we don’t really use it on a day-to-day basis. std:::destroy(first, last) The definition of std::unitialized_fill is as follows. 123456789template &lt;typename ForwardIt, typename T&gt;void unitialized_fill(ForwardIt first, ForwardIt last, const T&amp; value);template &lt;typename ExecutionPolicy, typename ForwardIt, typename T&gt;void unitialized_fill(ExecutionPolicy &amp;&amp;policy, ForwardIt first, ForwardIt last, const T&amp; value); Copies the given value to an uninitialized memory are, defined by the range[first, last) as if by: 123for (; first != last; ++first) ::new(/*VOIDIFY*/(*first)) typename std::iterator_traits&lt;ForwardIt&gt;::value_type(value); Where /*VOIDIFY*/(e) is: 123static_cast&lt;void*&gt;(&amp;e); // until C++11static_cast&lt;void*&gt;(std::addressof(e)); // Since C++11, Until C++20const_cast&lt;void*&gt;(static_cast&lt;const volatile void*&gt;(std::addressof(e))); // Since C++20 The possible implementation is as follows. 12345678910111213141516template &lt;typename ForwardIt, typename T&gt;void uninitialized_fill(ForwardIt first, ForwardIt last, const T&amp; value) { using V = tyepname std::iterator_traits&lt;ForwardIt&gt;::value_type; ForwardIt current = first; try { for (; current != last; ++current) { ::new (const_cast&lt;void*&gt;(static_cast&lt;const volatile void*&gt;( std::addressof(*current)))) V(value); } } catch (...) { for (; first != current; ++first) first-&gt;~V(); throw; }} The examples: 12345678910111213141516171819#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;tuple&gt;int main() { std::string* p; std::size_t sz; std::tie(p, sz) = std::get_temporary_buffer&lt;std::string&gt;(4); std::uninitialized_fill(p, p + sz, &quot;Example&quot;); for (std::string *i = p; i != p + sz; ++i) { std::cout &lt;&lt; *i &lt;&lt; '\\n'; i-&gt;~basic_string&lt;char&gt;(); } std::return_temporary_buffer(p);} Another case is as follows: 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;string&gt;int main() { constexpr int n{4}; alignas(alignof(std::string)) char out[n * sizeof(std::string)]; try { auto first{reinterpret_cast&lt;std::string*&gt;(out)}; auto last{first + n}; std::ranges::unitialized_fill(first, last, &quot;▄▀▄▀▄▀▄▀&quot;); int count{1}; for (auto it{first}; it != last; ++it) std::cout &lt;&lt; count++ &lt;&lt; ' ' &lt;&lt; *it &lt;&lt; '\\n'; std::ranges::destroy(first, last); } catch(...) { std::cout &lt;&lt; &quot;Exception!\\n&quot;; }} *_N1234567891011copy_nfill_ngenerate_nsearch_nfor_each_nuninitialized_copy_nuninitialized_fill_nuninitialized_move_nuninitialized_default_construct_nuninitialized_value_construct_ndestroy_n For example, we perform the std::fill on a collector. If we use std::fill_n takes beginning, size, and a value, and it fills the first five elements starting from the beginning. 1std::fill(std::begin(coll), std::end(coll), 42); 123// This fills 5 elements in coll with 42// from the beginning, std::fill_n(std::begin(coll), 5, 42); 1std::fill_n(std::back_inserter(coll), 5, 42); CONCLUSIONSTL algorithms can make code more expressive. There are serval tips for your code to use STL algorithms more. Replace your for-loops by the right algorithm.By an STL algorithm to make it smoother to work with. More algorithmsBoost.Algorithms: gather, sort_subrange, is_palindrome, boyer_moore, one_of, etc. Understand in depths the STL algorithms.Algorithmic complexityPre/post - requisites, like think about sorted collections for example.Look at the implementation. See how they are implemented, that is often quite instructive. Get inspired. If you can get inspired, you can have a better intuition of what abstractions work well. That’s the fundamental of writing code, and that intuition, you can use that in our own code. Once you are familiar enough, you can start thinking about writing your own algorithms. Well, we can combine an algorithm, an existing algorithm with a rune, like sort_copy doesn’t exist. Besides, you can enrich a family, like set_segregate. Also, you can start a new STL family.","link":"/2022/11/17/C-STL-Overview/"},{"title":"C++ learning lists","text":"Learning MaterialsDoneLambda Expression C++ Lambda Idioms - Timur Doumler - CppCon 2022My learning notes: C++ Lambda Idioms Type Traits Template Metaprogramming: Type Traits (part 1 of 2) - Jody Hagins - CppCon 2020 Template Metaprogramming: Type Traits (part 2 of 2) - Jody Hagins - CppCon 2020My learning notes: Template Metaprogramming—Type Traits Aggregate Initialization C++17’s Aggregate Initializations Lightning Talk: Direct Aggregate Initialisation - Timur Doumler - CppCon 2021My Learning note: Aggregate Initialization STL Algorithms 105 STL Algorithms in Less Than an HourMy learning note: C++ STL Overview TODOBasics Move Semantics C++ Move Semantics Constexpr Everything Overload Resolution Thoughts on Pattern Matching using is and as const and constexpr Modules Template Metaprogramming: Practical Application The Special Member Functions Named Tuples in C++20 Smart Pointers and RAII RAII in C++ Using Modern C++ to Eliminate Virtual Functions Master C++ Value Categories With Standard Tools Understanding Value Categories CUDA-related Bringing Existing Code to CUDA Using constexpr and std::pmr Profiling The Basics of Profiling The Most Important Optimizations to Apply in Your C++ Programs C++ Templates Templates (1/2) Templates (2/2) Templates in C++ C++ Interview Questions C++ Interview Questions Some C++ Learning Materials C++ Learning Materials Debugger Tutorial Debugger Tutorial LLVM Learning Materials LLVM Learning Materials LLVM Tutor C++ Coroutines Understanding C++ COroutines By Example (1/2) Understanding C++ COroutines By Example (2/2) Currency - Mike Shah - CppCon 2021 A C++ Library for Parallelism and Concurrency Designing Classes Designing Classes (1/2) Designing Classes (2/2) Class Layout A Practical Guide to Loose Coupling The Factory Pattern API Design The Visitor Design Pattern in CPP MISC The Right Way to Write C++ Code Design Patterns: Facts and Misconceptions Interpreter http://qingyunha.github.io/taotao/ C++ Interview 70+ C++ Interview Questions STL FluentCPP STL FluentCPP Posts Classic STL Standard Libraries chrono Introduction Functional Programming Functional Composable Operations with Unix-Style Pipes in C++ CUDA Thrust Related Top 22 Resource Using CUDA Programming Massively Parallel Processors — Videos Shows some useful CUDA examples and GitHub addresses Debugging Debugging in C++ Thrust &amp; CUB How To Compile Thrust and CUB","link":"/2022/11/14/C-learning-lists/"},{"title":"CMAKE---Multiple directories","text":"OverviewCMake is a directory-based project management tool. If your project has multiple directories, more CMakeLists.txt files should be created in your project directories. SituationAs the following directories, each directory is a standalone module. For example: the root target has its own source file(s) in ${ROOT}/src directory. hello_object_lib is a OBJECT target, and it has its own including paths. So we use a CMakeLists.txt file for target management. hello_shared_lib is a SHARED library target, the root project will link this shared library or provide for other projects. hello_static_lib is a STATIC library target, this target will generate a static library file for other projects. 12345678910111213141516171819202122232425262728tree.├── CMakeLists.txt├── hello_object_lib│ ├── CMakeLists.txt│ ├── inc│ └── src│ └── main.cc├── hello_shared_lib│ ├── CMakeLists.txt│ ├── include│ │ └── hello│ │ └── hello.hpp│ └── src│ ├── hello.cc│ ├── internal.cc│ └── internal.hpp├── hello_static_lib│ ├── CMakeLists.txt│ ├── include│ │ └── hello│ │ └── hello.hpp│ └── src│ ├── hello.cc│ ├── internal.cc│ └── internal.hpp└── src └── main.cc The content of root CMakeLists.txt is as follows. Each sub-directory should be added in this CMakeLists.txt. In this CMakeLists.txt, we define a executable target multiple_exec, all of the other targets will be linked to this executable target. There’s a difference should be noticed. OBJECT target cannot be linked into other targets using target_link_libraries command before CMake V3.12. So if you use the older CMake version, you should use the 12345678910111213141516171819202122cmake_minimum_required(VERSION 3.21)project(multiple_dirs VERSION 1.0 DESCRIPTION &quot;Multiple directory project&quot; LANGUAGES CXX)# Add subdirectories with examples.add_subdirectory(hello_object_lib)add_subdirectory(hello_shared_lib)add_subdirectory(hello_static_lib)# add an example executableadd_executable(multiple_exec)# add sources to the example executabletarget_sources(multiple_exec PRIVATE src/main.cc)# link librariestarget_link_libraries( multiple_exec PRIVATE hello_object_target hello_shared_target hello_static_target) References My-Advanced-CMake-Repo","link":"/2022/10/31/CMAKE-Multiple-directories/"},{"title":"How To Use Hexo","text":"IntroductionThe combination of Hexo + GithubPages is an easier way to configure your own blog. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. StepsCreate a GitHub RepoYou should create a repo for your blog, and the repo name must be &lt;username&gt;.github.io. Init HexoThen, navigate to &lt;username&gt;.github.io directory, run the following command to init Hexo blog. 12# cd &lt;username&gt;.github.iohexo init Install DependenciesFinally, run the following command to finalize installing procedures. 1npm install Hexo Useful CommandsCreate a new postEnter &lt;username&gt;.github.io directory, and execute the following command for new page creation. If you haven’t specify layout, hexo will use the default layout for new page creation. The default layout is configured in _config.yml file, the keyword is default_layout. For more info, pleasesee chapter Writing. 12# hexo new [layout] &lt;title&gt;$ hexo new &quot;My New Post&quot; Run serverIf you want to preview your blog on your local machine, you can use following command to deploy your blog on your local machine. For more info, please see chapter Server. 1$ hexo server Generate static filesBefore you publish your blog to github pages, you should generate static files locally. If you use the github pages’s theme, you only need to configure wanted theme in your _config.yml file, and github will gengerate all static files before deploying. For more info, please see chapter Generating. 1$ hexo generate Deploy to Remote SitesAfter generating all static files, you can deploy your blog on GitHub pages. This command would create a master branch in your blog repo. So your github pages should be based on master branch. You can change the github pages’ branch in Settings-&gt;Pages-&gt;Branch. 1$ hexo deploy For more info, please see chapter Deployment. ThemesInstall ThemeI’d like to use hexo-theme-icarus theme. User should execute the following commands to configure icarus theme. hexo-theme-icarus 12npm install hexo-theme-icarushexo config theme icarus Hexo provides numerous themes, please see Hexo-Themes for more details. Change Your Personnel InfoUser should change the personnel info in _config.icarus.yml file. NotesAll blog data are listed in source/ directory. My source directory hierarchy is as follows: 123456789101112» tree source source├── _posts│ ├── How-To-Use-Hexo.md│ └── hello-world.md└── img ├── alipay-qrcode.jpg ├── logo.png ├── logo.svg └── wechat-qrcode.jpg2 directories, 6 files If you want to change the default logo logo.svg, you should put your own logo.svg in source/img/logo.svg. Besides, Mac user can use imagemagick tool for png to svg conversion. For more details, you can see imagemagick-homepage. After install imagemagick tool, you can execute the following commands to convert. 1convert logo.png logo.svg Add “Read More” tag for your postsThere are two ways to add this tag. First, you can add excerpt tag in your post, and add some introductions for posts. 12345title: New Articledate: 2022-11-12excerpt: Introductions---# Contents ... add &lt;!-- more --&gt; line after introductions in your posts. References PicGo-Configuration Using-ssh-instead-of-http-in-config.yml-file Hexo-Doc Hexo-theme-icarus Hexo-theme-icarus-doc","link":"/2022/10/30/How-To-Use-Hexo/"},{"title":"LLVM Series","text":"LLVM Series Callgraph LibCall Creation Calling Clang to compile a source codes. References clang-notes","link":"/2022/11/06/LLVM-Series/"},{"title":"Lambda Expression","text":"Lambda ExpressionInit CaptureThis feature is introduced since C++14, it also called generalized lambda capture. 12345678910111213141516171819202122232425262728293031namespace {class Widget {private: std::string name_; public: explicit Widget(std::string name) : name_(std::move(name)) {} friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Widget &amp;item) { os &lt;&lt; item.name_; return os; } void test_capture_member() { [name = std::ref(name_)] { std::cout &lt;&lt; &quot;name: &quot; &lt;&lt; name; }(); }};} // namespacevoid test_init_capture() { auto pw_outer = std::make_unique&lt;Widget&gt;(&quot;widget&quot;); // test init capture. [pw = std::move(pw_outer)] { std::cout &lt;&lt; *pw.get(); }(); [pw = std::make_unique&lt;Widget&gt;(&quot;widget2&quot;)] { std::cout &lt;&lt; *pw.get(); }(); auto pw = std::make_unique&lt;Widget&gt;(&quot;test&quot;); // test class member capture. pw-&gt;test_capture_member();} Captures apply only to non-static local variables (including parameters) visible in the scope wherethe lambda is created. So if you want to capture a class member, the original way is using a localvariable. For example: 12345678910111213141516namespace {class Widget {private: std::string name_; public: explicit Widget(std::string name) : name_(std::move(name)) {} void test_capture() { auto &amp;name = name_; [name] { std::cout &lt;&lt; name; }(); }};} // namespace Since C++14, we can use init capture feature for this situation. It means we can define a newvariable and initialize this local variable using class member during lambda capture. For example: 12345678910111213namespace {class Widget {private: std::string name_; // ... void test_capture() { [name = std::ref(name_)] { std::cout &lt;&lt; name; }(); }};} // namespace Please visit site for complete code Lambda Expression Testcase References Item 31: Avoid default capture modes, Effective Modern C++, Scott Meyer","link":"/2022/11/08/Lambda-Expression/"},{"title":"Template Metaprogramming---Type Traits","text":"The Aims How to implement and how to use Exploration of the standard set of type traits Focus on techniques for implementing type traits Remove some of the mystique that still surrounds template metaprogramming. Practical advice from a regular user. So you can more readily use the standard set and implement your own whenneeded. What is Meta-Programming In general, when programs treat programs as data Could be other programs or itself Could be at “compile time” or “run time” We will discuss compile time metaprogramming in C++ Wide array of current techniques, but still considered a niche This two-part tutorial helps shed light on a very few essential ideoms Why Care About Metaprogramming (and type traits in particular) Each new standard library employs more metaprogramming techniques Some requirements are impossible without advanced techniques(e.g., std::optional) Many third party libraries, not just Boost Tools and idioms have become well developed, no longer black magic, limited to STL and Boost. All C++ programmers should understand the basics. Any library developer should understand a good bit more C++20 - concepts and independent requires expressions It’s kind of a paradigm shift, there are a lot of things that make metaprogramming more look likeregular functional programming. Meta-Functions A meta-function is not a function but a class/struct Meta-functions are not part of the language and have no formal language support They exist as an idiomatic use of existing language features Their use is not enforced by the language Their use is dictated by convention C++ community has created common “standard” conventions The Definition of meta-function Technically, a class with zero+ template parameters and zero+ return types and values Convention is that a meta-function should return one thing, like a regular function Convention was developed over time, so plenty of existing examples that do not follow this convention More modern meta-functions do follow this convention Return From a Meta-Function Expose a public value “value” 1234template &lt;typename T&gt;struct TheAnswer { static constexpr int value = 42;}; Expose a public type “type” 1234template &lt;typename T&gt;struct Echo { using type = T;}; Meta-functions yield back some types to you. Value Meta-functions Simple regular function: identity This is a very simple regular function. 123int int_identity(int x) { reutrn x; }assert(42 == int_identity(42)); The Simple Meta-Function: identity 123456template &lt;int X&gt;struct IntIdentity { static constexpr int value = X;};static_assert(42 == IntIdentity&lt;42&gt;::value) Generic Identity Function 12345678template &lt;typename T&gt;T identity(T x) { return x; }// Returned type will be intassert(42 == identity(42));// Returned type will be unsigned long longassert(42ull == identity(42ull)); Generic Identity Meta-Function 12345678910template &lt;typename T, T Value&gt;struct ValueIdentity { static constexpr T value = Value;};// The type of value will be intstatic_assert(42 == ValueIdentity&lt;int, 42&gt;::value);// The type of value will be unsigned long longstatic_assert(ValueIdentity&lt;unsigned long long, 42ull&gt;::value == 42ull); Generic Identity Meta-Function (C++17) Template accepts non-type template parameter since C++17. 12345678910template &lt;auto X&gt;struct ValueIdentity { static constexpr auto value = X;};// The type of value will be intstatic_assert(42 == ValueIdentity&lt;42&gt;::value);// The type of value will be unsigned long longstatic_assert(42ull == ValueIdentity&lt;42ull&gt;::value); Two forms of Sum Function 1234567891011121314template &lt;typename X, typename Y&gt;constexpr auto sum(X x, Y y) { return x + y; }// Return type will be unsigned long longassert(42ull == sum(30, 12ull));// It takes two separate non-type template parameterstemplate &lt;auto X, auto Y&gt;struct Sum { static constexpr auto value = X + Y;};// Return type will be unsigned long longstatic_assert(42ull == Sum&lt;30, 12ull&gt;::value); Type Meta-Functions Type meta-functions just like a workhorse (especially will the advent of constexpr) which manipulatetypes. “Returns” a type. This is a type meta-function demo 12template &lt;typename T&gt;struct TypeIdentity { using type = T; }; C++20 introduces std::type_identity Calling Type Meta-Functions12ValueIdentity&lt;42&gt;::value;TypeIdentity&lt;int&gt;::type; Typename Dance 1typename TypeIdentity&lt;T&gt;::type; Convenience Calling Conventions Value meta-functions use variable templates ending with “_v”. 1234567891011121314template &lt;auto X&gt;struct ValueIdentity { static constexpr auto value = X;};// variable template// This is a convenient way to call a value meta-functions using// variable template.template &lt;auto X&gt;inline constexpr auto ValueIdentity_v = ValueIdentity&lt;X&gt;::value;static_assert(42 == ValueIdentity&lt;42&gt;::value);static_assert(42 == ValueIdentity_v&lt;42&gt;); Type Meta-Functions use alias templates ending with “_t”. Typename Dance. 1234template &lt;typename T&gt;using TypeIdentity_t = typename TypeIdentity&lt;T&gt;::type;static_assert(std::is_same_v&lt;int, TypeIdentity_t&lt;int&gt;&gt;); These calling conventions are easier to use. But each one must be explicitly handwritten. A meta-convention to get around that which I may get to if time for bonus material. Type TraitsSome Useful Meta-Functionsstd::integral_constantA very useful meta-function. It allows us to wrap a constant with its type. 123456789101112131415template &lt;class T, T v&gt;struct integral_constant { static constexpr T value = v; using value_type = T; using type = integral_constant&lt;T, v&gt;; constexpr operator value_type() const noexcept { return value; } // this is a functor, a call operator. constexpr value_type operator()() const noexcept { return value; }}; std::bool_constantThis is Convenient helpers. 12345678template &lt;bool B&gt;using bool_constant = integral_constant&lt;bool, B&gt;;// alias templates// this is equivalent to integral_constant&lt;bool, true&gt;.using true_type = bool_constant&lt;true&gt;;// this is equivalent to integral_constant&lt;bool, false&gt;.using false_type = bool_constant&lt;false&gt;; true_type and false_type are going to be meta-functions. They are called nullary meta-functionsbecause they have no parameters. 12true_type::value;false_type::value; Standard Type Trait RequirementsCpp17 Unary Type TraitCpp20 introduces very different meta-programming techniques. For a unary type trait in the standard library which is what we’re got which is what we are talkingabout. Unary type trait in the standard library it has a class template of one template typeargument Cpp17UnaryTypeTrait Class Template One template type argument* Cpp17DefaultConstructible Cpp17CopyConstructible Publicly and unambiguously derived from a specialization of std::integral_constant.All the unary type traits have to derive from integral_constant. The member names of the base characteristic shall not be hidden and shall be unambiguously availableBasically, this means if you inherit from it you can’t hide any of that stuff, you got to let allthat stuff be available publicly. Cpp17BinaryTypeTraitThis is an exactly same thing with Cpp17UnaryTypeTrait except Cpp17BinaryTypeTrait has twotemplate type argument*. Cpp17TransformationTrait Class Template One template type argument* Define a publicly asccessible nested type name type. No default/copy constructible requirement No inheritance requirement Specializationis_void (Unary Type Trait) Value meta-function: is the type void? yields true_type or false_type Specialization Primary template: general case 12template &lt;typename T&gt;struct is_void : std::false_type {}; Specialization: special case(s) 12345678910// The empty angle brackets mean it's an explicit full// specialization, and then we take the type that we// are specializing for. And we put it in right place.// In this case, we are going to return true and so// these static_assert.template&lt;&gt;struct is_void&lt;void&gt; : std::true_type {};static_assert(is_void&lt;void&gt;{});static_assert(not is_void&lt;int&gt;{}); Why does is void reutrn true type false type instead of true false values? The reason because it is a meta-function returning the true type(the actual type of it).First of all, the is_void is inherited from integral_constant. false_type is just integralconstant bool false. true_type is just integral_constant bool true. The standard says thatunary meta-functions must inherit from one of those.And the reason because if all we did was just return a true value where is a is_void is inherit from a true_type, and true_type is already having a type. static_assert(is_void&lt;void&gt;{}, the curly bracket, that is instantiating one of those things and itimplicit conversion operator to turn it into a true. Is void const void? Is void volatile void? is_void is in primary type categories. Yes, the standard says void &amp; void const &amp; void volatile &amp; void const volatile are all void. cv stands for const volatile For any given type T, the result of applying one of these templates to T and to cv T shall yieldthe same result. The definition of is_void 12345678910111213141516171819// The primary templatetemplate &lt;typename T&gt; struct is_void : std::false_type {};// specialization for void.template&lt;&gt;struct is_void&lt;void&gt; : std::true_type {};// specialization for void consttemplate&lt;&gt;struct is_void&lt;void const&gt; : std::true_type {};// specialization for void volatiletemplate&lt;&gt;struct is_void&lt;void volatile&gt; : std::true_type {};// specialization for void const volatiletemplate&lt;&gt;struct is_void &lt;void const volatile&gt; : std::true_type {};// The standard mandates this as well.template &lt;typename T&gt;inline constexpr bool is_void_v = is_void&lt;T&gt;::value; remove_const (Transformation Trait)There are three type traits: unary traits/binary traits/transformation traits. remove_const isa transformation traits. transformation traits are what they call they are type meta-functions. Formal Definition The member typedef type names the same type as T except that any top-level const-qualifier hasbeen removed. The top-level qualifier, like volatile/const which are attached to the type itself. 123456789101112remove_const&lt;int&gt; -&gt; intremove_const&lt;const int&gt; -&gt; intremove_const&lt;const volatile int&gt; -&gt; volatile intremove_const&lt;int *&gt; -&gt; int *remove_const&lt;cont int *&gt; -&gt; const int *// this because pointer to a constant,// it is not a const pointer.remove_const&lt;int const * const&gt; -&gt; int const *remove_const&lt;int * const&gt; -&gt; int * The definition of remove_const 1234567891011121314template &lt;typename T&gt;struct TypeIdentity { using type = T; };// primary template, do nothing if no consttemplate &lt;typename T&gt;struct remove_const : TypeIdentity&lt;T&gt; {};// Partial specialization, when detect consttemplate &lt;typename T&gt;struct remove_const&lt;T const&gt; : TypeIdentity&lt;T&gt; {};// Standar mandated convenience aliastemplate &lt;typename T&gt;using rmeove_const_t = typename remove_const&lt;T&gt;::type; Contains const so the partial specialization will match. 12template &lt;typename T&gt;struct remove_const&lt;T const&gt; : TypeIdentity&lt;T&gt; {}; The const is explicitly matched so the part remaining to match with the “T” is int volatile conditionalThis is basically think of it as like an if statement in regular programming. Some conditions itreturns T, else return F. In this you can read it, if the bool condition is true, return T, else return F. 1234567891011121314151617template &lt;typename T&gt;struct TypeIdentitiy { using type = T; };// This partial specialization means condition is true,// then returns T.template &lt;bool Condition, typename T, typename F&gt;struct conditional : TypeIdentity&lt;T&gt; {};// This partial specialization means condition is false,// then conditional returns F.template &lt;typename T, typename F&gt;struct conditional&lt;false, T, F&gt; : TypeIdentity&lt;F&gt; {};static_assert(is_same_v&lt;int, conditional_t&lt;is_void&lt;void&gt;::value, int, long&gt;);static_assert(is_same_v&lt;long, conditional_t&lt;is_void&lt;char&gt;::value, int, long&gt;); Not all the type traits can be implemented by c++, the compiler has way more information aboutthe type system and about what’s going on than it is exposed to the programmer through thelanguage. Type traits can be implemented by intrinsics, and compiler can be more efficient for intrinsicsprocessing. is_union should be supported by compiler. Primary Type CategoriesThere are 14 primary type categories. 1234567is_void is_classis_null_pointer is_functionis_integral is_pointeris_floating_point is_lvalue_referenceis_array is_rvalue_referenceis_enum is_member_object_pointeris_union is_member_function_pointer All are to have base characteristic of either true_type or false_type. All should yield the same result in light of cv(const volatile) qualifiers. is_null_pointer12345678910111213141516171819template &lt;typename T&gt;struct is_null_pointer : std::false_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t const&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t volatile&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t const volatile&gt; : std::true_type {};// The standard mandates this as well...template &lt;typename T&gt;inline constexpr bool is_null_pointer_v = is_null_pointer&lt;T&gt;::value; is_floating_pointfloat/double/long double requires 12 specializations. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename T&gt; struct is_floating_point : std::false_type {};// float typetemplate &lt;&gt;struct is_floating_point&lt;float&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float const volatile&gt; : std::true_type {};// double typetemplate &lt;&gt;struct is_floating_point&lt;double&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double const volatile&gt; : std::true_type {};// long double typetemplate &lt;&gt;struct is_floating_point&lt;long double&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double const volatile&gt; : std::true_type {};// for convenience usetemplate &lt;typename T&gt;inline constexpr bool is_floating_point_v = is_floating_point&lt;T&gt;::value; is_integral Five standard signed integer types: signed char, short int, int, long int, long long int. Implementation defined extended signed integer types. Corresponding, but different, unsigned integer types. char, char8_t, char16_t, char32_t, wchar_t. bool Requires 16 * 4 = 54 specializations. Meta-Function Abstractions We would have reached for this long before now with regular/normal programming. Treat meta-function programming like regular programming because, well, that’s what it is. Step back to the land of regular functions. Pretend we needed to implement these same ideas with strings instead of types. The regular type of is_void 1234567bool is_void(std::string_view s) { return s == &quot;void&quot; || s == &quot;void const&quot; || s == &quot;void volatile&quot; || s == &quot;void const volatile&quot; || s == &quot;void volatile const&quot;;} A new version of type traits(A Step in the right direction) 123456789101112131415161718192021222324252627282930std::string_view remove_cv(std::string_view);bool is_void(std::string_view s) { return remove_cv(s) == &quot;void&quot;;}bool is_null_pointer(std::string_view s) { return remove_cv(s) == &quot;std::nullptr_t&quot;;}bool is_floating_point(std::string_view input) { auto const s = remove_cv(input); return s == &quot;float&quot; || s == &quot;double&quot; || s == &quot;long double&quot;;}std::string_view strip_signed(std::string_view);bool is_integral(std::string_view input) { auto const s = strip_signed(remove_cv(input)); return s == &quot;bool&quot; || s == &quot;char8_t&quot; || s == &quot;char16_t&quot; || s == &quot;char32_t&quot; || s == &quot;wchar_t&quot; || s == &quot;char&quot; || s == &quot;short&quot; || s == &quot;int&quot; || s == &quot;long&quot; || s == &quot;long long&quot;;} We already have remove_const, we also need remove_volatile, compose them to get remove_cv. remove_volatile Formal Definition The member typedef type names the same type as T except that any top-level volatile-qualifier hasbeen remove. 123456789101112131415template &lt;typename T&gt;struct TypeIdentity { using type = T; };// Primary template, do nothing if no volatiletemplate &lt;typename T&gt;struct remove_volatile : TypeIdentity&lt;T&gt; {};// Partial specialization, when detect volatiletemplate &lt;typename T&gt;strut remove_volatile&lt;T volatile&gt; : TypeIdentity&lt;T&gt; {};// Standard mandated convenience alias.template &lt;typename T&gt;using remove_volatile_t = typename remove_volatile&lt;T&gt;::type; remove_cv Formal Definition The member typedef type names the same type as T except that any top-level cv-qualifier hasbeen removed. 123456789101112131415// template &lt;typename T&gt;// using remove_cv = remove_const&lt;typename remove_volatile&lt;T&gt;::type&gt;;// alias templatetemplate &lt;typename T&gt;using remove_cv = remove_const&lt;remove_volatile_t&lt;T&gt;&gt;;// remove_volatile_t&lt;T&gt; is the same thing with typename// remove_volatile&lt;T&gt;::type.// Here we don't use remove_const_t, this because we want// remove_cv to be a meta-function.// If we use remove_const_t, remove_cv is just a type either// meta-function.template &lt;typename T&gt;using remove_cv_t = typename remove_cv&lt;T&gt;::type; Eg. remove_cv&lt;int const volatile&gt; 12345678// Removing volatile, then consttemplate &lt;typename T&gt;using remove_cv = remove_const&lt;remove_volatile_t&lt;T&gt;&gt;;// remove_cv&lt;int const volatile&gt;// remove_const&lt;remove_volatile_t&lt;int const volatile&gt;&gt;// remove_const&lt;typename remove_volatile&lt;int const volatile&gt;::type&gt;// remove_const&lt;int const&gt; Eg. remove_ct_t&lt;int const volatile&gt; 1234567template &lt;typename T&gt;using remove_cv_t = typename remove_cv&lt;T&gt;::type;// remove_cv_t&lt;int const volatile&gt;// typename remove_cv&lt;int const volatile&gt;::type// typename remove_const&lt;int const&gt;::type// int is_same12345678910111213template &lt;typename T1, typename T2&gt;strut is_same : std::false_type {};// Partial specialization --- when they are both the same.// angle bracketstemplate &lt;typename T&gt;struct is_same&lt;T, T&gt; : std::true_type {};// When T1 and T2 are same, then is_same matches this partial// specialization version. Otherwise, is_same matches the// false_type version. Compiler only choose the best match version.template &lt;typename T1, typename T2&gt;constexpr bool is_same_v = is_same&lt;T1, T2&gt;::value; Examples static_assert(not is_same_v&lt;int, unsigned&gt;) T1 = int, T2 = unsigned, primary template matches. No way to make T to matchspecialization. static_assert(is_same_v&lt;int, int&gt;) T1 = int, T2 = int, primary template matches, T = int – specialization matches is_same_rawThis is not standard type traits, but it is kind of useful. Take two types, and remove eachcv qualifiers and then compares them. If the two types are the same after removing thesecv qualifiers, then I’m treat them the same. So this might be helpful considering thatall of our type traits want us to remove both the const and the volatile qualifiers. 12345template &lt;typename T1, typename T2&gt;using is_same_raw = is_same&lt;remove_cv_t&lt;T1&gt;, remove_cv_t&lt;T2&gt;&gt;;template &lt;typename T1, typename T2&gt;constexpr bool is_same_raw_v = is_same_raw&lt;T1, T2&gt;::value; is_floating_point: reduxThis is using alias template. 12345template &lt;typename T&gt;using is_floating_point = std::bool_constant&lt; is_same_raw_v&lt;float, T&gt; || is_same_raw_v&lt;double, T&gt; || is_same_raw_v&lt;long double, T&gt;&gt;; is_integral: redux123456789101112131415161718template &lt;typename T&gt;using is_integral = std::bool_constant&lt; is_same_raw_v&lt;bool, T&gt; || is_same_raw_v&lt;char, T&gt; || is_same_raw_v&lt;char8_t, T&gt; || is_same_raw_v&lt;char16_t, T&gt; || is_same_raw_v&lt;char32_t, T&gt; || is_same_raw_v&lt;wchar_t, T&gt; || is_same_raw_v&lt;signed char, T&gt; || is_same_raw_v&lt;short, T&gt; || is_same_raw_v&lt;int, T&gt; || is_same_raw_v&lt;long, T&gt; || is_same_raw_v&lt;long long, T&gt; || is_same_raw_v&lt;unsigned char, T&gt; || is_same_raw_v&lt;unsigned short, T&gt; || is_same_raw_v&lt;unsigned int, T&gt; || is_same_raw_v&lt;unsigned long, T&gt; || is_same_raw_v&lt;unsigned long long, T&gt;&gt;; It might be implemented using parameter pack. is_type_in_pack is a meta-function, it takes a type and ti take a list of bunch of other types.Adn is_type_in_pack will biscally returned true if that type was anywhere in that list. 12345678910111213template &lt;typename TargetT, typename ...Ts&gt;using is_type_in_pack = ...;template &lt;typename T&gt;using is_integral = is_type_inpack&lt;remove_cv_t&lt;T&gt;, bool, char, char8_t, char16_t, char32_t, wchar_t, signed char, unsigned char, signed short, unsigned short, signed int, unsigned int, signed long, unsigned long, signed long long, unsigned long long&gt;; is_arrayThe definition of is_array. 12345678910template &lt;typename T&gt;struct is_array : std::false_type {};// inbounded arraytemplate &lt;typename T, std::size_t N&gt;struct is_arrya &lt;T[N]&gt; : std::true_type {};// unbounded arraytemplate &lt;typename T&gt;struct is_array&lt;T[]&gt; : std::true_type {}; Some examples. 1234567static_assert(is_array,int[5]&gt;);// T = int[5] - primary template matches// T = int, N = 5 - first specialization matches// no way to form T to match second sepcializationstatic_assert(is_array&lt;int[]&gt;);// T = int[] == primary template matches is_pointer1234567891011121314namespace detail {// Primary template - most things are not pointerstemplate &lt;typename T&gt;struct is_pointer_impl : std::false_type {};// When we have a pointertemplate &lt;typename T&gt;struct is_pointer_impl&lt;T *&gt; : std::true_type {};} // end of namespace detail// alias template template &lt;typename T&gt;using is_pointer = detail::is_pointer_impl&lt;remove_cv_t&lt;T&gt;&gt;; is_unionThis meta-function is actually impossible to implement without support from the compiler. Both clangand gcc provide this particular compiler intrinsic to determine if a type is a union. 12template &lt;typename T&gt;using is_union = std::bool_constant&lt;__is_union(T)&gt;; is_class_or_unionWhat do we know about unions and classes that is unique to those two types? They can have members. Devise a way to detect if a type can have a member. How can you tell if a class has a member? The syntax for a pointer-to-member is valid for any class, even without any members. Eg. int* is a valid pointer type, but does not have to point to anything. meta-programming is aimed todeal with types, not the data. int Foo::* is a member pointer type, does not have to point to anything. 12345678910// An empty struct, with no members of any kindstruct Bar {};// BarIntObjectMemPtr is an alias for a type that is a// pointer to a member of class Bar, where the member// is an int.using BarintObjectMemPtr = int Bar::*;// This, however, generates a hard compiler errorusign LongIntObjectMemPtr = ing long::*; Funciton Overload Resolution123456789101112namespace detail {std::true_type is_nullptr(std::nullptr_t);// ... it will match anything. But it is the least priority.// It will only ever be used if nothing else matches. It'll// only be used if it's the only one that matches.std::false_type is_nullptr(...);} // end of namespace detailtemplate &lt;typename T&gt;using is_null_pointer = decltype(detail::is_nullptr(std::devlval&lt;T&gt;())); 123456static_assert(not is_null_pointer&lt;int&gt;::value);// This only match the second one.static_assert(is_null_pointer&lt;std::nullptr_t&gt;::value);// This can match two versions of `is_nullptr`, but overload// resolution will choose the first one, because the first// one is the best match. Another case. 1234567891011121314template &lt;typename T&gt;struct TypeIdentity { using type = T; };namespace detail {template &lt;typename T&gt;std::true_type isconst(TypeIdentity&lt;T const&gt;);template &lt;typename T&gt;std::false_type isconst(TypeIdentity&lt;T&gt;);} // end of namespace detailtemplate &lt;typename T&gt;using is_const = decltype(detail::isconst(std::declval&lt;TypeIdentity&lt;T&gt;&gt;())); This uses technique called Tag Dispatch. Tag Dispatch is where we are creating a type that isjust being used as a tag. TypeIdentity takes no space, and it is very efficient to pass these guys around. SFINAE (Substitution Failure Is Not An Error)12345template &lt;typename T&gt;std::true_type can_have_pointer_to_member(int T::*);template &lt;typename T&gt;std::false_type can_have_pointer_to_member(...); is_classAlmost always implemented as compiler intrinsic. Because compiler is much faster dealing withintrinsics than dealing with even the simplest template stuff. Without the support of compiler, itis kind of impossible to distinguish between union and non-union class type. We have is_union (with help from the compiler) The definition is: 1234567891011121314namespace detail {template &lt;typename T&gt;std::bool_constant&lt;not std::is_union_v&lt;T&gt;&gt;is_class_or_union(int T::*);// We only want to use the return type of `is_class_or_union`// function. So we don't need to create implementation for this// function.template &lt;typename T&gt;std::false_type is_class_or_union(...);}template &lt;typename T&gt;using is_class = decltype(detail::is_class_or_union&lt;T&gt;(nullptr)); Implement is_class using constexpr. 12345678910111213namespace detail {template &lt;typename T&gt; constexpr bool is_class_or_union(int T::*) { return not std::is_union&lt;T&gt;::value;}template &lt;typename T&gt; constexpr bool is_class_or_union(...) { return false;}} // end of namespace detailtemplate &lt;typename T&gt;using is_class = std::bool_constant&lt;detail::is_class_or_union&lt;T&gt;(nullptr)&gt;; 123template &lt;typename T&gt;using is_const = decltype(detail::isconst(std::declval&lt;TypeIdentity&lt;T&gt;&gt;())); decltype — tells you to pretend that compiler will evaluate this expression, and give me theresult the type that you would get from the evaluated expression. declval — is there so you can grab a reference to any type. It just gives you a referenceto something as if you had created one as if you had one. So it just declaration, it’s there’s noimplementation. is_in_pack1234567891011121314151617// Template declaration, with no definitiontemplate &lt;typename TargetT, typename... Ts&gt;struct IsInPack;// Base case --- no more elementstemplate &lt;typename TargetT&gt;struct IsInPack&lt;TargetT&gt; : std::false_type {};// NOTES: is_in_pack uses partial specialization to match// the two same types. If the first one matches the target,// we are done.template &lt;typename TargetT, typename... Ts&gt;struct IsInpack&lt;TargetT, TargetT, Ts...&gt; : std::true_type {};// Otherwise, check the remaining ones.template &lt;typename TargetT, typename T, typename... Ts&gt;struct IsInpack&lt;TargetT, T, Ts...&gt; : IsInPack&lt;Target, Ts...&gt; {}; Examples 12static_assert(IsInPack&lt;int, double,char,int,float&gt;::value);static_assert(not IsInPack&lt;long, double,char,int,float&gt;::value); The version of using is_base_of. 123456789101112namespace detail {template &lt;typename T&gt;struct TypeIdentitiy { using type = T; };template &lt;typename... Ts&gt;struct IsInPackImpl : TypeIdentity&lt;Ts&gt;... {};tmeplate &lt;typename TargetT, typename... Ts&gt;using IsInpack = std::is_base_of&lt; TypeIdentity&lt;TargetT&gt;, detail::IsInPackImpl&lt;Ts...&gt;&gt;;} // end of namespace detail Examples 12static_assert(IsInPack&lt;int, double,char,int,float&gt;::value);static_assert(not IsInPack&lt;long, double,char,int,float&gt;::value); is_base_ofIf Derived is derived from Base or if both are the same non-union class (in both casescv-qualification), provides the member constant value equal to true. Otherwise value is false. The possible definition of is_base_of is as follows: 12345678910111213141516171819202122namespace detail {template &lt;typename B&gt;std::true_type test_pre_ptr_convertible(const volatile B*);template &lt;typename&gt;std::false_type test_pre_ptr_convertible(const volatile void*);template &lt;typename, typename&gt;auto test_pre_is_base_of(...) -&gt; std::true_type;template &lt;typename B, typename D&gt;auto test_pre_is_base_of(int) -&gt; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));} // end of namespace detailtemplate &lt;typename Base, typename Derived&gt;struct is_base_of : std::integral_constant&lt; bool, std::is_class&lt;Base&gt;::value &amp;&amp; std::is_class&lt;Derived&gt;::value &amp;&amp; decltype(details::test_pre_is_base_of&lt;Base, Derived&gt;(0))::value &gt; {}; Learning materials. Template Metaprogramming: Type Traits Part I Template Metaprogramming: Type Traits Part II Modern Template Metaprogramming: A Compendium, Part I, Walter E. Brown, CppCon 2014,Link: Part IPart II References Modern C++ Design About C++ Template Metaprogramming Template Metaprogramming with C++ Generic programming in OO Languages 30 Core Guidelines for Writting Clean, Safe, and Fast Code Reflective Metaprogramming in C++ Tag Dispatching","link":"/2022/11/06/Template-Metaprogramming-Type-Traits/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/10/30/hello-world/"},{"title":"CUDA Thrust Introduction","text":"Thrust is analogous to C++ Standard Template Library(STL). The Thrust algorithms can run on both the host and the device. Sort, scan, reduce, reduce-by-keyTransform input vector(s)Eg. vector addition thrust::plusOr you can apply user defined transformation functors.interoperate with CUDA code. If you don’t need to do something that is not built in to Thrust or that’s difficult to do with Thrust 123456thrust::device_vector&lt;float&gt; X(3);float result = thrust::reduce(X.begin(), X.end());// orfloat init = 0.f;// We can pass in an operator to use or a functor.result = thrust::reduce(X.begin(), X.end(), init, thrust::maximum&lt;float&gt;()); Some AlgorithmsThese algorithms are existed in thrust, but do not exist in C++ STL library. 12345678thrust::gather();thrust::gather_if();thrust::scatter();thrust::scatter_if();thrust::sequence();thrust::stable_partition_copy();thrust::tabulate();thrust::transform_if(); thrust::sequence()The equivalent of algorithm in STL is std::iota, which is not a good name. Thrust changes this name to sequence. Some algorithms in &lt;numeric&gt; header. There are 12 by-key-algorithms in thrust. These 12 algorithms are super useful. You can think of them as segmented versions of their corresponding algorithms. So if you have an inclusive scan by key. This is exactly like an inclusive scan but instead of doing it on a whole range you are doing it on segments of a range, which can come in handy in many cases. 123456789101112thrust::exclusive_scan_by_key();thrust::inclusive_scan_by_key();thrust::merge_by_key();thrust::reduce_by_key();thrust::set_difference_by_key();thrust::set_intersection_by_key();thrust::set_symmetric_difference_by_key();thrust::set_union_by_key();thrust::sort_by_key();thrust::stable_sort_by_key();thrust::unique_by_key();thrust::unique_by_key_copy(); There are three examples that shows how to use these algorithms. Problem 1 In C++ STL view. What is std::iota + std::transform? In Thrust view: What is thrust::sequence + thrust::transform? These two algorithms combined to make a single algorithm: thrust::tabulate. This is very interesting algorithm. Generate the first odd number. For example, generate first 10 odd numbers. In C++ 12345678auto odds = std::vector&lt;int&gt;(10);std::iota(odds.begin(), odds.end(), 0);std::transform( odds.begin(), odds.end(), odds.begin(), [](auto e) { return e * 2 + 1; }); In CUDA With Thrust 1234auto odds = std::vector&lt;int&gt;(10);thrust::tabulate( odds.begin(), odds.end(), [](auto e) { return e * 2 + 1; }); This code is running on the host. And this is very easy to transform this code to device. 1234auto odds = std::device_vector&lt;int&gt;(10);thrust::tabulate( odds.begin(), odds.end(), [] __device__ (auto e) { return e * 2 + 1; }); Problem 2 Copy every other number. The answer is thrust::gather(). 1234567891011auto const deck = std::vector&lt;int&gt;{13, 2, 14, 3, 6, 7};auto const gather_map = std::vector&lt;int&gt;{0, 2, 4};auto hand = std::vector&lt;int&gt;(3);// deals every second card to handthrust::gather( gather_map.cbegin(), // The first two iterators define the gather map. gather_map.cend(), deck.cbegin(), // defines source that we are gathering from hand.begin()); // defines the target that we are gathering to.// The final results: hand = {13, 14, 6}; Problem 3 — MCO Maximum Consecutive Ones Using thrust::reduce_by_key() for solve this problem. 1234567891011121314// 1 1 1 0 0 1 0 1 1 1 1// For example, calculates the longest contiguous sequence of ones. In this example, the answer is 4.auto const ones = std::vector&lt;int&gt;{1, 1, 1, 0, 1, 1, 1, 1};auto sums = std::vector&lt;int&gt;(3);thrust::reduce_by_key( ones.cbegin(), // keys input ones.cend(), ones.cbegin(), // values input thrust::make_discard_iterator(), // keys output sums.begin()); // values outputauto const max = *thrust::max_element( sums.cbegin(), sums.cend());","link":"/2022/11/22/CUDA-Thrust-Introduction/"},{"title":"Thrust Archiecture Overview","text":"IntroductionTODO Thrust is not CUDA specific, it does not allow the programmers to interfere CUDA specific details (the number of threads, cudaStream_t parameters etc.). Because of that, the primitives can not be configured for a specific GPU architecture. OverviewTODO ArchitectureTODO APIsTODO ContainersTODO AlgorithmsTODO CopyingGatheringReference Page thrust::gather12345678910111213141516171819template &lt;typename DerivedPolicy, typename InputIterator, typename RandomAccessIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::gather(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator map_first, InputIterator map_last, RandomAccessIterator input_first, OutputIterator result);template &lt;typename InputIterator, typename RandomAccessIterator, typename OutputIterator&gt;OutputIteratorthrust::gather(InputIterator map_first, InputIterator map_last, RandomAccessIterator input_first, OutputIterator result); thrust::gather_if1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template &lt;typename DerivedPolicy, typename InputIterator, typename RandomAccessIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::gather(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator map_first, InputIterator map_last, RandomAccessIterator input_first, OutputIterator result);template &lt;typename InputIterator, typename RandomAccessIterator, typename OutputIterator&gt;OutputIteratorthrust::gather(InputIterator map_first, InputIterator map_last, RandomAccessIterator input_first, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename RandomAccessIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::gather_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 map_first, InputIterator1 map_last, InputIterator2 stencil, RandomAccessIterator input_first, OutputIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename RandomAccessIterator, typename OutputIterator&gt;OutputIteratorthrust::gather_if(InputIterator1 map_first, InputIterator1 map_last, InputIterator2 stencil, RandomAccessIterator input_first, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename RandomAccessIterator, typename OutputIterator, typename Predicate&gt;__host__ __device__ OutputIteratorthrust::gather_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 map_first, InputIterator1 map_last, InputIterator2 stencil, RandomAccessIterator input_first, OutputIterator result, Predicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename RandomAccessIterator, typename OutputIterator, typename Predicate&gt;OutputIteratorthrust::gather_if(InputIterator1 map_first, InputIterator1 map_last, InputIterator2 stencil, RandomAccessIterator input_first, OutputIterator result, Predicate pred); ScatteringReference Page thrust::scatterthrust::scatter copies elements from a source range into an output array according to a map. For each iterator i in the range [first, last), the value *i is assigned to output[*(map + (i - first))]. The output iterator must permit random access. If the same index appears more than once in the range [map, map + (last - first)), the result is undefined. 12345678910111213141516171819template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename RandomAccessIterator&gt;__host__ __device__ voidthrust::scatter(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, RandomAccessIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename RandomAccessIterator&gt;voidthrust::scatter(InputIterator1 first, InputIterator1 last, InputIterator2 map, RandomAccessIterator result); The following code demonstrates how to use thrust::scatter to reorder a range using the thrust::device execution policy for parallelization: 123456789101112131415161718#include &lt;thrust/scatter.h&gt;#include &lt;thrust/device_vector.h&gt;#include &lt;thrust/execution_policy.h&gt;// mark even indices with a 1; odd indices with a oint values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};thrust::device_vector&lt;int&gt; d_values(values, values + 10);// scatter all even indices into the first half of the// range, and odd indices vice versa.int map[10] = {0, 5, 1, 6, 2, 7, 3, 8, 4, 9};thrust::device_vector&lt;int&gt; d_map(map, map + 10);thrust::device_vector&lt;int&gt; d_output(10);thrust::scatter(thrust::device, d_values.begin(), d_values.end(), d_map.begin(), d_output.begin());// d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}; thrust::scatter_if123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename RandomAccessIterator&gt;__host__ __device__ voidthrust::scatter_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename RandomAccessIterator&gt;voidthrust::scatter_if(InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename RandomAccessIterator, typename Predicate&gt;__host__ __device__ voidthrust::scatter_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output, Predicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename RandomAccessIterator, typename Predicate&gt;voidthrust::scatter_if(InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output, Predicate pred); CopyingReference Page thrust::copy123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result);template &lt;typename InputIterator, typename OutputIterator&gt;OutputIteratorthrust::copy(InputIterator first, InputIterator last, OutputIterator result); thrust::copy_n1234567891011121314151617template &lt;typename DerivedPolicy, typename InputIterator, typename Size, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::copy_n(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, Size n, OutputIterator result);template &lt;typename InputIterator, typename Size, typename OutputIterator&gt;OutputIteratorthrust::copy_n(InputIterator first, Size n, OutputIterator result); thrust::swap_rangesthrust::swap_ranges swaps each of the elements in the range [first1, last1) with the corresponding element in the range [first2, first2 + (last1 - first1)). That is, for each integer n such that 0 &lt;= n &lt; (last1 - first1), it swaps *(first1 + n) and *(first2 + n). The return value is first2 + (lsat1 - first1). 123456789101112131415template &lt;typename DerivedPolicy, typename ForwardIterator1, typename ForwardIterator2&gt;__host__ __device__ ForwardIterator2thrust::swap_ranges(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);template &lt;typename ForwardIterator1, typename ForwardIterator2&gt;ForwardIterator2thrust::swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2); The following code snippet demonstrates how to use swap_ranges to swap the contents of two thrust::device_vectors using the thrust::device execution policy for parallelization: 123456789101112131415#include &lt;thrust/swap.h&gt;#include &lt;thrust/device_vector.h&gt;#include &lt;thrust/execution_policy.h&gt;thrust::device_vector&lt;int&gt; v1(2), v2(2);v1[0] = 1;v1[1] = 2;v2[0] = 3;v2[1] = 4;thrust::swap_ranges(thrust::device, v1.begin(), v1.end(), v2.begin());// The result is:// v1[0] = 3, v1[1] = 4// v2[0] = 1, v2[1] = 2 thrust::uninitialized_copy123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename ForwardIterator&gt;__host__ __device__ ForwardIteratorthrust::uninitialized_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, ForwardIterator result);template &lt;typename InputIterator, typename ForwardIterator&gt;ForwardIteratorthrust::uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result); thrust::uninitialized_copy_n1234567891011121314151617template &lt;typename DerivedPolicy, typename InputIterator, typename Size, typename ForwardIterator&gt;__host__ __device__ ForwardIteratorthrust::uninitialized_copy_n(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, Size n, ForwardIterator result);template &lt;typename InputIterator, typename Size, typename ForwardIterator&gt;ForwardIteratorthrust::uninitialized_copy_n(InputIterator first, Size n, ForwardIterator result); MergingReference Page thrust::mergethrust::merge combines two sorted ranges [first1, last1) and [first2, last2) into a single sorted range. That is, it copies from [first1, last1) and [first2, last2) into [result, result + (last1 - first1) + (last2 - first2)) such taht the resulting range is in ascending order. merge is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is result + (last1 - first1) + (last2 - first2). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::merge(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;OutputIteratorthrust::merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;__host__ __device__ OutputIteratorthrust::merge(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;OutputIteratorthrust::merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp); The following code snippet demonstrates how to use merge to compute the merger of two sorted sets of integers using the thrust::host execution policy for parallelization: 12345678910111213#include &lt;thrust/merge.h&gt;#include &lt;thrust/execution_policy.h&gt;// ...int A1[6] = {1, 3, 5, 7, 9, 11};int A2[7] = {1, 1, 2, 3, 5, 8, 13};int result[13];int *result_end = thrust::merge(thrust::host, A1, A1 + 6, A2, A2 + 7, result);// result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}; thrust::merge_by_key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::merge_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::merge_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename Compare&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::merge_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, Compare comp);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::merge_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp); Prefix SumsSegmented Prefix SumsReference Page thrust::inclusive_scan_by_key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::inclusive_scan_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;OutputIteratorthrust::inclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryPredicate&gt;__host__ __device__ OutputIteratorthrust::inclusive_scan_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryPredicate&gt;OutputIteratorthrust::inclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryPredicate, typename AssociativeOperator&gt;__host__ __device__ OutputIteratorthrust::inclusive_scan_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryPredicate, typename AssociativeOperator&gt;OutputIteratorthrust::inclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op); thrust::exclusive_scan_by_key123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::exclusive_scan_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;OutputIteratorthrust::exclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename T&gt;__host__ __device__ OutputIteratorthrust::exclusive_scan_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename T&gt;OutputIteratorthrust::exclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename T, typename BinaryPredicate&gt;__host__ __device__ OutputIteratorthrust::exclusive_scan_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename T, typename BinaryPredicate&gt;OutputIteratorthrust::exclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename T, typename BinaryPredicate, typename AssociativeOperator&gt;__host__ __device__ OutputIteratorthrust::exclusive_scan_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename T, typename BinaryPredicate, typename AssociativeOperator&gt;OutputIteratorthrust::exclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op); Transformed Prefix SumsReference Page thrust::transform_inclusive_scan1234567891011121314151617181920212223template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename UnaryFunction, typename AssociativeOperator&gt;__host__ __device__ OutputIteratorthrust::transform_inclusive_scan(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, AssociativeOperator binary_op);template &lt;typename InputIterator, typename OutputIterator, typename UnaryFunction, typename AssociativeOperator&gt;OutputIteratorthrust::transform_inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, AssociativeOperator binary_op); trust::transform_exclusive_scan123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename UnaryFunction, typename T, typename AssociativeOperator&gt;__host__ __device__ OutputIteratorthrust::transform_exclusive_scan(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, T init, AssociativeOperator binary_op);template &lt;typename InputIterator, typename OutputIterator, typename UnaryFunction, typename T, typename AssociativeOperator&gt;OutputIteratorthrust::transform_exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, T init, AssociativeOperator binary_op); Group Prefix SumsReference Page thrust::inclusive_scaninclusive_scan computes an inclusive prefix sum operation. The term ‘inclusive’ means each result includes the corresponding input operand in the partial sum. More precisely, *first is assigned to *result and the sum of *first and *(first ~ 1) is assigned to *(result + 1), and so on.thrust::inclusive_scan is similar to std::partial_sum in the STL. The primary difference between the two functions is that std::parital_sum guarantees a serial summation order, while thrust::inclusive_scan requires associativity of the binary operation to parallelize the prefix sum.Results are not deterministic for pseudo-associative operators (e.g. addition of floating-point types). Results for pseudo-associative operators may vary from run to run.The algorithm’s execution is parallelized as determined by exec. 1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::inclusive_scan(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result);template &lt;typename InputIterator, typename OutputIterator&gt;OutputIteratorthrust::inclusive_scan(InputIterator first, InputIterator last, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename AssociativeOperator&gt;__host__ __device__ OutputIteratorthrust::inclusive_scan(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op);template &lt;typename InputIterator, typename OutputIterator, typename AssociativeOperator&gt;OutputIteratorthrust::inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op); The following code snippet demonstrates how to use inclusive_scan to compute an in-place p thrust::exclusive_scan1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::exclusive_scan(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result);template &lt;typename InputIterator, typename OutputIterator&gt;OutputIteratorthrust::exclusive_scan(InputIterator first, InputIterator last, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename T&gt;__host__ __device__ OutputIteratorthrust::exclusive_scan(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, T init);template &lt;typename InputIterator, typename OutputIterator, typename T&gt;OutputIteratorthrust::exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init);template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename T, typename AssociativeOperator&gt;__host__ __device__ OutputIteratorthrust::exclusive_scan(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, T init, AssociativeOperator binary_op);template &lt;typename InputIterator, typename OutputIterator, typename T, typename AssociativeOperator&gt;OutputIteratorthrust::exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init, AssociativeOperator binary_op); ReductionsComparisonsReference Page thrust::equal1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2&gt;__host__ __device__ boolthrust::equal(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);template &lt;typename InputIterator1, typename InputIterator2&gt;boolthrust::equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate&gt;__host__ __device__ boolthrust::equal(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred);template &lt;typename InputIterator1, typename InputIterator2, typename BinaryPredicate&gt;boolthrust::equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred); CountingReference Page thrust::count123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename EqualityComparable&gt;__host__ __device__ thrust::iterator_traits&lt; InputIterator &gt;::difference_typethrust::count(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, const EqualityComparable &amp; value);template &lt;typename InputIterator, typename EqualityComparable&gt;thrust::iterator_traits&lt; InputIterator &gt;::difference_typethrust::count(InputIterator first, InputIterator last, const EqualityComparable &amp; value); thrust::count_if123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename Predicate&gt;__host__ __device__ thrust::iterator_traits&lt; InputIterator &gt;::difference_typethrust::count_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, Predicate pred);template &lt;typename InputIterator, typename Predicate&gt;thrust::iterator_traits&lt; InputIterator &gt;::difference_typethrust::count_if(InputIterator first, InputIterator last, Predicate pred); ExtremaReference Page thrust::min_element123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename ForwardIterator&gt;__host__ __device__ ForwardIteratorthrust::min_element(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last);template &lt;typename ForwardIterator&gt;ForwardIteratorthrust::min_element(ForwardIterator first, ForwardIterator last);template &lt;typename DerivedPolicy, typename ForwardIterator, typename BinaryPredicate&gt;__host__ __device__ ForwardIteratorthrust::min_element(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, BinaryPredicate comp);template &lt;typename ForwardIterator, typename BinaryPredicate&gt;ForwardIteratorthrust::min_element(ForwardIterator first, ForwardIterator last, BinaryPredicate comp); thrust::max_element12345678910111213141516171819202122232425262728template &lt;typename DerivedPolicy, typename ForwardIterator&gt;__host__ __device__ ForwardIteratorthrust::max_element(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last);template &lt;typename ForwardIterator&gt;ForwardIteratorthrust::max_element(ForwardIterator first, ForwardIterator last);template &lt;typename DerivedPolicy, typename ForwardIterator, typename BinaryPredicate&gt;__host__ __device__ ForwardIteratorthrust::max_element(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, BinaryPredicate comp);template &lt;typename ForwardIterator, typename BinaryPredicate&gt;ForwardIteratorthrust::max_element(ForwardIterator first, ForwardIterator last, BinaryPredicate comp); thrust::minmax_element123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename ForwardIterator&gt;__host__ __device__ thrust::pair&lt; ForwardIterator, ForwardIterator &gt;thrust::minmax_element(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last);template &lt;typename ForwardIterator&gt;thrust::pair&lt; ForwardIterator, ForwardIterator &gt;thrust::minmax_element(ForwardIterator first, ForwardIterator last);template &lt;typename DerivedPolicy, typename ForwardIterator, typename BinaryPredicate&gt;__host__ __device__ thrust::pair&lt; ForwardIterator, ForwardIterator &gt;thrust::minmax_element(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, BinaryPredicate comp);template &lt;typename ForwardIterator, typename BinaryPredicate&gt;thrust::pair&lt; ForwardIterator, ForwardIterator &gt;thrust::minmax_element(ForwardIterator first, ForwardIterator last, BinaryPredicate comp); LogicalReference Page thrust::all_of123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename Predicate&gt;__host__ __device__ boolthrust::all_of(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, Predicate pred);template &lt;typename InputIterator, typename Predicate&gt;boolthrust::all_of(InputIterator first, InputIterator last, Predicate pred); thrust::any_of123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename Predicate&gt;__host__ __device__ boolthrust::any_of(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, Predicate pred);template &lt;typename InputIterator, typename Predicate&gt;boolthrust::any_of(InputIterator first, InputIterator last, Predicate pred); thrust::none_of123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename Predicate&gt;__host__ __device__ boolthrust::none_of(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, Predicate pred);template &lt;typename InputIterator, typename Predicate&gt;boolthrust::none_of(InputIterator first, InputIterator last, Predicate pred); PredicatesReference Page thrust::is_partitionedthrust::is_partitioned returns true if the given range is partitioned with respect to a predicate, and false otherwise. 是否所有满足predicates的元素都出现在不满足 predicates的元素前面。Specifically, thrust::is_partitioned returns true if [first, last) is empty of if [first, last) is partitioned by pred, i.e. if all elements that satisfy pred appear before those that do not. 123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename Predicate&gt;__host__ __device__ boolthrust::is_partitioned(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, Predicate pred);template &lt;typename InputIterator, typename Predicate&gt;boolthrust::is_partitioned(InputIterator first, InputIterator last, Predicate pred); The following code demonstrates how to use thrust::is_partitioned: 123456789101112#include &lt;thrust/partition.h&gt;#include &lt;thrust/execution_policy.h&gt;struct is_even { __host__ __device__ bool operator()(const int &amp;x) { return (x % 2) == 0; }};// ...int A[] = {2, 4, 6, 8, 19, 1, 3, 5, 7, 9};int B[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};thrust::is_partitioned(thrust::host, A, A + 10, is_even()); // returns truethrust::is_partitioned(thrust::host, B, B + 10, is_even()); // returns false thrust::is_sortedthrust::is_sorted returns true if the range [first, last) is sorted in ascending order, and false otherwise. 123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename ForwardIterator&gt;__host__ __device__ boolthrust::is_sorted(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last);template &lt;typename ForwardIterator&gt;boolthrust::is_sorted(ForwardIterator first, ForwardIterator last);template &lt;typename DerivedPolicy, typename ForwardIterator, typename Compare&gt;__host__ __device__ boolthrust::is_sorted(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, Compare comp);template &lt;typename ForwardIterator, typename Compare&gt;boolthrust::is_sorted(ForwardIterator first, ForwardIterator last, Compare comp); The following code demonstrates how to use thrust::is_sorted: 12345678910111213141516171819#include &lt;thrust/sort.h&gt;#include &lt;thrust/device_vector.h&gt;#include &lt;thrust/sort.h&gt;#include &lt;thrust/execution_policy.h&gt;thrust::device_vector&lt;int&gt; v(6);v[0] = 1;v[1] = 4;v[2] = 2;v[3] = 8;v[4] = 5;v[5] = 7;bool result = thrust::is_sorted(thrust::device, v.begin(), v.end());// result == false;thrust::sort(v.begin(), v.end());result = thrust::is_sorted(thrust::device, v.begin(), v.end());// result = true; thrust::is_sorted_until123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename ForwardIterator&gt;__host__ __device__ ForwardIteratorthrust::is_sorted_until(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last);template &lt;typename ForwardIterator&gt;ForwardIteratorthrust::is_sorted_until(ForwardIterator first, ForwardIterator last);template &lt;typename DerivedPolicy, typename ForwardIterator, typename Compare&gt;__host__ __device__ ForwardIteratorthrust::is_sorted_until(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, Compare comp);template &lt;typename ForwardIterator, typename Compare&gt;ForwardIteratorthrust::is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp); Transformed ReductionsReference Page thrust::inner_product1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputType&gt;__host__ __device__ OutputTypethrust::inner_product(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init);template &lt;typename InputIterator1, typename InputIterator2, typename OutputType&gt;OutputTypethrust::inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputType, typename BinaryFunction1, typename BinaryFunction2&gt;__host__ __device__ OutputTypethrust::inner_product(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2);template &lt;typename InputIterator1, typename InputIterator2, typename OutputType, typename BinaryFunction1, typename BinaryFunction2&gt;OutputTypethrust::inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2); thrust::transform_reduce1234567891011121314151617181920212223template &lt;typename DerivedPolicy, typename InputIterator, typename UnaryFunction, typename OutputType, typename BinaryFunction&gt;__host__ __device__ OutputTypethrust::transform_reduce(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, UnaryFunction unary_op, OutputType init, BinaryFunction binary_op);template &lt;typename InputIterator, typename UnaryFunction, typename OutputType, typename BinaryFunction&gt;OutputTypethrust::transform_reduce(InputIterator first, InputIterator last, UnaryFunction unary_op, OutputType init, BinaryFunction binary_op); ReductionsReference Page thrust::reduce1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename InputIterator&gt;__host__ __device__ thrust::iterator_traits&lt; InputIterator &gt;::value_typethrust::reduce(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last);template &lt;typename InputIterator&gt;thrust::iterator_traits&lt; InputIterator &gt;::value_typethrust::reduce(InputIterator first, InputIterator last);template &lt;typename DerivedPolicy, typename InputIterator, typename T&gt;__host__ __device__ Tthrust::reduce(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, T init);template &lt;typename InputIterator, typename T&gt;Tthrust::reduce(InputIterator first, InputIterator last, T init);template &lt;typename DerivedPolicy, typename InputIterator, typename T, typename BinaryFunction&gt;__host__ __device__ Tthrust::reduce(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, T init, BinaryFunction binary_op);template &lt;typename InputIterator, typename T, typename BinaryFunction&gt;Tthrust::reduce(InputIterator first, InputIterator last, T init, BinaryFunction binary_op); thrust::reduce_by_key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::reduce_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::reduce_by_key(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename BinaryPredicate&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::reduce_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename BinaryPredicate&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::reduce_by_key(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename BinaryPredicate, typename BinaryFunction&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::reduce_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename BinaryPredicate, typename BinaryFunction&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::reduce_by_key(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op); ReorderingPartitioningReference Page thrust::partition根据 Predicate 的结果来重新排列元素(true 元素在前，其余元素在后面).thrust::partition reorders the elements [first, last) based on the function object pred applied to a stencil range [stencil, stencil + (last - first)), such that all the elements whose corresponding stencil element satisfies pred precede all the elements whose corresponding stencil element failed Preconditions: The ranges [first, last) and [stencil, tencil + (last - first)) shall not overlap. Returns: An iterator referring to the first element of the second partition, that is, the sequence of the elements whose stencil elements do not satisfy pred. 1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename ForwardIterator, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::partition(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, Predicate pred);template &lt;typename ForwardIterator, typename Predicate&gt;ForwardIteratorthrust::partition(ForwardIterator first, ForwardIterator last, Predicate pred);template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::partition(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred);template &lt;typename ForwardIterator, typename InputIterator, typename Predicate&gt;ForwardIteratorthrust::partition(ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred); thrust::partition_copythrust::partition_copy differs from partition only in that the reordered sequence is written to difference output sequences, rather than in place. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator1, typename OutputIterator2, typename Predicate&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::partition_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);template &lt;typename InputIterator, typename OutputIterator1, typename OutputIterator2, typename Predicate&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::partition_copy(InputIterator first, InputIterator last, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename Predicate&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::partition_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename Predicate&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::partition_copy(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred); thrust::stable_partition1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename ForwardIterator, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::stable_partition(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, Predicate pred);template &lt;typename ForwardIterator, typename Predicate&gt;ForwardIteratorthrust::stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::stable_partition(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred);template &lt;typename ForwardIterator, typename InputIterator, typename Predicate&gt;ForwardIteratorthrust::stable_partition(ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred); thrust::stable_partition_copy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator1, typename OutputIterator2, typename Predicate&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::stable_partition_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);template &lt;typename InputIterator, typename OutputIterator1, typename OutputIterator2, typename Predicate&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::stable_partition_copy(InputIterator first, InputIterator last, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename Predicate&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::stable_partition_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename Predicate&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::stable_partition_copy(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred); ShufflingReference Page thrust::shuffle123456789101112131415template &lt;typename DerivedPolicy, typename RandomIterator, typename URBG&gt;__host__ __device__ voidthrust::shuffle(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomIterator first, RandomIterator last, URBG &amp;&amp; g);template &lt;typename RandomIterator, typename URBG&gt;__host__ __device__ voidthrust::shuffle(RandomIterator first, RandomIterator last, URBG &amp;&amp; g); thrust::shuffle_copy12345678910111213141516171819template &lt;typename DerivedPolicy, typename RandomIterator, typename OutputIterator, typename URBG&gt;__host__ __device__ voidthrust::shuffle_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomIterator first, RandomIterator last, OutputIterator result, URBG &amp;&amp; g);template &lt;typename RandomIterator, typename OutputIterator, typename URBG&gt;__host__ __device__ voidthrust::shuffle_copy(RandomIterator first, RandomIterator last, OutputIterator result, URBG &amp;&amp; g); Stream CompactionReference Page thrust::copy_if12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename Predicate&gt;__host__ __device__ OutputIteratorthrust::copy_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, Predicate pred);template &lt;typename InputIterator, typename OutputIterator, typename Predicate&gt;OutputIteratorthrust::copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate&gt;__host__ __device__ OutputIteratorthrust::copy_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate&gt;OutputIteratorthrust::copy_if(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred); thrust::remove123456789101112131415template &lt;typename DerivedPolicy, typename ForwardIterator, typename T&gt;__host__ __device__ ForwardIteratorthrust::remove(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const T &amp; value);template &lt;typename ForwardIterator, typename T&gt;ForwardIteratorthrust::remove(ForwardIterator first, ForwardIterator last, const T &amp; value); thrust::remove_copy12345678910111213141516171819template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename T&gt;__host__ __device__ OutputIteratorthrust::remove_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, const T &amp; value);template &lt;typename InputIterator, typename OutputIterator, typename T&gt;OutputIteratorthrust::remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T &amp; value); thrust::remove_if123456789101112131415161718192021222324252627282930313233343536template &lt;typename DerivedPolicy, typename ForwardIterator, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::remove_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, Predicate pred);template &lt;typename ForwardIterator, typename Predicate&gt;ForwardIteratorthrust::remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);template &lt;typename ForwardIterator, typename InputIterator, typename Predicate&gt;ForwardIteratorthrust::remove_if(ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred);template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::remove_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred); thrust::remove_copy_if12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename Predicate&gt;__host__ __device__ OutputIteratorthrust::remove_copy_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, Predicate pred);template &lt;typename InputIterator, typename OutputIterator, typename Predicate&gt;OutputIteratorthrust::remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate&gt;__host__ __device__ OutputIteratorthrust::remove_copy_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate&gt;OutputIteratorthrust::remove_copy_if(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred); thrust::unique123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename ForwardIterator&gt;__host__ __device__ ForwardIteratorthrust::unique(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last);template &lt;typename ForwardIterator&gt;ForwardIteratorthrust::unique(ForwardIterator first, ForwardIterator last);template &lt;typename DerivedPolicy, typename ForwardIterator, typename BinaryPredicate&gt;__host__ __device__ ForwardIteratorthrust::unique(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);template &lt;typename ForwardIterator, typename BinaryPredicate&gt;ForwardIteratorthrust::unique(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred); thrust::unique_copy1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::unique_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result);template &lt;typename InputIterator, typename OutputIterator&gt;OutputIteratorthrust::unique_copy(InputIterator first, InputIterator last, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename BinaryPredicate&gt;__host__ __device__ OutputIteratorthrust::unique_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred);template &lt;typename InputIterator, typename OutputIterator, typename BinaryPredicate&gt;OutputIteratorthrust::unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred); thrust::unique_by_key1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename ForwardIterator1, typename ForwardIterator2&gt;__host__ __device__ thrust::pair&lt; ForwardIterator1, ForwardIterator2 &gt;thrust::unique_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first);template &lt;typename ForwardIterator1, typename ForwardIterator2&gt;thrust::pair&lt; ForwardIterator1, ForwardIterator2 &gt;thrust::unique_by_key(ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first);template &lt;typename DerivedPolicy, typename ForwardIterator1, typename ForwardIterator2, typename BinaryPredicate&gt;__host__ __device__ thrust::pair&lt; ForwardIterator1, ForwardIterator2 &gt;thrust::unique_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first, BinaryPredicate binary_pred);template &lt;typename ForwardIterator1, typename ForwardIterator2, typename BinaryPredicate&gt;thrust::pair&lt; ForwardIterator1, ForwardIterator2 &gt;thrust::unique_by_key(ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first, BinaryPredicate binary_pred); thrust::unique_by_key_copy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::unique_by_key_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::unique_by_key_copy(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename BinaryPredicate&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::unique_by_key_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_result, OutputIterator2 values_result, BinaryPredicate binary_pred);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator1, typename OutputIterator2, typename BinaryPredicate&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::unique_by_key_copy(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_result, OutputIterator2 values_result, BinaryPredicate binary_pred); thrust::unique_count123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename ForwardIterator, typename BinaryPredicate&gt;__host__ __device__ thrust::iterator_traits&lt; ForwardIterator &gt;::difference_typethrust::unique_count(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);template &lt;typename DerivedPolicy, typename ForwardIterator&gt;__host__ __device__ thrust::iterator_traits&lt; ForwardIterator &gt;::difference_typethrust::unique_count(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last);template &lt;typename ForwardIterator, typename BinaryPredicate&gt;__host__ __device__ thrust::iterator_traits&lt; ForwardIterator &gt;::difference_typethrust::unique_count(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred);template &lt;typename ForwardIterator&gt;__host__ __device__ thrust::iterator_traits&lt; ForwardIterator &gt;::difference_typethrust::unique_count(ForwardIterator first, ForwardIterator last); SearchingReference Page thrust::find123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename T&gt;__host__ __device__ InputIteratorthrust::find(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, const T &amp; value);template &lt;typename InputIterator, typename T&gt;InputIteratorthrust::find(InputIterator first, InputIterator last, const T &amp; value); thrust::find_if123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename Predicate&gt;__host__ __device__ InputIteratorthrust::find_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, Predicate pred);template &lt;typename InputIterator, typename Predicate&gt;InputIteratorthrust::find_if(InputIterator first, InputIterator last, Predicate pred); thrust::find_if_not123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename Predicate&gt;__host__ __device__ InputIteratorthrust::find_if_not(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, Predicate pred);template &lt;typename InputIterator, typename Predicate&gt;InputIteratorthrust::find_if_not(InputIterator first, InputIterator last, Predicate pred); thrust::mismatchthrust::mismatch finds the first position where the two ranges [first1, last1) and [first2, first2 + (last1 - first1)) differ. 1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2&gt;__host__ __device__ thrust::pair&lt; InputIterator1, InputIterator2 &gt;thrust::mismatch(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);template &lt;typename InputIterator1, typename InputIterator2&gt;thrust::pair&lt; InputIterator1, InputIterator2 &gt;thrust::mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename BinaryPredicate&gt;__host__ __device__ thrust::pair&lt; InputIterator1, InputIterator2 &gt;thrust::mismatch(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename BinaryPredicate&gt;thrust::pair&lt; InputIterator1, InputIterator2 &gt;thrust::mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred); The following code demonstrates how to use thrust::mismatch. 123456789101112131415161718#include &lt;thrust/mismatch.h&gt;#include &lt;thrust/device_vector.h&gt;#include &lt;thrust/execution_policy.h&gt;thrust::device_vector&lt;int&gt; vec1(4);thrust::device_vector&lt;int&gt; vec2(4);vec1[0] = 0; vec2[0] = 0;vec1[2] = 5; vec2[1] = 5;vec1[3] = 3; vec2[2] = 8;vec1[4] = 7; vec2[3] = 7;typedef thrust::device_vector&lt;int&gt;::iterator Iterator;thrust::pair&lt;Iterator, Iterator&gt; result;result = thrust::mismatch(thrust::device, vec1.begin(), vec1.end(), vec2.begin()); thrust::partition_pointthrust::partition_point returns an iterator pointing to the end of the true partition of a partitioned range. partition_point requires the input range [first, last) to be a partition; that is, all elements which satisfy pred shall appear before those that do not. Preconditions: The range [first, last) shall be partitioned by pred. Returns: An iterator mid such that all_of(first, mid, pred) and none_of(mid, last, pred) are both true. Note: Though similar, thrust::partition_point is not redundant with thrust::find_if_not, thrust::partition_point‘s precondition ([first, last) shall be partitioned by pred) provides an opportunity for a faster implementation. 123456789101112131415template &lt;typename DerivedPolicy, typename ForwardIterator, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::partition_point(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, Predicate pred);template &lt;typename ForwardIterator, typename Predicate&gt;ForwardIteratorthrust::partition_point(ForwardIterator first, ForwardIterator last, Predicate pred); The following code demonstrates how to use thrust::partition_point: 1234567891011121314#include &lt;thrust/partition.h&gt;#include &lt;thrust/execution_policy.h&gt;struct is_even { __host__ __device__ bool operator()(const int &amp;x) { return (x % 2) == 0; }};int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};int *B = thrust::partition_point(thrust::host, A, A + 10, is_even());// B - A = 5// [A, B) contains only even values. Binary SearchReference Page thrust::lower_bound1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename ForwardIterator, typename LessThanComparable&gt;__host__ __device__ ForwardIteratorthrust::lower_bound(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const LessThanComparable &amp; value);template &lt;class ForwardIterator, class LessThanComparable&gt;ForwardIteratorthrust::lower_bound(ForwardIterator first, ForwardIterator last, const LessThanComparable &amp; value);template &lt;typename DerivedPolicy, typename ForwardIterator, typename T, typename StrictWeakOrdering&gt;__host__ __device__ ForwardIteratorthrust::lower_bound(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const T &amp; value, StrictWeakOrdering comp);template &lt;class ForwardIterator, class T, class StrictWeakOrdering&gt;ForwardIteratorthrust::lower_bound(ForwardIterator first, ForwardIterator last, const T &amp; value, StrictWeakOrdering comp); thrust::upper_bound1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename ForwardIterator, typename LessThanComparable&gt;__host__ __device__ ForwardIteratorthrust::upper_bound(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const LessThanComparable &amp; value);template &lt;class ForwardIterator, class LessThanComparable&gt;ForwardIteratorthrust::upper_bound(ForwardIterator first, ForwardIterator last, const LessThanComparable &amp; value);template &lt;typename DerivedPolicy, typename ForwardIterator, typename T, typename StrictWeakOrdering&gt;__host__ __device__ ForwardIteratorthrust::upper_bound(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const T &amp; value, StrictWeakOrdering comp);template &lt;class ForwardIterator, class T, class StrictWeakOrdering&gt;ForwardIteratorthrust::upper_bound(ForwardIterator first, ForwardIterator last, const T &amp; value, StrictWeakOrdering comp); thrust::binary_search1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename ForwardIterator, typename LessThanComparable&gt;__host__ __device__ boolthrust::binary_search(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const LessThanComparable &amp; value);template &lt;class ForwardIterator, class LessThanComparable&gt;boolthrust::binary_search(ForwardIterator first, ForwardIterator last, const LessThanComparable &amp; value);template &lt;typename DerivedPolicy, typename ForwardIterator, typename T, typename StrictWeakOrdering&gt;__host__ __device__ boolthrust::binary_search(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const T &amp; value, StrictWeakOrdering comp);template &lt;class ForwardIterator, class T, class StrictWeakOrdering&gt;boolthrust::binary_search(ForwardIterator first, ForwardIterator last, const T &amp; value, StrictWeakOrdering comp); thrust::equal_range1234567891011121314151617181920212223242526272829303132333435template &lt;typename DerivedPolicy, typename ForwardIterator, typename LessThanComparable&gt;__host__ __device__ thrust::pair&lt; ForwardIterator, ForwardIterator &gt;thrust::equal_range(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const LessThanComparable &amp; value);template &lt;class ForwardIterator, class LessThanComparable&gt;thrust::pair&lt; ForwardIterator, ForwardIterator &gt;thrust::equal_range(ForwardIterator first, ForwardIterator last, const LessThanComparable &amp; value);template &lt;typename DerivedPolicy, typename ForwardIterator, typename T, typename StrictWeakOrdering&gt;__host__ __device__ thrust::pair&lt; ForwardIterator, ForwardIterator &gt;thrust::equal_range(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const T &amp; value, StrictWeakOrdering comp);template &lt;class ForwardIterator, class T, class StrictWeakOrdering&gt;thrust::pair&lt; ForwardIterator, ForwardIterator &gt;thrust::equal_range(ForwardIterator first, ForwardIterator last, const T &amp; value, StrictWeakOrdering comp); Binary Search (Vectorized Searches)Reference Page thrust::lower_bound1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::lower_bound(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result);template &lt;class ForwardIterator, class InputIterator, class OutputIterator&gt;OutputIteratorthrust::lower_bound(ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result);template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename OutputIterator, typename StrictWeakOrdering&gt;__host__ __device__ OutputIteratorthrust::lower_bound(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result, StrictWeakOrdering comp);template &lt;class ForwardIterator, class InputIterator, class OutputIterator, class StrictWeakOrdering&gt;OutputIteratorthrust::lower_bound(ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result, StrictWeakOrdering comp); thrust::upper_bound1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::upper_bound(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result);template &lt;class ForwardIterator, class InputIterator, class OutputIterator&gt;OutputIteratorthrust::upper_bound(ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result);template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename OutputIterator, typename StrictWeakOrdering&gt;__host__ __device__ OutputIteratorthrust::upper_bound(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result, StrictWeakOrdering comp);template &lt;class ForwardIterator, class InputIterator, class OutputIterator, class StrictWeakOrdering&gt;OutputIteratorthrust::upper_bound(ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result, StrictWeakOrdering comp); thrust::binary_search1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::binary_search(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result);template &lt;class ForwardIterator, class InputIterator, class OutputIterator&gt;OutputIteratorthrust::binary_search(ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result);template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename OutputIterator, typename StrictWeakOrdering&gt;__host__ __device__ OutputIteratorthrust::binary_search(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result, StrictWeakOrdering comp);template &lt;class ForwardIterator, class InputIterator, class OutputIterator, class StrictWeakOrdering&gt;OutputIteratorthrust::binary_search(ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator result, StrictWeakOrdering comp); Set OperationsReference Page thrust::set_difference1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::set_difference(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;OutputIteratorthrust::set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;__host__ __device__ OutputIteratorthrust::set_difference(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;OutputIteratorthrust::set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp); thrust::set_intersection1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::set_intersection(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;OutputIteratorthrust::set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;__host__ __device__ OutputIteratorthrust::set_intersection(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;OutputIteratorthrust::set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp); thrust::set_symmetric_difference1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::set_symmetric_difference(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;OutputIteratorthrust::set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;__host__ __device__ OutputIteratorthrust::set_symmetric_difference(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;OutputIteratorthrust::set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp); thrust::set_union1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;__host__ __device__ OutputIteratorthrust::set_union(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;OutputIteratorthrust::set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;__host__ __device__ OutputIteratorthrust::set_union(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename StrictWeakCompare&gt;OutputIteratorthrust::set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp); thrust::set_difference_by_key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_difference_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_difference_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_difference_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_difference_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp); thrust::set_intersection_by_key123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename OutputIterator1, typename OutputIterator2&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_intersection_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename OutputIterator1, typename OutputIterator2&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_intersection_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_intersection_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_intersection_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp); thrust::set_symmetric_difference_by_key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_symmetric_difference_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_symmetric_difference_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_symmetric_difference_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_symmetric_difference_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp); thrust::set_union_by_key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_union_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_union_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;__host__ __device__ thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_union_by_key(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename InputIterator4, typename OutputIterator1, typename OutputIterator2, typename StrictWeakCompare&gt;thrust::pair&lt; OutputIterator1, OutputIterator2 &gt;thrust::set_union_by_key(InputIterator1 keys_first1, InputIterator1 keys_last1, InputIterator2 keys_first2, InputIterator2 keys_last2, InputIterator3 values_first1, InputIterator4 values_first2, OutputIterator1 keys_result, OutputIterator2 values_result, StrictWeakCompare comp); SortingReference Page thrust::sort123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename RandomAccessIterator&gt;__host__ __device__ voidthrust::sort(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomAccessIterator first, RandomAccessIterator last);template &lt;typename RandomAccessIterator&gt;voidthrust::sort(RandomAccessIterator first, RandomAccessIterator last);template &lt;typename DerivedPolicy, typename RandomAccessIterator, typename StrictWeakOrdering&gt;__host__ __device__ voidthrust::sort(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp);template &lt;typename RandomAccessIterator, typename StrictWeakOrdering&gt;__host__ __device__ voidthrust::sort(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp); thrust::stable_sort123456789101112131415161718192021222324252627template &lt;typename DerivedPolicy, typename RandomAccessIterator&gt;__host__ __device__ voidthrust::stable_sort(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomAccessIterator first, RandomAccessIterator last);template &lt;typename RandomAccessIterator&gt;voidthrust::stable_sort(RandomAccessIterator first, RandomAccessIterator last);template &lt;typename DerivedPolicy, typename RandomAccessIterator, typename StrictWeakOrdering&gt;__host__ __device__ voidthrust::stable_sort(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp);template &lt;typename RandomAccessIterator, typename StrictWeakOrdering&gt;voidthrust::stable_sort(RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp); thrust::sort_by_keythrust::sort_by_key performs a key-value sort. That is, sort_by_key sorts the elements in [keys_first, keys_last) and [values_first, values_first + (keys_last - keys_first)) into ascending key order, meaning that if i and j are any two valid iterators in [keys_first, keys_last) such that i precedes j, and p and q are iterators in [values_first, values_first + (keys_last - keys_first)) corresponding to i and j respectively, then *j is not less than *i.Note: thrust::sort_by_key is not guaranteed to be stable. That is, suppose that *i and *j are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two keys or the relative order of their corresponding values will be preserved by thrust::sort_by_key. 123456789101112131415161718192021222324252627282930313233343536373839template &lt;typename DerivedPolicy, typename RandomAccessIterator1, typename RandomAccessIterator2&gt;__host__ __device__void thrust::sort_by_key( const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first);// This version of `sort_by_key` compares key objects using `operator&lt;`.template &lt;typename RandomAccessIterator1, typename RandomAccessIterator2&gt;void thrust::sort_by_key( RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first);// This version of `sort_by_key` compares key objects using `operator&lt;`.template &lt;typename DerivedPolicy, typename RandomAccessIterator1, typename RandomAccessIterator2, typename StrictWeakOrdering&gt;__host__ __device__void thrust::sort_by_key( const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp);template &lt;typename RandomAccessIterator1, typename RandomAccessIterator2, typename StrictWeakOrdering&gt;void thrust::sort_by_key( RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp); The following code demonstrates how to use thrust::sort_by_key to sort an array of character values using integers as sorting keys using the thrust::host execution policy for parallelization: 123456789#include &lt;thrust/sort.h&gt;#include &lt;thrust/execution_policy.h&gt;const int N = 6;int keys[N] = {1, 4, 2, 8, 5, 7};char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};thrust::sort_by_key(thrust::host, keys, keys + N, values);// keys is now {1, 2, 4, 5, 7, 8// values is now {'a', 'c', 'b', 'e', 'f', 'd'} thrust::stable_sort_by_key12345678910111213141516171819202122232425262728293031323334353637template &lt;typename DerivedPolicy, typename RandomAccessIterator1, typename RandomAccessIterator2&gt;__host__ __device__ voidthrust::stable_sort_by_key( const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first);template &lt;typename RandomAccessIterator1, typename RandomAccessIterator2&gt;voidthrust::stable_sort_by_key(RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first);template &lt;typename DerivedPolicy, typename RandomAccessIterator1, typename RandomAccessIterator2, typename StrictWeakOrdering&gt;__host__ __device__ voidthrust::stable_sort_by_key( const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp);template &lt;typename RandomAccessIterator1, typename RandomAccessIterator2, typename StrictWeakOrdering&gt;voidthrust::stable_sort_by_key(RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp); TransformationsReference Page FillingReference Page thrust::fill123456789101112131415template &lt;typename DerivedPolicy, typename ForwardIterator, typename T&gt;__host__ __device__ voidthrust::fill(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const T &amp; value);template &lt;typename ForwardIterator, typename T&gt;__host__ __device__ voidthrust::fill(ForwardIterator first, ForwardIterator last, const T &amp; value); thrust::fill_n1234567891011121314151617template &lt;typename DerivedPolicy, typename OutputIterator, typename Size, typename T&gt;__host__ __device__ OutputIteratorthrust::fill_n(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, OutputIterator first, Size n, const T &amp; value);template &lt;typename OutputIterator, typename Size, typename T&gt;__host__ __device__ OutputIteratorthrust::fill_n(OutputIterator first, Size n, const T &amp; value); thrust::uninitialized_fill123456789101112131415template &lt;typename DerivedPolicy, typename ForwardIterator, typename T&gt;__host__ __device__ voidthrust::uninitialized_fill(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const T &amp; x);template &lt;typename ForwardIterator, typename T&gt;voidthrust::uninitialized_fill(ForwardIterator first, ForwardIterator last, const T &amp; x); thrust::uninitialized_fill_n1234567891011121314151617template &lt;typename DerivedPolicy, typename ForwardIterator, typename Size, typename T&gt;__host__ __device__ ForwardIteratorthrust::uninitialized_fill_n(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, Size n, const T &amp; x);template &lt;typename ForwardIterator, typename Size, typename T&gt;ForwardIteratorthrust::uninitialized_fill_n(ForwardIterator first, Size n, const T &amp; x); ModifyingReference Page thrust::for_each123456789101112131415template &lt;typename DerivedPolicy, typename InputIterator, typename UnaryFunction&gt;__host__ __device__ InputIteratorthrust::for_each(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, UnaryFunction f);template &lt;typename InputIterator, typename UnaryFunction&gt;InputIteratorthrust::for_each(InputIterator first, InputIterator last, UnaryFunction f); thrust::for_each_n1234567891011121314151617template &lt;typename DerivedPolicy, typename InputIterator, typename Size, typename UnaryFunction&gt;__host__ __device__ InputIteratorthrust::for_each_n(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, Size n, UnaryFunction f);template &lt;typename InputIterator, typename Size, typename UnaryFunction&gt;InputIteratorthrust::for_each_n(InputIterator first, Size n, UnaryFunction f); ReplacingReference Page thrust::replace1234567891011121314151617template &lt;typename DerivedPolicy, typename ForwardIterator, typename T&gt;__host__ __device__ voidthrust::replace(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, const T &amp; old_value, const T &amp; new_value);template &lt;typename ForwardIterator, typename T&gt;voidthrust::replace(ForwardIterator first, ForwardIterator last, const T &amp; old_value, const T &amp; new_value); thrust::replace_if12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;typename DerivedPolicy, typename ForwardIterator, typename Predicate, typename T&gt;__host__ __device__ voidthrust::replace_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp; new_value);template &lt;typename ForwardIterator, typename Predicate, typename T&gt;voidthrust::replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp; new_value);template &lt;typename DerivedPolicy, typename ForwardIterator, typename InputIterator, typename Predicate, typename T&gt;__host__ __device__ voidthrust::replace_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred, const T &amp; new_value);template &lt;typename ForwardIterator, typename InputIterator, typename Predicate, typename T&gt;voidthrust::replace_if(ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred, const T &amp; new_value); thrust::replace_copy123456789101112131415161718192021template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename T&gt;__host__ __device__ OutputIteratorthrust::replace_copy(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, const T &amp; old_value, const T &amp; new_value);template &lt;typename InputIterator, typename OutputIterator, typename T&gt;OutputIteratorthrust::replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T &amp; old_value, const T &amp; new_value); thrust::replace_copy_if123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename Predicate, typename T&gt;__host__ __device__ OutputIteratorthrust::replace_copy_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T &amp; new_value);template &lt;typename InputIterator, typename OutputIterator, typename Predicate, typename T&gt;OutputIteratorthrust::replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T &amp; new_value);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T&gt;__host__ __device__ OutputIteratorthrust::replace_copy_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred, const T &amp; new_value);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T&gt;OutputIteratorthrust::replace_copy_if(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred, const T &amp; new_value); transformationsReference Page thrust::adjacent_differencethrust::adjacent_difference calculates the differences of adjacent elements in the range [first, last). That is, *first is assigned to *result, and, for each iterator i in the range [first + 1, last), the difference of *i and *(i - 1) is assigned to *(result + (i - first)).The algorithm’s execution is parallelized as determined by exec. 12345678910111213141516171819202122232425262728293031323334353637383940template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator&gt;__host__ __device__OutputIterator thrust::adjacent_difference( const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result);// This version of `adjacent_difference` uses// `operator-` to calculate differences.template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename BinaryFunction&gt;__host__ __device__ OutputIteratorthrust::adjacent_difference(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, BinaryFunction binary_op);// This version of `adjacent_difference` uses the binary// function `binary_op` to calculate differences.template &lt;typename InputIterator, typename OutputIterator&gt;OutputIteratorthrust::adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);template &lt;typename InputIterator, typename OutputIterator, typename BinaryFunction&gt;OutputIteratorthrust::adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryFunction binary_op); The following code demonstrates how to use thrust::adjacent_difference to compute the difference between adjacent elements of a range using the thrust::device execution policy: 123456789101112131415#include &lt;thrust/adjacent_difference.h&gt;#include &lt;thrust/device_vector.h&gt;#include &lt;thrust/execution_policy.h&gt;// ...int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};thrust::device_vector&lt;int&gt; d_data(h_data, h_data + 8);thrust::device_vector&lt;int&gt; d_result(8);thrust::adjacent_difference(thrust::device, d_data.begin(), d_data.end(), d_result.begin());// d_result is now [1, 1, -1, 1, -1, 1, -1, 1] The following code demonstrates how thrust::generatethrust::generate assigns the result of invoking gen, a function object that takes no arguments, to each element in the range [first, last). The algorithm’s execution is parallelized as determined by exec. 1234567891011121314151617181920template &lt;typename DerivedPolicy, typename ForwardIterator, typename Generator&gt;__host__ __device__ voidthrust::generate(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, Generator gen);// exec --- The execution policy to use for parallelization.// first --- The first element in the range of interest.// last --- The last element in the range of interest.// gen --- A function argument, taking no parameters, used to generate// values to assign to elements in the range [first, last).template &lt;typename ForwardIterator, typename Generator&gt;voidthrust::generate(ForwardIterator first, ForwardIterator last, Generator gen); Template Parameters: DerivedPolicy The name of the derived execution policy.ForwardIterator is a model of Forward Iterator, and ForwardIterator is mutable.Generator is a model of Generator, and Generator‘s result_type is convertible to ForwardIterator‘s value_type. The following code shows how to fill a thrust::host_vector with random numbers, using the standard C library function rand using the thrust::host execution policy for parallelization: 123456789#include &lt;thrust/generate.h&gt;#include &lt;thrust/host_vector.h&gt;#include &lt;thrust/execution_policy.h&gt;#include &lt;cstdlib&gt;thrust::host_vector&lt;int&gt; v(10);srand(13);thrust::generate(thrust::host, v.begin(), v.end(), srand);// the elements of v are now pseudo-random numbers. thrust::generate_n1234567891011121314151617template &lt;typename DerivedPolicy, typename OutputIterator, typename Size, typename Generator&gt;__host__ __device__ OutputIteratorthrust::generate_n(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, OutputIterator first, Size n, Generator gen);template &lt;typename OutputIterator, typename Size, typename Generator&gt;OutputIteratorthrust::generate_n(OutputIterator first, Size n, Generator gen); thrust::sequencesequence fills the range [first, last) with a sequence of numbers. For each iterator i in the range [first, last), this version sequence performs the assignment *i = (i - first). The algorithm’s execution is parallelized as determined by exec. 123456789101112131415161718192021222324252627282930313233343536373839404142434445template &lt;typename DerivedPolicy, typename ForwardIterator&gt;__host__ __device__ voidthrust::sequence(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last);template &lt;typename ForwardIterator&gt;voidthrust::sequence(ForwardIterator first, ForwardIterator last);template &lt;typename DerivedPolicy, typename ForwardIterator, typename T&gt;__host__ __device__ voidthrust::sequence(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, T init);template &lt;typename ForwardIterator, typename T&gt;voidthrust::sequence(ForwardIterator first, ForwardIterator last, T init);template &lt;typename DerivedPolicy, typename ForwardIterator, typename T&gt;__host__ __device__ voidthrust::sequence(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, T init, T step);template &lt;typename ForwardIterator, typename T&gt;voidthrust::sequence(ForwardIterator first, ForwardIterator last, T init, T step); The following code snippet demonstrates how to use sequence to fill a range with a sequence of numbers using the thrust::host execution policy for parallelization: 1234567#include &lt;thrust/sequence.h&gt;#include &lt;thrust/execution_policy.h&gt;const int N = 10;int A[N];thrust::sequence(thrust::host, A, A + 10);// A is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} Note: Unlike the similar C++ STL function std::iota, sequence offers no guarantee on order of execution. Template Parameters: DerivedPolicy The name of the derived execution policy. ForwardIterator is a model of Forward Iterator, and ForwardIterator is mutable, and if x and y are objects of ForwardIterator‘s value_type, then x + y is defined, and if T is ForwardIterator‘s value_type, then T(0) is defined. thrust::tabulatetabulate fills the range [first, last) iwth the value of a function applied to each element’s index. 123456789101112131415template &lt;typename DerivedPolicy, typename ForwardIterator, typename UnaryOperation&gt;__host__ __device__ voidthrust::tabulate(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, ForwardIterator first, ForwardIterator last, UnaryOperation unary_op);template &lt;typename ForwardIterator, typename UnaryOperation&gt;voidthrust::tabulate(ForwardIterator first, ForwardIterator last, UnaryOperation unary_op); For each iterator i in the range [first, last), tabulate performs the assignment *i = unary_op(i - first). The algorithm’s execution is parallelized as determined by exec. The following code demonstrates how to use tabulate to generate the first n non-positive integers using the thrust::host execution policy for parallelization: 1234567#include &lt;thrust/tabulate.h&gt;#include &lt;thrust/functional.h&gt;const int N = 10;int A[N];thrust::tabulate(thrust::host, A, A + 10, thrust::negate&lt;int&gt;());// A is now {0, -1, -2, -3, -4, -5, -6, -7, -8, -9} thrust::transformtransform applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence. Specifically, for each iterator i in the range [first, last) the operation op(*i) is performed and the result is assigned to *o, where o is the corresponding output iterator in the range [result, result + (last - first)). The input and output sequences may coincide, resulting in an in-place transformation. 12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;typename DerivedPolicy, typename InputIterator, typename OutputIterator, typename UnaryFunction&gt;__host__ __device__ OutputIteratorthrust::transform(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op);template &lt;typename InputIterator, typename OutputIterator, typename UnaryFunction&gt;OutputIteratorthrust::transform(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryFunction&gt;__host__ __device__ OutputIteratorthrust::transform(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op);template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryFunction&gt;OutputIteratorthrust::transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op); The following code snippet demostrates how to use transform to negate a range in-place using the thrust::host execution policy for parallelization: 12345678910#include &lt;thrust/transform.h&gt;#include &lt;thrust/functional.h&gt;#include &lt;thrust/execution_policy.h&gt;int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};thrust::negate&lt;int&gt; op;// in-place transformation.thrust::transform(thrust::host, data, data + 10, data, op);// data is now {5, 0, -2, 3, -2, -4, 0, 1, -2, -8}; thrust::transform_if1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283template &lt;typename DerivedPolicy, typename InputIterator, typename ForwardIterator, typename UnaryFunction, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::transform_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator first, InputIterator last, ForwardIterator result, UnaryFunction op, Predicate pred);template &lt;typename InputIterator, typename ForwardIterator, typename UnaryFunction, typename Predicate&gt;ForwardIteratorthrust::transform_if(InputIterator first, InputIterator last, ForwardIterator result, UnaryFunction op, Predicate pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename ForwardIterator, typename UnaryFunction, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::transform_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction op, Predicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename ForwardIterator, typename UnaryFunction, typename Predicate&gt;ForwardIteratorthrust::transform_if(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction op, Predicate pred);template &lt;typename DerivedPolicy, typename InputIterator1, typename InputIterator2, typename InputIterator3, typename ForwardIterator, typename BinaryFunction, typename Predicate&gt;__host__ __device__ ForwardIteratorthrust::transform_if(const thrust::detail::execution_policy_base&lt; DerivedPolicy &gt; &amp; exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred);template &lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename ForwardIterator, typename BinaryFunction, typename Predicate&gt;ForwardIteratorthrust::transform_if(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred); thrust::transform_ifDefinitionThis version of transform_if conditionally applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence if the corresponding position in the input sequence satisfies a predicate. Otherwise, the corresponding position in the output sequence is not modified. The definition is as follows: 123456789101112template &lt;typename DerivedPolicy, typename InputIterator, typename ForwardIterator, typename UnaryFunction, typename Predicate&gt;__host__ __device__ ForwardIteratortransform_if(const thrust::detail::execution_policy_base&lt;DerivedPolicy&gt; &amp;exec, InputIterator first, InputIterator last, ForwardIterator result, UnaryFunction op, Predicate pred); Specifically, for each iterator i in the range [first, last) the predicate pred(*i) is evaluated. If this predicate evaluates to true, the result of op(*i) is assigned to *o, where o is the corresponding output iterator in the range [result, result + (last - first) ). Otherwise, op(*i) is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation. Examples12345678910111213141516template &lt;typename Vector&gt;transform_if_test1() { typedef typename Vector::value_type T; Vector input(3); Vector output(3); Vector result(3); input[0] = 1; input[1] = -2; input[2] = 3; result[0] = -1; result[1] = 2; result[2] = -3; auto iter = thrust::transform(input.begin(), input.end(), output.begin(), thrust::negate&lt;T&gt;()); // EXPECT_EQ(std::size_t(iter - output.begin()), input.size()); // EXPECT_EQ(output, result);} IteratorsTODO Policies1const detail::host_t thrust::host thrust::host is the default parallel execution policy associated with Thrust’s host backend system configured by the THRUST_HOST_SYSTEM macro.Instead of relying on implicit algorithm dispatch through iterator system tags, users may directly target algorithm dispatch at Thrust’s host system by providing thrust::host as an algorithm parameter.Explicit dispatch can be useful in avoiding the introduction of data copies into containers such as thrust::host_vector. 12345678910111213141516#include &lt;thrust/for_each.h&gt;#include &lt;thrust/execution_policy.h&gt;#include &lt;cstdio&gt;struct printf_functor { __host__ __device__ void operator()(int x) { printf(&quot;%d\\n&quot;, x); }};// ...int vec(3);vec[0] = 0; vec[1] = 1; vec[2] = 2;thrust::for_each(thrust::host, vec.begin(), vec.end(), printf_functor());// 0 1 2 is printed to standard output in some unspecified order. thrust::devicethrust::device is the default parallel execution policy associated with Thrust’s device backend system configured by the THRUST_DEVICE_SYSTEM macro.Instead of relying on implicit algorithm dispatch through iterator system tags, users may directly target algorithm dispatch at Thrust’s device system by providing thrust::device as an algorithm parameter.Explicit dispatch can be useful in avoiding the introduction of data copies into containers such as thrust::device_vector or to avoid wrapping e.g. raw pointers allocated by the CUDA API with types such as thrust::device_ptr. Function ObjectsFunction Object AdaptorsThere are several functions defined in thrust/functional.h header file. thrust::plusthrust::plus is a function object. Specifically, it is an Adaptable Binary Function. 12345678template &lt;typename T = void&gt;struct plus { // ... __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs + rhs; }}; thrust::minusthrust::minus is a function object. Specifically, it is an Adaptable Binary Function. 12345678template &lt;typename T = void&gt;struct minus { // ... __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs - rhs; }}; thrust::multipliesTODO 12345678template &lt;typename T = void&gt;struct multiplies { // ... __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs * rhs; }}; thrust::dividesTODO 12345678template &lt;typename T = void&gt;struct divides { // ... __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs / rhs; }}; thrust::modulusTODO 12345678template &lt;typename T = void&gt;struct modulus { // ... __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs % rhs; }}; thrust::negateTODO 123456template &lt;typename T = void&gt;struct negate { // ... __host__ __device__ constexpr T operator()(const T &amp;x) const { return -x; }}; thrust::squareTODO 123456template &lt;typename T = void&gt;struct square { // ... __host__ __device__ constexpr T operator()(const T &amp;x) const { return x * x; }}; thrust::equal_toTODO 1234567template &lt;typename T = void&gt;struct equal_to { __host__ __device__ constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs == rhs; }}; thrust::not_equal_toTODO 1234567template &lt;typename T = void&gt;struct not_equal_to { __host__ __device__ constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh != rhs; }}; thrust::greaterTODO 1234567template &lt;typename T = void&gt;struct greater { __host__ __device__ constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh &gt; rhs; }}; thrust::lessTODO 1234567template &lt;typename T = void&gt;struct less { __host__ __device__ constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh &lt; rhs; }}; thrust::greater_equalTODO 1234567template &lt;typename T = void&gt;struct greater_equal { __host__ __device__ constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh &gt;= rhs; }}; thrust::less_equalTODO 1234567template &lt;typename T = void&gt;struct less_equal { __host__ __device__ constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh &lt;= rhs; }}; thrust::logical_andTODO 1234567template &lt;typename T = void&gt;struct logical_and { __host__ __device__ constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh &amp;&amp; rhs; }}; thrust::logical_orTODO 1234567template &lt;typename T = void&gt;struct logical_or { __host__ __device__ constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh || rhs; }}; thrust::logical_notTODO 12345template &lt;typename T = void&gt;struct logical_not { __host__ __device__ constexpr T operator()(const T &amp;x) const { return !x; }}; thrust::bit_andTODO 1234567template &lt;typename T = void&gt;struct bit_and { __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh &amp; rhs; }}; thrust::bit_orTODO 1234567template &lt;typename T = void&gt;struct bit_or { __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh | rhs; }}; thrust::bit_xorTODO 1234567template &lt;typename T = void&gt;struct bit_xor { __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lsh ^ rhs; }}; thrust::identityTODO 12345template &lt;typename T = void&gt;struct identity { __host__ __device__ constexpr const T operator()(const T &amp;x) const { return x; }}; thrust::maximumTODO 1234567template &lt;typename T = void&gt;struct maximum { __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs &lt; rhs ? rhs : lhs; }}; thrust::minimumTODO 1234567template &lt;typename T = void&gt;struct minimum { __host__ __device__ constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs &lt; rhs ? lhs : rhs; }}; thrust::project1stTODO 1234567template &lt;typename T1 = void, typename T2 = void&gt;struct project1st { __host__ __device__ constexpr T1 &amp;operator()(const T1 &amp;lhs, const T2 &amp;/*rhs*/) const { return lhs; }}; thrust::project2ndTODO 1234567template &lt;typename T1 = void, typename T2 = void&gt;struct project2nd { __host__ __device__ constexpr T2 &amp;operator()(const T1 &amp;/*lhs*/, const T2 &amp;rhs) const { return rhs; }}; thrust::unary_negateTODO 12345678910111213template &lt;typename Predicate&gt;struct unary_negate : public thrust:unary_function&lt;typename Predicate::argument_type, bool&gt; { __host__ __device__ explicit unary_negate(Predicate p) : pred(p) {} __host__ __device__ bool operator()(const typename Predicate::argument_type &amp;x) { return !pred(x); } Predicate pred;}; thrust::not1TODO 123template &lt;typename Predicate&gt;__host__ __device__unary_nagate&lt;Predicate&gt; not1(const Predciate &amp;pred); thrust::binary_negateTODO 1234567891011121314template &lt;typename Predicate&gt;struct binary_negate : public thrust::binary_function&lt;typename Predicate::first_argument_type, typename Predicate::second_argument_type, bool&gt; { __host__ __device__ explicit binary_negate(Predicate p) : pred(p) {} __host__ __device__ bool operator()(const typename Predicate::first_argument_type &amp;x, const typename Predicate::second_argument_type &amp;y) { return !pred(x, y); }}; thrust::not2TODO 123template &lt;typename BinaryPredicate&gt;__host__ __device__binary_negate&lt;BinaryPredicate&gt; not2(const BinaryPredicate &amp;pred); placeholdersObjects in the thrust::placeholders namespace may be used to create simple arithmetic functions inline in an algorithm invocation. Combining placeholders such as _1 and _2 with arithmetic operations such as + creates an unnamed function object which applies the operation to their arguments. The type of placeholder object is implementation-defined. TODOThe following code shows how to use placeholder. 1234567891011121314151617181920212223242526272829#include &lt;thrust/device_vector.h&gt;#include &lt;thrust/transform.h&gt;#include &lt;thrust/functional.h&gt;int main() { thrust::device_vector&lt;float&gt; x(4), y(4); x[0] = 1; x[1] = 2; x[2] = 3; x[3] = 4; x[0] = 1; x[1] = 1; x[2] = 1; x[3] = 1; float a = 2.0f; using namespace thrust::placeholders; // The SAXPY computation. thrust::transform(x.begin(), x.end(), y.begin(), y.begin(), a * _1 + _2); for (auto val : y) std::cout &lt;&lt; val &lt;&lt; ' '; std::cout &lt;&lt; std::endl; return 0;} Containersthrust::pairthrust::pair is a generic data structure encapsulating a heterogeneous pair of values. The definition is as follows. 12345678910111213141516171819202122232425262728template &lt;typename T1, typename T2&gt;struct pair { typedef T1 first_type; typedef T2 second_type; first_type first; second_type second; __host__ __device__ pair(void); // constructor inline __host__ __device__ pair(const T1 &amp;x, const T2 &amp;y); // copy constructor. template &lt;typename U1, typename U2&gt; inline __host__ __device__ pair(const pair&lt;U1, U2&gt; &amp;p); // copy constructor. Copies from a std::pair template &lt;typename U1, typename U2&gt; inline __host__ __device__ pair(const std::pair&lt;U1, U2&gt; &amp;p); // swap two elements inline __host__ __device__ void swap(pair &amp;p);}; References Thrust Introduction","link":"/2022/12/06/Thrust-Archiecture-Overview/"},{"title":"C++ Interview Questions","text":"What is actual use of friend function and classes in C++?If you declare a function is a friend of a class, then this function can visit private members in this class.For example, it is a good idea of the &lt;&lt; and &gt;&gt; operator overloading and adding as a friend of those classes. 1234567891011121314151617181920212223242526#include &lt;iostream&gt;class Base { int x; public: Base() {} Base(int x) : x{x} {} friend void func(Base &amp;obj);};void fun(Base &amp;obj) { std::cout &lt;&lt; obj.x &lt;&lt; std::endl; obj.x = 20; std::cout &lt;&lt; obj.x &lt;&lt; std::endl;}int main(){ Base b{10}; fun(b); return 0;} The friend specifier allows the designated class access to protected data or functionality within the class making the friend statement. For example, in the below code anyone may ask a child for their name, but only the mother and the child may change the name.You can take this simple example further by considering a more complex class such as a window. Quite likely a window will have many function/data elements that should not be publicly accessible, but are needed by a related class such as a WindowManger. 12345678910class Child { // Mother class members can access the private parts of class Child. friend class Mother; public: string name(void); protected: void setName(string newName);}; At work we use friends for testing code, extensively. It means we can provide proper encapsulation and information hiding for the main application code. But also we can have separate test code that uses friends to inspect internal state and data for testing. Friend Definition Friend definition allows to define a function in class-scope, but the function will not be defined as a member function, but as a free function of the enclosing namespace, and won’t be visible normally except for argument dependent lookup. That makes it especially useful for operator overloading: 12345678910111213141516171819202122232425namespace utils {class f {private: using int_type = int; int_type value; public: // let's assume it doesn't only need .value, but some internal stuff. friend f operator+(f cosnt &amp;a, f const &amp;b) { // name resolution finds names in class-scope. // int_type is visible here. return f(a.value + b.value); } int getValue() cosnt { return value; }};}int main() { utils::f a, b; std::cout &lt;&lt; (a + b).getValue(); // valid; return 0;} Private CRTP Base Class Sometimes, you find the need that a policy needs access to the derived class: 1234567891011121314151617181920212223242526// Possible policy used for flexible-classtemplate &lt;typename Derived&gt;struct Policy { void doSomething() { // casting this to Derived* requires us to see that we are a // base-class of Derived. some_type cosnt &amp;t = static_cast&lt;Derived *&gt;(this)-&gt;getSomething(); }};// not, derived privatelytemplate &lt;typename &lt;typename&gt; class SomePolicy&gt;struct FlexibleClass : private SomePolicy&lt;FlexibleClass&gt; { // We derive privately, so the base-class wouldn't notice that, // (even though it's the base itself!), so we need a friend declaration // to make the base a friend of us. friend class SomePolicy&lt;FlexibleClass&gt;; void doStuff() { // calls doSomething of the policy. this-&gt;doSomething(); } // will return useful information some_type getSomething();}; You will find a non-contrived example for that in this example. Another code","link":"/2023/05/13/C-Interview-Questions/"},{"title":"Curiously Recurring Template Pattern --- CRTP","text":"Curiously Recurring Template Pattern (CRTP)The Curiously Recurring Template Pattern is an idiom in which a class X derives from a class template Y, taking a template parameter Z, where Y is initialized with Z = X. For example, 1234template &lt;typename Z&gt;class Y {};class X : public Y&lt;X&gt; {}; Intent: To achieve static polymorphism Implementation: Make use of base class template specialization. Also known as: Upside-down inheritance, static-polymorphism. CRTP may be used to implement “compile-time polymorphism”, when a base class exposes an interface, and derived classes implement such interface. 123456789101112131415#include &lt;iostream&gt;template &lt;typename Derived&gt;struct Base { void name() { (static_cast&lt;Derived *&gt;(this))-&gt;impl(); }};struct D1 : public Base&lt;D1&gt; { void impl() { std::cout &lt;&lt; &quot;D1::impl()\\n&quot;; }};struct D2 : public Base&lt;D2&gt; { void impl() { std::cout &lt;&lt; &quot;D2::impl()\\n&quot;; }};void test(){ // Base&lt;D1&gt; b1; b1.name(); // undefined behavior // Base&lt;D2&gt; b2; b2.name(); // undefined behavior D1().name(); D2().name();} Some use cases for this pattern are a static polymorphism and other meta-programming techniques. Static polymorphismTypically, the base class template will take advantage of the fact that member function bodies (definitions) are not instantiated until long after their declarations, and will use members of the derived class within its own member functions, via the use of a cast. For example: 123456789101112131415161718192021template &lt;typename T&gt;struct Base { void interface() { // ... static_cast&lt;T *&gt;(this)-&gt;impl(); // ... } static void static_func() { // ... T::static_sub_func(); // ... }};struct Derived : public Base&lt;Derived&gt;{ void impl() { std::cout &lt;&lt; &quot;Derived().impl()\\n&quot;; } static void static_sub_func();}; In the above example, the function Base&lt;Derived&gt;::interface(), though declared before the existence of the struct Derived is known by the compiler, is not actually instantiated by the compiler until it is actually called by some later code which occurs after the declaration of Derived (not shown in the above example), so that at the time the function “impl” is instantiated, the declaration of Derived::impl() is known. This technique achieves a similar effect to the use of virtual functions, without the costs (and some flexibility) of dynamic polymorphism. This particular use of the CRTP has been called simulated dynamic binding by some. To elaborate on the above example, consider a base class with no virtual functions. Whenever the base class calls another member function, it will always call its own base class functions. When we derive a class from this base class, we inherit all the member variables and member functions that were not overridden (no constructors or destructors). If the derived class calls an inherited function which then calls another member function, then that function will never call any derived or overridden member function which then another member function, then that function will never call any derived or overridden member functions in the derived class.However, if base class member functions use CRTP for all member function calls, the overridden functions in the derived class will be selected at compile time. This effectively emulates the virtual function call system at compile time without hte costs in size or function call overhead (VTBL structures, and method lookups, multiple-inheritance VTBL machinery) at the disadvantage of not being able to make this choice at runtime. Object CounterThe main purpose of an object counter is retrieving statistics of object creation and destruction for a given class. This can be easily solved using CRTP. 123456789101112131415161718192021222324252627282930template &lt;typename T&gt;struct Counter { static inline int objects_created = 0; static inline int objects_alive = 0; Counter() { ++objects_created; ++objects_alive; } Counter(const Counter&amp;) { ++objects_created; ++objects_alive; }proteced: ~counter() // objects should never be removed through pointers of this type. { --objects_alive; };};class X : public Counter&lt;X&gt;{ // ...};class Y : public Counter&lt;Y&gt;{ // ...}; Each time an object of class X is created, the constructor of counter&lt;X&gt; is called, incrementing both the created and alive count. Each time an object of class X is destroyed, the alive count is decremented. It is important to note that Counter&lt;X&gt; and Counter&lt;Y&gt; are two separate classes and this is whey they will keep separate counts of Xs and Ys. In this example of CRTP, this distinction of classes is the only use of the template parameter (T in Counter&lt;T&gt;) and the reason whey we cannot use a simple un-templated base class. Polymorphic ChainingMethod chaining, also known as named parameter idiom, is a common syntax for invoking multiple method calls in object-oriented programming languages. Each method returns an object, allowing the calls to be chained together in a single statement without requiring variables to store the intermediate results.When the named parameter object pattern is applied to an object hierarchy, things can go wrong. Suppose we have such a base class: 12345678910111213class Printer {public: Printer(std::ostream &amp;pstream) : m_stream(pstream) {} template &lt;typename T&gt; Printer &amp;print(T &amp;&amp;t) { m_stream &lt;&lt; t; return *this; } template &lt;typename T&gt; Printer &amp;println(T &amp;&amp;t) { m_stream &lt;&lt; t &lt;&lt; std::endl; return *this; } private: std::ostream &amp;m_stream;}; Then Prints can be easily chained: 1Printer(myStream).println(&quot;Hello&quot;).println(500); However, if we define the following derived class: 1234567891011class CoutPrinter : public Printer{public: CoutPrinter() : Printer(cout) {} CoutPrinter &amp;SetConsoleColor(Color c) { // ... return *this; }}; We ‘lose’ the concrete class as soon as we invoke a function of the base: 123// v --- we have a 'Printer' here, not a 'CoutPrinter'CoutPrinter().print(&quot;hello &quot;).SetConsoleColor(Color.red).println(&quot;Printer!&quot;);// compile error This happens because ‘print’ is a function of the base - ‘Printer’ - and then it returns a ‘Printer’ instance.The CRTP can be used to avoid such problem and to implement “Polymorphic chaining”: 1234567891011121314151617181920212223242526272829303132333435363738// Base classtemplate &lt;typename ConcretePrinter&gt;class Printer {public: Printer(std::ostream &amp;pstream) : m_stream(pstream) {} template &lt;typename T&gt; ConcretePrinter &amp;print(T &amp;&amp;t) { m_stream &lt;&lt; t; return static_cast&lt;ConcreatePrinter &amp;&gt;(*this); } template &lt;typename T&gt; ConcretePrinter &amp;println(T &amp;&amp;t) { m_stream &lt;&lt; t &lt;&lt; std::endl; return static_cast&lt;ConcretePrinter &amp;&gt;(*this); } private: std::ostream &amp;m_stream;};// Derived classclass CoutPrinter : public Printer&lt;CoutPrinter&gt;{public: CoutPrinter() : Printer(std::cout) {} CoutPrinter &amp;SetConsoleColor(Color c) { // ... return *this; }};// Usage:CoutPrinter().print(&quot;Hello &quot;).SetConsoleColor(Color.red).println(&quot;Printer!&quot;); Polymorphic Copy ConstructionWhen using polymorphism, one sometimes need to create copies of objects by the base class pointer. A commonly used idiom for this is adding a virtual clone function that is defined in every derived class. The CRTP can be used to avoid having to duplicate that function or other similar functions in every derived class. 12345678910111213141516171819202122232425// Base class has a pure virtual function for cloningclass AbstractShape {public: virtual ~AbstractShape () = default; virtual std::unique_ptr&lt;AbstractShape&gt; clone() const = 0;};// This CRTP class implements clone() for Derivedtemplate &lt;typename Derived&gt;class Shape : public AbstractShape {public: std::unique_ptr&lt;AbstractShape&gt; clone() const override { return std::make_unique&lt;Derived&gt;(static_cast&lt;Derived const &amp;&gt;(*this)); } protected: // We make clear Shape class needs to be inherited Shape() = default; Shape(const Shape &amp;) = default; Shape(Shape &amp;&amp;) = default;};// Every derived class inherits from CRTP class instead of abstract classclass Square : public Shape&lt;Square&gt; {};class Circle : public Shape&lt;Circle&gt; {}; This allows obtaining copies of squares, circles or any other shapes by shapePtr-&gt;clone(). CRTP widely employed for static polymorphism without bearing the cost of virtual dispatch mechanism. Consider the following code we have not used virtual keyword &amp; still achieved the functionality of polymorphism (specifically satic polymorphism). 1234567891011121314151617181920212223242526template &lt;typename specific_animal&gt;struct animal { void who() { implementation().who(); } private: specific_animal &amp;implementation() { return *static_cast&lt;specific_animal *&gt;(this); }};struct dog : public animal&lt;dog&gt; { void who() { std::cout &lt;&lt; &quot;dog&quot; &lt;&lt; std::endl; }};struct cat : public animal&lt;cat&gt; { void who() { std::cout &lt;&lt; &quot;cat&quot; &lt;&lt; std::endl; }};template &lt;typename specific_animal&gt;void who_am_i(animal&lt;specific_animal&gt; &amp;animal) { animal.who();} PitfallsOne issue with static polymorphism is that without using a general base class like AbstractShape from the above example, derived classes cannot be stored homogeneously - that is, putting different types derived from the same base class in the same container. For example, a container defined as std::vector&lt;Shape *&gt; does not work because Shape is not a class, but a template needing specialization. A container defined as std::vector&lt;Shape&lt;Circle&gt;*&gt; can only store Circles, not Squares. This is because each of the classes derived from the CRTP base class Shape is a unique type. A common solution to this problem is to inherit from a shared base class with a virtual destructor, like the AbstractShape example above, allowing for the creation of a std::vector&lt;AbstractShape*&gt;.","link":"/2023/05/13/CRTP/"},{"title":"CUB Architecture Overview","text":"IntroductionThrust — Host-side interface, no kernels.CUB — CUDA Unbound (C_uda U_n_B_und)software reuse in CUDA Kernels. Compile-time binding with template, typing high performance. So stiching these kernels together, you can get high performance. And finally, because CUB doesn’t dictate things like thread block size or shared memory usage, it allows you to experiment with these values as you optimize or auto-tune your code. And one thing you’ll find if you get into optimizing CUDA code is that this kind of auto-tuning where you experiment with or even automatically sweep the parameters of your code, things like the block size and the shared memory size. That’s a really powerful tool for extracting the maximum amount of performance from your code without investing a lot of personal effort. CUB is a generic, configurable C++ template library for high performance CUDA primitives. It targets each layer of the CUDA programming model. reusable software components are: Parallel primitives: Warp-wide “collective” primitives Block-wide “collective” primitives Device-wide primitives Utilities: Fancy iterators Thread and thread block I/O PTX intrinsics Device, kernel, and storage management CUB is CUDA C++ specific, it allows the programmers to intefere CUDA specific details (the number of threads, cudaStream_t parameters etc.). So the primitives can be configured for a specific GPU architecture. Iteratorscub::ArgIndexInputIterator&lt;InputIterator, OffsetT, OutputValueT&gt;1234567template &lt; typename InputIteratorT, typename OffsetT = ptrdiff_t, typename OutputValueT = cub::detail::value_t&lt;InputIteratorT&gt;&gt;class cub::ArgIndexInputIterator&lt;InputIteratorT, OffsetT, OutputValueT&gt; { }; References CUB Introduction Introducing CUDA UnBound (CUB)","link":"/2022/12/12/CUB-Archiecture-Overview/"},{"title":"Execution Policy in C++17","text":"","link":"/2022/11/22/Execution-Policy-in-C-17/"},{"title":"RAII","text":"","link":"/2023/05/13/RAII/"},{"title":"C++ functional Library Introduction","text":"","link":"/2023/05/13/cpp-std-functional/"},{"title":"Perfect Forwarding","text":"Forward ReferencesT&amp;&amp; can accept lvalues and rvalues, so this is also called Universal Reference. 1234567template &lt;typename TPara&gt;void foo(TPara &amp;&amp; p) {}// usagefoo(3);foo(std::move(i));foo(std::move(up)); &amp; &amp;&amp; T&amp; T &amp; T &amp; T&amp;&amp; T &amp; T &amp;&amp; The upper table shows that references are collapsed to a lvalue reference when at least one of them is a lvalue reference.The lack of type substitution is the reason why the non-template rvalue reference do not accept lvalues. The only reason why the function parameter can be an lvalue is that an lvalue reference is introduced by the substitution. Without this substitution, no lvalue reference is involved and references are not collapsed. Perfect ForwardingWe’ve seen that template argument deduction would change reference to lvalue reference in case there is an lvalue reference exists.However, if we want the lvalue reference to be passed as an lvalue and the rvalue reference as an rvalue, we should use std::forward. It casts an rvalue reference into an rvalue and leaves an lvalue as it is. std::forward must be instantiated with the type parameter. 12345template &lt;typename TPara&gt;void foo(TPara &amp;&amp;p){ bar(std::forward&lt;TPara&gt;(p));} The argument of foo is passed with the same value category to bar. Whatever was passed as an lvalue to foo is passed as an lvalue to bar, likewise for every rvalue.Like std::move, std::forward is a pure cast and does not generate a single machine operation. People have phrased this as: std::move does not move and std::forward does not forward. They rather cast their arguments to be moved or forwarded. const T&amp; — Universal ReferenceMay be you are wondering that why const T&amp; can bind to rvalues and lvalues.C++98 didn’t have rvalue references, only “references” — what we now call “lvalue references”. The rule was simply that a mutable reference would bind only to a mutable lvalue, but a const reference could bind to anything. 12345678910111213void change(int &amp;);void observe(const int &amp;);int main(){ int i = 41; change(i); // OK, lvalue change(42); // Error, rvalue observe(i); // OK, lvalue observe(42); // OK, rvalue return 0;} This also applies even when that type int comes from type deduction: 12345678910111213template &lt;typename T&gt;void observe(const T&amp;);int main(){ int i = 41; const int ci = 42; observe(i); // OK, lvalue, T = int observe(ci); // OK, lvalue, T = int observe(43); // OK, rvalue, T = int return 0;} When C++11 invented rvalue references, none of this behavior changed at all. const T&amp; still binds happily to both lvalues and rvalues. const T&amp; is the O.G. universal reference. C++11 also invented the forwarding reference: that when there’s a deduced type T directly modified by &amp;&amp;, T can sometimes be deduced as an lvalue reference type. 1234567891011121314template &lt;typename T&gt;void forward(T &amp;&amp;) {}int main(){ int i = 41; const int ci = 42; forward(i); // OK, lvalue, T = int &amp; forward(ci); // OK, lvalue, T = const int &amp; forward(43); // OK, rvalue, T = int return 0;} The advantage of T &amp;&amp; is that (, by looking at whether T deduced as a reference type) you can tell whether your caller considered the argument an rvalue or an rvalue. That’s not useful information in its own right; it is useful only if you are planning to forward your argument as its original value category - lvalues as lvalues, rvalues as rvalues. That’s what std::forward&lt;T&gt;(t) is for. In exchange for this advantage - forwardability - you pay in template bloat. Notice taht we get three difference instantiations of void forward(T &amp;&amp;) above, whereas we got only a single template instantiation of void observe(const T&amp;). 12345678// Instantiated from forward(i)template&lt;&gt; void forward&lt;int &amp;&gt;(int &amp;) {}// Instantiated from forward(ci)template&lt;&gt; void forward&lt;const int &amp;&gt;(const int &amp;) {}// Instantiated from forward(43)template&lt;&gt; void forward&lt;int&gt;(int &amp;&amp;) {} References “Universal reference” or “forwarding reference”? Perfect forwarding and universal references in C++","link":"/2023/05/13/perfect-Forwarding/"},{"title":"Argument Dependent Lookup","text":"","link":"/2023/05/13/Argument-Dependent-Lookup/"},{"title":"C++ Iterator System","text":"CategoriesIterators can be distinguished by the form of access: InputIterator: an iterator concept for reading the referred entries (but only once). OutputIterator: an iterator concept for writing to the referred entries (but only once). Note that the ability to write doesn’t imply readability; e.g., an ostream_iterator is an STL interface used for writing to output streams like std::cout or output files. Categories of the form of traversal: ForwardIterator: a concept for iterators that can pass from one element to the next, i.e., types that provide an operator++. It is a refinement of InputIterator and OutputIterator. In contrast to those, ForwardIterator allows for reading values twice and for traversing multiple times. BidirectionalIterator: a concept for iterators with step-wise forward and backward traversal, i.e., types with operator++ and operator--. It refines ForwardIterator. RandomAccessIterator: a concept for iterators to which an arbitrary positive or negative offset can be added, i.e., types that additionally provide operator[]. it refines BidirectionalIterator. A clever design choice of all iterator interfaces was that their operations are also provided by pointers. Every pointer models RandomAccesIterator so that all STL algorithms can be applied on old-style arrays via pointers. Iterator Category Write Read Increment Decrement Random Access Contiguous Storage OutputIterator Required Required InputIterator Required Required ForwardIterator Required Required BidirectionalIterator Required Required Required RandomAccessIterator Required Required Required Required ContiguousIterator Required Required Required Required Required","link":"/2023/05/14/C-Iterator-System/"},{"title":"C++ Best Practices","text":"","link":"/2023/05/14/C-Best-Practices/"},{"title":"C++ Basics","text":"Template and Generic ProgrammingAims An understanding template purpose and semantics. A working knowledge of function and type template syntax in C++ An understanding static polymorphism and how it is implemented using CRTP. An introduction to type traits, the basis of C++ metaprogramming. An understanding of different approaches to compile-time conditional coding. An understanding of policy classes. An understanding of how to implement perfect forwarding with variadic parameters and forwarding references. An understanding of how to determine the types of variables whose types are deduced. An understanding of the goals of Generic Programming. An understanding of the process of developing code using the Generic Programming paradigm. An understanding of how to use the STL to model and solve a real-world problem. Familiarity with the algorithms provided in the Standard Library. Outlines Template Syntax and Mechanics Motivation Template Instantiation Argument Deduction Two-phase Compilation Dependent Types Non-Type Template Parameters Overloading Function Templates Function Template Partial Ordering Class Templates Explicit Specialization Partial Specialization Dependent Base Modern Template Techniques The Template Challenge CRTP – Static Polymorphism Type Traits – Basic Metaprogramming Compile-time Conditional Overloading Policy Classes Perfect Forwarding Viewing Deduced Types Introduction to Generic Programming Alex Stepanov Programming = Math + Memory Algorithms Abstraction Generic Library Design Generalizing Linear Search Concepts and Models Valid Expressions Associated Types Associate Semantics Fundamental Concepts Iterator Concepts Input Iterator Output Iterator Forward Iterator Bidirectional Iterator Random Access Iterator Using the Standard Template Library Example Domain: Graphs Survey of the Standard Algorithms Non-modifying and Modifying Minimum and Maximum Permutation, Sorting, and Partitioning Set, Heap, and Numeric","link":"/2023/05/14/C-Basics/"},{"title":"C++ Value Categories","text":"MotivationConsider the following code: 123456789101112131415161718struct Data { Data(size_t s); // constructor Data(const Data &amp;); // copy constructor Data(Data &amp;&amp;) // move constructor size_t s; int *b;};const Data getData(size_t s) { return Data{s}; }// Consider what times does following code call constructors?auto d1 = Data{42}; // 1 --- constructorauto d2 = std::move(d1); // 0 --- d1 is pointer, then just move d1 value to d2;auto d3 = getData(42); // 1 --- constructorauto d4 = std::move(getData(42)); // 2, one for constructor, and since the // return type is const Data, so the copy // constructor is called for d4 construction. Explanationauto d4 = std::move(getData(42)); Firstly, Data(size_t s) constructor is called by getData() function. Then the copy constructor is called because getData function returns a const Data object, so the copy constructor creates a new Data object, and std::move moves new object for d4. Value CategoriesValue Categories were inherited from C, with the porting of “lvalue expression”, which is originally referred to the location of expression with regards to assignment. 1auto a = int(42); lvalue (left-value) was on the left of the assignment. rvalue (right-value) was on the right of the assignement. Value Category of an entity defines: lifetime Can it be moved from Is it a temporary Is it observable after change, etc Identity Object has identity if its address can be taken and used safely Value Categories affect two very important aspects: PerformanceOverload resolution Value Category is a quality of an expression. 1234567891011struct Data { Data(int x); int x_;};void foo(Data &amp;&amp;x) { x = 42; }// ...Data &amp;&amp;a = 42;foo(a); // Fail! lvalue!foo(Data{73}); // OK ExplanationData &amp;&amp;a is rvalue reference, but this is confusing because a have a name we can take and change it, which means this is an lvalue. a’s Type: rvalue reference to Data a’s Value Category: lvalueThe entity can have different Value Category in different contexts.So let’s look at function foo that takes data, during calling this function, we firstly create this unamed temporary data with 73, foo function binds the temporary data object to this rvalue reference, now in this function foo, this temporary entity has a name inside the scope of the foo function, so inside the scope of the foo function, this entity is an lvalue, because we can take its address we can assign to it. So the different scope gave different value category to the same entity. Each expression has two properties: A TYPE (including CV qualifiers) A VALUE CATEGORY Value Category is a quality of an expression. Expression Category taxonomy 12345 expression / \\ glvalue rvalue / \\ / \\lvalue xvalue prvalue C++11: added rvalue references, move semantics: Has Identity (glvalue) Doesn’t have identity Can’t be moved from lvalue - Can’t be moved from (rvalue) xvalue prvalue C++17: added guaranteed copy elision:[P0135] Guaranteed copy elision through simplified value categories Has Identity (glvalue) Doesn’t have identity Can’t be moved from lvalue - Can’t be moved from (rvalue) xvalue prvalue materialization The result of a prvalue is the value that the expression stores into its context. So then we materialize this thing and we get the prvalue. C++20:[p0527]: Implicitly move from rvalue references in return statementsMoved Value Categories section from [basic] to [expt — expression] C++23:[P0847]: Deducing this TODO: Differences about value categories between C++11 and C++17 and C++20TODO: Value Categories in C++17 Main Categories (classification only) glvalue: (have identity) expression whose evaluation determines the identity of an object or function. rvalue: (can be moved from) a prvalue or an xvalue Subcategories lvalue: glvalue that is not an xvalue xvalue: glvalue that denotes an object whose resources can be reused (usually because it is near the end of its lifetime). prvalue: expression whoes evaluation initializes an object, or computes the value of the operand of an operator, as specified by the context in which it appears, or an expression that has type cv void. glvalue 1234567891011121314151617181920struct Data { int n; int* pn = &amp;n; };Data&amp; getData(Data&amp; d) { return d; }int a = 42;int b = a;int&amp; la = a;int* pa = &amp;a;int&amp;&amp; ra = 42;a++;++a;int arr[] = {1, 2, 3};arr[0] = 73;Data d;(&amp;d)-&gt;n = 42;d.n = 73;*d.pn = 42;string s = &quot;Hello world&quot;;a == b ? b : c;Data c = getData(d); prvalue 1234567891011121314151617181920struct Data { int n; int foo() { this-&gt;n = 4; }};int a = 42;int* pa = &amp;a;pa = nullptr;a++;++a;auto l = []() { return 2; };Data d;Data* dp = &amp;d;Data();d-&gt;n = 6;d.n = 6;string s = &quot;Hello world&quot;;a == a ? throw 4 : throw 2;bool equals = a == 42; xvalue 12345678910struct Data { int n; int* pn = &amp;n; };Data d1 = Data{42};d1.*pn = 73;Data d2 = std::move(d1);Data().n;Data getData() { return Data{73}; }Data d3 = getData();d1 == d2 ? Data{42} : Data{73}; The Details of Binding Expressions with different Value Categories “bind” to different types of References. The Reference type which binds the expression determines the permitted operations. 123456789101112int a = 42;int&amp; la = a;const int&amp; cla = a;int&amp;&amp; ra = a + 73;const int&amp;&amp; cra = 42;// ... la = 73; // OK, a = la = 73cla = 42; // Errorra = 73; // OK, int&amp;&amp; ra = a + 73, this means there exits a ra, and ra value is a + 73, // then ra = 73 means change ra value to 73 since ra is lvalue category.cra = 42; // Error Binding rules are important as part of the following “events”: Initialization or assignment Function call (including non-static class member function called on an object) Return statement So all of these three different events that happens in your code needs to take the value category and the binding rules under consideration. Initialization or Assignment123456789int a = 42;int&amp; la1 = a; // OK la = 42int&amp; la2 = 73; // Errorconst int&amp; cla1 = a; // OKcosnt int&amp; cla2 = 73; // OKint&amp;&amp; ra1 = a; // Errorint&amp;&amp; ra2 = a + 42; // OKconst int&amp;&amp; cra1 = a; // Errorconst int&amp;&amp; cra2 = a + 42; // OK Binding Rules Binds lvalues? Binds rvalues? lvalue reference YES NO const lvalue reference YES YES rvalue reference NO YES const rvalue reference NO YES rvalues can be bound to const lvalue reference and rvalue reference and to const rvalue reference. lvalues can be bound to lvalue reference and const lvalue reference. This is very important in the scope of talking about move constructor.If a rvalue is bound to a const lvalue reference, it will extend its lifetime, rvalue reference can extend the lifetime of a temporary. Limitations is the context of the function are according to the binding function: Function can modify data?? Caller can observe (old) data? lvalue reference YES YES const lvalue reference NO YES rvalue reference YES NO const rvalue reference NO NO Copy Elision OptimizationsReturn Statement:Starting from C++17, the behavior of VCs is affected by: “PO135 Guaranteed copy elision (…)”There are two mandatory elisions of copy and move constructors: Object Initialization 123Data d = Data{Data{42}};// 1 CTOR (avoids: Copy CTOR)// In C++17, copy constructor would be removed. Return StatementAn un-named Return Value Optimization (RVO): 123Data getData(int x) { return Data{x}; }Data d = getData(42);// 1 CTOR (avoids Move CTOR) Return Statement: MaterializationTemporary materialization conversion conv.rvalA prvalue of type T can be converted to an xvalue of type T. This conversion initializes a temporary object of type T from the prvalue by evaluating the prvalue with the temporary object as its result object, and produces an xvalue denoting the temporary object. In order to materialize, T shall be a complete type. The Details of Binding To summarize:Binding rules apply in the following “events”: initialization or assignment Function call (including non-static class member function called on an object) Return statements Behavior of the entity(which :The behavior of the entity is defined by the things that binds it. Initialization: limits are according to the reference which binds it. Function call: limits inside the function are according to the overload which binds it. Return statement: limits as in initialization, with additional rules due to optimizations and const Reference CollisionIn case of concatenation of multiple ‘&amp;’ symbols, such as in generic code, or in code using type aliases. Compiler performs Reference Collision. 123456789101112typedef int&amp; lr;typedef int&amp;&amp; rr;int a;// Compiler knows the actual types, and then// compiler performs reference collision, we can// get the actual types.lr&amp; b = a; // lr&amp; -&gt; int&amp;&amp; -&gt; int&amp;lr&amp;&amp; c = a; // lr&amp;&amp; -&gt; int&amp;&amp;&amp; -&gt; int&amp;rr&amp; d = a; // rr&amp; -&gt; int&amp;&amp;&amp; -&gt; int&amp;rr&amp;&amp; e = 73; // rr&amp;&amp; -&gt; int&amp;&amp;&amp;&amp; -&gt; int&amp;&amp; Forwarding ReferenceForwarding parameters inside a function template should consider Value Categories. The term for them was first suggested by Scott Myers, “universal reference”, and later, formalized as “forwarding reference“.Due to TAD, “rvalue reference” has a special meaning in context of function template: 123456789101112131415// In the following code, T&amp;&amp; looks like rvalue reference,// But it is actually a forwarding reference (only in this// context).template &lt;typename T&gt;void foo(T&amp;&amp; t) { // Type of T here}int a = 42;const int&amp; cla = a;int&amp;&amp; b = 73;// This conversion is due to Reference Collision.foo(a); // T = int&amp;foo(cla); // T = const int&amp;foo(std::move(a)); // T = T = int T&amp;&amp; keeps the value category of the type the instantiation is based on. tools for Handling Value CategoriesThis tools helps you to manipulate value categories to understand better and to control them in your code. 123456std::movestd::forwardstd::decaystd::declvaldecltype specifierDeducing this (C++23) std::moveUtility function, produces an xvalue expression T&amp;&amp;, this equivalent to static_cast to a T value reference type: static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t) Notice that std::move may not always do what you hoped: 123456789101112void foo(int&amp; x) { std::cout &lt;&lt; &quot;int&amp;&quot;; }void foo(const int&amp; x) { std::cout &lt;&lt; &quot;const int&amp;&quot;; }void foo(int&amp;&amp; x) { std::cout &lt;&lt; &quot;int&amp;&amp;&quot;; }int a = 73;int&amp; b = a;const int&amp; c = a;const int&amp;&amp; d = 42;foo(std::move(b)); // int&amp;&amp; --&gt; foo(int&amp;&amp;)foo(std::move(c)); // const int&amp; --&gt; foo(const int&amp;)foo(std::move(d)); // const int&amp;&amp; --&gt; foo(const int&amp;) std::forward1std::forward&lt;T&gt;(expression); N1385 The forwarding problem: Arguments, presented two issues: forwarding params, and returning result. Suggested utility function, preserves value category of the object passed to the template.It suggests a solution for the forwarding problem. In this paper, they’ve recognized that there is an issue and the value categories are something be that needs to be preserved, and suggested this utility. std::forward uses std::remove_reference&lt;T&gt; to get the value type. std::forward uses other utilities from the standard library in the implementation, and it’s commonly used combined with forwarding reference. 12345678910111213141516171819// There are three overloads of the functions.void foo(int&amp; x) { std::cout &lt;&lt; &quot;int&amp;&quot;; }void foo(const int&amp; x) { std::cout &lt;&lt; &quot;const int&amp;&quot;; }void foo(int&amp;&amp; x) { std::cout &lt;&lt; &quot;int&amp;&amp;&quot;; }template &lt;typename T&gt;void wrapper(T&amp;&amp; t) { foo(std::forward&lt;T&gt;(t)); }template &lt;typename T&gt;void nfwrapper(T&amp;&amp; t) { foo(t); }int a = 73;const int&amp; lca = a;wrapper(a); // int&amp;nfwrapper(a); // int&amp;wrapper(lca); // const int&amp;nfwrapper(lca); // const int&amp;wrapper(6); // int&amp;&amp;nfwrapper(6); // int&amp; std::decay1std::decay&lt;T&gt;::type Type trait, result is accessible through _t. Performs the following conversions: Array to pointer Function to function pointer lvalue to rvalue (removes cv qualifiers, references) (issue for move-only types) it is the std::decay is doing something very similar to what auto is doing. 1234567template &lt;typename T, typename U&gt;struct decay_is_same : std::is_same&lt;typename std::decay&lt;T&gt;::type, U&gt;{};// How to use former definition:decay_is_same&lt;int&amp;, int&gt;::value; // True This behavior should be familiar to you, as it resembles autos behavior (auto performs auto-decay).TODO decltype specifier1decltype( expression ); decltype is a language thing, is a language utility, and it bascially gives you back the type of the object including value category, which is very important. decltype evaluates an expression, yields its type + value category (AKA the declared type).decltype (unlike auto) preserves value category. For an expression of type T: If expression is xvalue, yields T&amp;&amp;. If expression is lvalue, yields T&amp;. If expression is prvalue, yields T. decltype can be used instead of a type, as a placeholder which preserves value categories 12345int&amp;&amp; foo(int&amp; i) { return std::move(i); }int i = 73;auto a = foo(i); // Type: int | VC: lvaluedecltype(auto) b = foo(i); // Type: rvalue ref | VC: lvalue The T prvalue doesn’t materialize, so T can be an incomplete type (C++17). If evaluation fails (entity is not found or overload resolution fails), program is ill-formed. ((expression)) has a special meaning, and yields an lvalue expression. 123int&amp;&amp; a = 42;decltype(a) b = 42; // Type: rvalue ref to int | VC: lvaluedecltype((a)) c = 73; // Error! Binding non-const lvalue ref to prvalue decltype main use cases: When the type is unknown (syntax is available from C++14), we can use that to retrieve the type.12345678template &lt;typename T, typename U&gt;decltype(auto) Add(T t, U u) { return t + u; }template &lt;typename T&gt;decltype(auto) Wrapper(T&amp;&amp; t) { // do something... return std::forward&lt;T&gt;(t);} To preserve the value category of the expression.1234int &amp;&amp; a = 32; // Type: rvalue ref to int | VC: lvaluedecltype(a) b = a; // Error! (binding rvalue ref to an lvalue ref a)decltype(a) c = 73; // Type: rvalue ref to int | VC: lvaluedecltype((a)) d = a; // Type: lvalue ref to int | VC: lvalue std::declval1std::declval&lt;T&gt;( ) It basically takes an object and return the type.Utility function produces: xvalue expression T&amp;&amp;. If T is void, returns T. std::declval can be used with expression to return the expression’s reference type. It can return a non-constructible or incomplete type. 1234567891011struct Type { int a; int foo() { return 42; }private: Type() { }};// Fails, the Type() constructor is a private function.Type t;// Type, we can use this incomplete type for std::declval.typeid(std::declval&lt;Type&gt;()).name(); So this is a way for you to communicate with compiler.Combined with decltype, we can get the type of a member (even when Type is non-constructible). 1decltype(std::declval&lt;Type&gt;().a) b = 73; std::declval shouldn’t be used in an evaluated context (evaluating std::decltype is an error). std::declval allows us to access T members, in a way preserves value categories. 1234567891011121314struct Type { int a; int&amp; ra = a; int getA() { return int{73}; } int&amp; getRefA() { return ra; } private: Type(int i) : a(int(i)) {}};std::declval&lt;Type&gt;().a; // xvaluestd::declval&lt;Type&gt;().ra; // lvaluestd::declval&lt;Type&gt;().getA(); // prvaluestd::declval&lt;Type&gt;().getRefA(); // lvalue std::decltype and std::declval are often used to transform between type and instance, for example: Deducing This (C++23)12template &lt;typename T&gt;void Foo(this T&amp;&amp; t) { } P0847: Deducing this - voted into C++23this allows specifying from within a member function the value category of the expression it’s invoked on 123456789101112struct Type { auto Foo() const &amp;; auto Foo() &amp;; auto Foo() &amp;&amp;;};// This can be re-written like this:struct Type { auto Foo(this const Type&amp;); auto Foo(this Type&amp;); auto Foo(this Type&amp;&amp;);}; Combined with the forwarding reference, we can now write all these in a single template function. 1234struct Type { template &lt;typename Self&gt; auto Foo(this Self&amp;&amp; self);}; This would help you to write libraries, or multiple overloads. “Deducing this” feature introduced two new utilities: std::like_t and std::forward_like&lt;T&gt;(u). std::like_t applies CV and ref-qualifiers of T onto U. For example: 1234std::like_t&lt;double&amp;, int&gt;; // int&amp;std::like_t&lt;const double&amp;, int&gt;; // const int&amp;std::like_t&lt;double&amp;&amp;, int&gt;; // int&amp;&amp;std::like_t&lt;const double&amp;&amp;, int&gt;; // const int&amp;&amp; 1std::forward_like&lt;T&gt;(U) -&gt; std::forward&lt;std::like_t&lt;T, decltype(u)&gt;&gt;(u) References A Taxonomy of Expression Value Categories Master C++ Value Categories With Standard Tools Value Categories in C++17","link":"/2023/05/14/C-Value-Categories/"}],"tags":[{"name":"C++17","slug":"C-17","link":"/tags/C-17/"},{"name":"C++20","slug":"C-20","link":"/tags/C-20/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"CMake","slug":"CMake","link":"/tags/CMake/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"LLVM","slug":"LLVM","link":"/tags/LLVM/"},{"name":"C++14","slug":"C-14","link":"/tags/C-14/"},{"name":"Meta-Programming","slug":"Meta-Programming","link":"/tags/Meta-Programming/"},{"name":"CUDA","slug":"CUDA","link":"/tags/CUDA/"},{"name":"Thrust","slug":"Thrust","link":"/tags/Thrust/"},{"name":"CUB","slug":"CUB","link":"/tags/CUB/"},{"name":"Interview","slug":"Interview","link":"/tags/Interview/"},{"name":"RAII","slug":"RAII","link":"/tags/RAII/"},{"name":"Perfect Forwarding","slug":"Perfect-Forwarding","link":"/tags/Perfect-Forwarding/"},{"name":"C++11","slug":"C-11","link":"/tags/C-11/"}],"categories":[],"pages":[{"title":"","text":"google-site-verification: google22665da6f1436b9d.html","link":"/google22665da6f1436b9d.html"},{"title":"about","text":"PROFILE Yuanjun RenSELF-ESTIMATION Proficiency in C + +, STL,Python; Proficient in the use of Linux operating system and shell programming; Familiar with Linux development environment, including VIM + GDB + GIT + C Make/Makefile and other development tools; EDUCATION Durations University Major Degree 2011/09 - 2014/04 China Academy of Aeronautics Science in Computational Aerodynamics Master 2007/09 - 2011/06 Beihang University Aircraft Design and Engineering Bachelor EXPERIENCE2022/02~ Present Company: Hexaflake Technology Co., Ltd. Position: GPU Compiler Development Engineer(Based on LLVM) 2018/03 - 2022/02 Company: Huawei Technologies Co., Ltd. Position: DSP Compiler Development Engineer(Based on LLVM) 2017/05 - 2018/03 Company: Xi’an Yongshengda Electronic Technology Co., Ltd. Position: C + + Development Engineer 2014/05 - 2017/04 Company: Aerodynamics Research Institute of Aviation Position: CFD Solver Development Engineer","link":"/about/index.html"}]}