{"posts":[{"title":"How To Use Hexo","text":"IntroductionThe combination of Hexo + GithubPages is an easier way to configure your own blog. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. StepsCreate a GitHub RepoYou should create a repo for your blog, and the repo name must be &lt;username&gt;.github.io. Init HexoThen, navigate to &lt;username&gt;.github.io directory, run the following command to init Hexo blog. 12# cd &lt;username&gt;.github.iohexo init Install DependenciesFinally, run the following command to finalize installing procedures. 1npm install Hexo Useful CommandsCreate a new postEnter &lt;username&gt;.github.io directory, and execute the following command for new page creation. If you haven’t specify layout, hexo will use the default layout for new page creation. The default layout is configured in _config.yml file, the keyword is default_layout. For more info, pleasesee chapter Writing. 12# hexo new [layout] &lt;title&gt;$ hexo new &quot;My New Post&quot; Run serverIf you want to preview your blog on your local machine, you can use following command to deploy your blog on your local machine. For more info, please see chapter Server. 1$ hexo server Generate static filesBefore you publish your blog to github pages, you should generate static files locally. If you use the github pages’s theme, you only need to configure wanted theme in your _config.yml file, and github will gengerate all static files before deploying. For more info, please see chapter Generating. 1$ hexo generate Deploy to Remote SitesAfter generating all static files, you can deploy your blog on github pages. This command would create a master branch in your blog repo. So your github pages should be based on master branch. You can change the github pages’ branch in Settings-&gt;Pages-&gt;Branch. 1$ hexo deploy For more info, please see chapter Deployment. ThemesInstall ThemeI’d like to use hexo-theme-icarus theme. User should execute the following commands to configure icarus theme. hexo-theme-icarus 12npm install hexo-theme-icarushexo config theme icarus Hexo provides numerous themes, please see Hexo-Themes for more details. Change Your Personnel InfoUser should change the personnel info in _config.icarus.yml file. NotesAll blog data are listed in source/ directory. My source directory hierarchy is as follows: 123456789101112» tree source source├── _posts│ ├── How-To-Use-Hexo.md│ └── hello-world.md└── img ├── alipay-qrcode.jpg ├── logo.png ├── logo.svg └── wechat-qrcode.jpg2 directories, 6 files If you want to change the default logo logo.svg, you should put your own logo.svg in source/img/logo.svg. Besides, Mac user can use imagemagick tool for png to svg conversion. For more details, you can see imagemagick-homepage. After install imagemagick tool, you can execute the following commands to convert. 1convert logo.png logo.svg Add “Read More” tag for your postsThere are two ways to add this tag. First, you can add excerpt tag in your post, and add some introductions for posts. 12345title: New Articledate: 2022-11-12excerpt: Introductions---# Contents ... add &lt;!-- more --&gt; line after introductions in your posts. References PicGo-Configuration Using-ssh-instead-of-http-in-config.yml-file Hexo-Doc Hexo-theme-icarus Hexo-theme-icarus-doc","link":"/2022/10/30/How-To-Use-Hexo/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/10/30/hello-world/"},{"title":"CMAKE---Multiple directories","text":"OverviewCMake is a directory-based project management tool. If your project has multiple directories, more CMakeLists.txt files should be created in your project directories. SituationAs the following directories, each directory is a standalone module. For example: the root target has its own source file(s) in ${ROOT}/src directory. hello_object_lib is a OBJECT target, and it has its own including paths. So we use a CMakeLists.txt file for target management. hello_shared_lib is a SHARED library target, the root project will link this shared library or provide for other projects. hello_static_lib is a STATIC library target, this target will generate a static library file for other projects. 12345678910111213141516171819202122232425262728tree.├── CMakeLists.txt├── hello_object_lib│ ├── CMakeLists.txt│ ├── inc│ └── src│ └── main.cc├── hello_shared_lib│ ├── CMakeLists.txt│ ├── include│ │ └── hello│ │ └── hello.hpp│ └── src│ ├── hello.cc│ ├── internal.cc│ └── internal.hpp├── hello_static_lib│ ├── CMakeLists.txt│ ├── include│ │ └── hello│ │ └── hello.hpp│ └── src│ ├── hello.cc│ ├── internal.cc│ └── internal.hpp└── src └── main.cc The content of root CMakeLists.txt is as follows. Each sub-directory should be added in this CMakeLists.txt. In this CMakeLists.txt, we define a executable target multiple_exec, all of the other targets will be linked to this executable target. There’s a difference should be noticed. OBJECT target cannot be linked into other targets using target_link_libraries command before CMake V3.12. So if you use the older CMake version, you should use the 12345678910111213141516171819202122cmake_minimum_required(VERSION 3.21)project(multiple_dirs VERSION 1.0 DESCRIPTION &quot;Multiple directory project&quot; LANGUAGES CXX)# Add subdirectories with examples.add_subdirectory(hello_object_lib)add_subdirectory(hello_shared_lib)add_subdirectory(hello_static_lib)# add an example executableadd_executable(multiple_exec)# add sources to the example executabletarget_sources(multiple_exec PRIVATE src/main.cc)# link librariestarget_link_libraries( multiple_exec PRIVATE hello_object_target hello_shared_target hello_static_target) References My-Advanced-CMake-Repo","link":"/2022/10/31/CMAKE-Multiple-directories/"},{"title":"Template Metaprogramming---Type Traits","text":"The Aims How to implement and how to use Exploration of the standard set of type traits Focus on techniques for implementing type traits Remove some of the mystique that still surrounds template metaprogramming. Practical advice from a regular user. So you can more readily use the standard set and implement your own whenneeded. What is Meta-Programming In general, when programs treat programs as data Could be other programs or itself Could be at “compile time” or “run time” We will discuss compile time metaprogramming in C++ Wide array of current techniques, but still considered a niche This two-part tutorial helps shed light on a very few essential ideoms Why Care About Metaprogramming (and type traits in particular) Each new standard library employs more metaprogramming techniques Some requirements are impossible without advanced techniques(e.g., std::optional) Many third party libraries, not just Boost Tools and idioms have become well developed, no longer black magic, limited to STL and Boost. All C++ programmers should understand the basics. Any library developer should understand a good bit more C++20 - concepts and independent requires expressions It’s kind of a paradigm shift, there are a lot of things that make metaprogramming more look likeregular functional programming. Meta-Functions A meta-function is not a function but a class/struct Meta-functions are not part of the language and have no formal language support They exist as an idiomatic use of existing language features Their use is not enforced by the language Their use is dictated by convention C++ community has created common “standard” conventions The Definition of meta-function Technically, a class with zero+ template parameters and zero+ return types and values Convention is that a meta-function should return one thing, like a regular function Convention was developed over time, so plenty of existing examples that do not follow this convention More modern meta-functions do follow this convention Return From a Meta-Function Expose a public value “value” 1234template &lt;typename T&gt;struct TheAnswer { static constexpr int value = 42;}; Expose a public type “type” 1234template &lt;typename T&gt;struct Echo { using type = T;}; Meta-functions yield back some types to you. Value Meta-functions Simple regular function: identity This is a very simple regular function. 123int int_identity(int x) { reutrn x; }assert(42 == int_identity(42)); The Simple Meta-Function: identity 123456template &lt;int X&gt;struct IntIdentity { static constexpr int value = X;};static_assert(42 == IntIdentity&lt;42&gt;::value) Generic Identity Function 12345678template &lt;typename T&gt;T identity(T x) { return x; }// Returned type will be intassert(42 == identity(42));// Returned type will be unsigned long longassert(42ull == identity(42ull)); Generic Identity Meta-Function 12345678910template &lt;typename T, T Value&gt;struct ValueIdentity { static constexpr T value = Value;};// The type of value will be intstatic_assert(42 == ValueIdentity&lt;int, 42&gt;::value);// The type of value will be unsigned long longstatic_assert(ValueIdentity&lt;unsigned long long, 42ull&gt;::value == 42ull); Generic Identity Meta-Function (C++17) Template accepts non-type template parameter since C++17. 12345678910template &lt;auto X&gt;struct ValueIdentity { static constexpr auto value = X;};// The type of value will be intstatic_assert(42 == ValueIdentity&lt;42&gt;::value);// The type of value will be unsigned long longstatic_assert(42ull == ValueIdentity&lt;42ull&gt;::value); Two forms of Sum Function 1234567891011121314template &lt;typename X, typename Y&gt;constexpr auto sum(X x, Y y) { return x + y; }// Return type will be unsigned long longassert(42ull == sum(30, 12ull));// It takes two separate non-type template parameterstemplate &lt;auto X, auto Y&gt;struct Sum { static constexpr auto value = X + Y;};// Return type will be unsigned long longstatic_assert(42ull == Sum&lt;30, 12ull&gt;::value); Type Meta-Functions Type meta-functions just like a workhorse (especially will the advent of constexpr) which manipulatetypes. “Returns” a type. This is a type meta-function demo 12template &lt;typename T&gt;struct TypeIdentity { using type = T; }; C++20 introduces std::type_identity Calling Type Meta-Functions12ValueIdentity&lt;42&gt;::value;TypeIdentity&lt;int&gt;::type; Typename Dance 1typename TypeIdentity&lt;T&gt;::type; Convenience Calling Conventions Value meta-functions use variable templates ending with “_v”. 1234567891011121314template &lt;auto X&gt;struct ValueIdentity { static constexpr auto value = X;};// variable template// This is a convenient way to call a value meta-functions using// variable template.template &lt;auto X&gt;inline constexpr auto ValueIdentity_v = ValueIdentity&lt;X&gt;::value;static_assert(42 == ValueIdentity&lt;42&gt;::value);static_assert(42 == ValueIdentity_v&lt;42&gt;); Type Meta-Functions use alias templates ending with “_t”. Typename Dance. 1234template &lt;typename T&gt;using TypeIdentity_t = typename TypeIdentity&lt;T&gt;::type;static_assert(std::is_same_v&lt;int, TypeIdentity_t&lt;int&gt;&gt;); These calling conventions are easier to use. But each one must be explicitly handwritten. A meta-convention to get around that which I may get to if time for bonus material. Type TraitsSome Useful Meta-Functionsstd::integral_constantA very useful meta-function. It allows us to wrap a constant with its type. 123456789101112131415template &lt;class T, T v&gt;struct integral_constant { static constexpr T value = v; using value_type = T; using type = integral_constant&lt;T, v&gt;; constexpr operator value_type() const noexcept { return value; } // this is a functor, a call operator. constexpr value_type operator()() const noexcept { return value; }}; std::bool_constantThis is Convenient helpers. 12345678template &lt;bool B&gt;using bool_constant = integral_constant&lt;bool, B&gt;;// alias templates// this is equivalent to integral_constant&lt;bool, true&gt;.using true_type = bool_constant&lt;true&gt;;// this is equivalent to integral_constant&lt;bool, false&gt;.using false_type = bool_constant&lt;false&gt;; true_type and false_type are going to be meta-functions. They are called nullary meta-functionsbecause they have no parameters. 12true_type::value;false_type::value; Standard Type Trait RequirementsCpp17 Unary Type TraitCpp20 introduces very different meta-programming techniques. For a unary type trait in the standard library which is what we’re got which is what we are talkingabout. Unary type trait in the standard library it has a class template of one template typeargument Cpp17UnaryTypeTrait Class Template One template type argument* Cpp17DefaultConstructible Cpp17CopyConstructible Publicly and unambiguously derived from a specialization of std::integral_constant.All the unary type traits have to derive from integral_constant. The member names of the base characteristic shall not be hidden and shall be unambiguously availableBasically, this means if you inherit from it you can’t hide any of that stuff, you got to let allthat stuff be available publicly. Cpp17BinaryTypeTraitThis is an exactly same thing with Cpp17UnaryTypeTrait except Cpp17BinaryTypeTrait has twotemplate type argument*. Cpp17TransformationTrait Class Template One template type argument* Define a publicly asccessible nested type name type. No default/copy constructible requirement No inheritance requirement Specializationis_void (Unary Type Trait) Value meta-function: is the type void? yields true_type or false_type Specialization Primary template: general case 12template &lt;typename T&gt;struct is_void : std::false_type {}; Specialization: special case(s) 12345678910// The empty angle brackets mean it's an explicit full// specialization, and then we take the type that we// are specializing for. And we put it in right place.// In this case, we are going to return true and so// these static_assert.template&lt;&gt;struct is_void&lt;void&gt; : std::true_type {};static_assert(is_void&lt;void&gt;{});static_assert(not is_void&lt;int&gt;{}); Why does is void reutrn true type false type instead of true false values? The reason because it is a meta-function returning the true type(the actual type of it).First of all, the is_void is inherited from integral_constant. false_type is just integralconstant bool false. true_type is just integral_constant bool true. The standard says thatunary meta-functions must inherit from one of those.And the reason because if all we did was just return a true value where is a is_void is inherit from a true_type, and true_type is already having a type. static_assert(is_void&lt;void&gt;{}, the curly bracket, that is instantiating one of those things and itimplicit conversion operator to turn it into a true. Is void const void? Is void volatile void? is_void is in primary type categories. Yes, the standard says void &amp; void const &amp; void volatile &amp; void const volatile are all void. cv stands for const volatile For any given type T, the result of applying one of these templates to T and to cv T shall yieldthe same result. The definition of is_void 12345678910111213141516171819// The primary templatetemplate &lt;typename T&gt; struct is_void : std::false_type {};// specialization for void.template&lt;&gt;struct is_void&lt;void&gt; : std::true_type {};// specialization for void consttemplate&lt;&gt;struct is_void&lt;void const&gt; : std::true_type {};// specialization for void volatiletemplate&lt;&gt;struct is_void&lt;void volatile&gt; : std::true_type {};// specialization for void const volatiletemplate&lt;&gt;struct is_void &lt;void const volatile&gt; : std::true_type {};// The standard mandates this as well.template &lt;typename T&gt;inline constexpr bool is_void_v = is_void&lt;T&gt;::value; remove_const (Transformation Trait)There are three type traits: unary traits/binary traits/transformation traits. remove_const isa transformation traits. transformation traits are what they call they are type meta-functions. Formal Definition The member typedef type names the same type as T except that any top-level const-qualifier hasbeen removed. The top-level qualifier, like volatile/const which are attached to the type itself. 123456789101112remove_const&lt;int&gt; -&gt; intremove_const&lt;const int&gt; -&gt; intremove_const&lt;const volatile int&gt; -&gt; volatile intremove_const&lt;int *&gt; -&gt; int *remove_const&lt;cont int *&gt; -&gt; const int *// this because pointer to a constant,// it is not a const pointer.remove_const&lt;int const * const&gt; -&gt; int const *remove_const&lt;int * const&gt; -&gt; int * The definition of remove_const 1234567891011121314template &lt;typename T&gt;struct TypeIdentity { using type = T; };// primary template, do nothing if no consttemplate &lt;typename T&gt;struct remove_const : TypeIdentity&lt;T&gt; {};// Partial specialization, when detect consttemplate &lt;typename T&gt;struct remove_const&lt;T const&gt; : TypeIdentity&lt;T&gt; {};// Standar mandated convenience aliastemplate &lt;typename T&gt;using rmeove_const_t = typename remove_const&lt;T&gt;::type; Contains const so the partial specialization will match. 12template &lt;typename T&gt;struct remove_const&lt;T const&gt; : TypeIdentity&lt;T&gt; {}; The const is explicitly matched so the part remaining to match with the “T” is int volatile conditionalThis is basically think of it as like an if statement in regular programming. Some conditions itreturns T, else return F. In this you can read it, if the bool condition is true, return T, else return F. 1234567891011121314151617template &lt;typename T&gt;struct TypeIdentitiy { using type = T; };// This partial specialization means condition is true,// then returns T.template &lt;bool Condition, typename T, typename F&gt;struct conditional : TypeIdentity&lt;T&gt; {};// This partial specialization means condition is false,// then conditional returns F.template &lt;typename T, typename F&gt;struct conditional&lt;false, T, F&gt; : TypeIdentity&lt;F&gt; {};static_assert(is_same_v&lt;int, conditional_t&lt;is_void&lt;void&gt;::value, int, long&gt;);static_assert(is_same_v&lt;long, conditional_t&lt;is_void&lt;char&gt;::value, int, long&gt;); Not all the type traits can be implemented by c++, the compiler has way more information aboutthe type system and about what’s going on than it is exposed to the programmer through thelanguage. Type traits can be implemented by intrinsics, and compiler can be more efficient for intrinsicsprocessing. is_union should be supported by compiler. Primary Type CategoriesThere are 14 primary type categories. 1234567is_void is_classis_null_pointer is_functionis_integral is_pointeris_floating_point is_lvalue_referenceis_array is_rvalue_referenceis_enum is_member_object_pointeris_union is_member_function_pointer All are to have base characteristic of either true_type or false_type. All should yield the same result in light of cv(const volatile) qualifiers. is_null_pointer12345678910111213141516171819template &lt;typename T&gt;struct is_null_pointer : std::false_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t const&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t volatile&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t const volatile&gt; : std::true_type {};// The standard mandates this as well...template &lt;typename T&gt;inline constexpr bool is_null_pointer_v = is_null_pointer&lt;T&gt;::value; is_floating_pointfloat/double/long double requires 12 specializations. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename T&gt; struct is_floating_point : std::false_type {};// float typetemplate &lt;&gt;struct is_floating_point&lt;float&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float const volatile&gt; : std::true_type {};// double typetemplate &lt;&gt;struct is_floating_point&lt;double&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double const volatile&gt; : std::true_type {};// long double typetemplate &lt;&gt;struct is_floating_point&lt;long double&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double const volatile&gt; : std::true_type {};// for convenience usetemplate &lt;typename T&gt;inline constexpr bool is_floating_point_v = is_floating_point&lt;T&gt;::value; is_integral Five standard signed integer types: signed char, short int, int, long int, long long int. Implementation defined extended signed integer types. Corresponding, but different, unsigned integer types. char, char8_t, char16_t, char32_t, wchar_t. bool Requires 16 * 4 = 54 specializations. Meta-Function Abstractions We would have reached for this long before now with regular/normal programming. Treat meta-function programming like regular programming because, well, that’s what it is. Step back to the land of regular functions. Pretend we needed to implement these same ideas with strings instead of types. The regular type of is_void 1234567bool is_void(std::string_view s) { return s == &quot;void&quot; || s == &quot;void const&quot; || s == &quot;void volatile&quot; || s == &quot;void const volatile&quot; || s == &quot;void volatile const&quot;;} A new version of type traits(A Step in the right direction) 123456789101112131415161718192021222324252627282930std::string_view remove_cv(std::string_view);bool is_void(std::string_view s) { return remove_cv(s) == &quot;void&quot;;}bool is_null_pointer(std::string_view s) { return remove_cv(s) == &quot;std::nullptr_t&quot;;}bool is_floating_point(std::string_view input) { auto const s = remove_cv(input); return s == &quot;float&quot; || s == &quot;double&quot; || s == &quot;long double&quot;;}std::string_view strip_signed(std::string_view);bool is_integral(std::string_view input) { auto const s = strip_signed(remove_cv(input)); return s == &quot;bool&quot; || s == &quot;char8_t&quot; || s == &quot;char16_t&quot; || s == &quot;char32_t&quot; || s == &quot;wchar_t&quot; || s == &quot;char&quot; || s == &quot;short&quot; || s == &quot;int&quot; || s == &quot;long&quot; || s == &quot;long long&quot;;} We already have remove_const, we also need remove_volatile, compose them to get remove_cv. remove_volatile Formal Definition The member typedef type names the same type as T except that any top-level volatile-qualifier hasbeen remove. 123456789101112131415template &lt;typename T&gt;struct TypeIdentity { using type = T; };// Primary template, do nothing if no volatiletemplate &lt;typename T&gt;struct remove_volatile : TypeIdentity&lt;T&gt; {};// Partial specialization, when detect volatiletemplate &lt;typename T&gt;strut remove_volatile&lt;T volatile&gt; : TypeIdentity&lt;T&gt; {};// Standard mandated convenience alias.template &lt;typename T&gt;using remove_volatile_t = typename remove_volatile&lt;T&gt;::type; remove_cv Formal Definition The member typedef type names the same type as T except that any top-level cv-qualifier hasbeen removed. 123456789101112131415// template &lt;typename T&gt;// using remove_cv = remove_const&lt;typename remove_volatile&lt;T&gt;::type&gt;;// alias templatetemplate &lt;typename T&gt;using remove_cv = remove_const&lt;remove_volatile_t&lt;T&gt;&gt;;// remove_volatile_t&lt;T&gt; is the same thing with typename// remove_volatile&lt;T&gt;::type.// Here we don't use remove_const_t, this because we want// remove_cv to be a meta-function.// If we use remove_const_t, remove_cv is just a type either// meta-function.template &lt;typename T&gt;using remove_cv_t = typename remove_cv&lt;T&gt;::type; Eg. remove_cv&lt;int const volatile&gt; 12345678// Removing volatile, then consttemplate &lt;typename T&gt;using remove_cv = remove_const&lt;remove_volatile_t&lt;T&gt;&gt;;// remove_cv&lt;int const volatile&gt;// remove_const&lt;remove_volatile_t&lt;int const volatile&gt;&gt;// remove_const&lt;typename remove_volatile&lt;int const volatile&gt;::type&gt;// remove_const&lt;int const&gt; Eg. remove_ct_t&lt;int const volatile&gt; 1234567template &lt;typename T&gt;using remove_cv_t = typename remove_cv&lt;T&gt;::type;// remove_cv_t&lt;int const volatile&gt;// typename remove_cv&lt;int const volatile&gt;::type// typename remove_const&lt;int const&gt;::type// int is_same12345678910111213template &lt;typename T1, typename T2&gt;strut is_same : std::false_type {};// Partial specialization --- when they are both the same.// angle bracketstemplate &lt;typename T&gt;struct is_same&lt;T, T&gt; : std::true_type {};// When T1 and T2 are same, then is_same matches this partial// specialization version. Otherwise, is_same matches the// false_type version. Compiler only choose the best match version.template &lt;typename T1, typename T2&gt;constexpr bool is_same_v = is_same&lt;T1, T2&gt;::value; Examples static_assert(not is_same_v&lt;int, unsigned&gt;) T1 = int, T2 = unsigned, primary template matches. No way to make T to matchspecialization. static_assert(is_same_v&lt;int, int&gt;) T1 = int, T2 = int, primary template matches, T = int – specialization matches is_same_rawThis is not standard type traits, but it is kind of useful. Take two types, and remove eachcv qualifiers and then compares them. If the two types are the same after removing thesecv qualifiers, then I’m treat them the same. So this might be helpful considering thatall of our type traits want us to remove both the const and the volatile qualifiers. 12345template &lt;typename T1, typename T2&gt;using is_same_raw = is_same&lt;remove_cv_t&lt;T1&gt;, remove_cv_t&lt;T2&gt;&gt;;template &lt;typename T1, typename T2&gt;constexpr bool is_same_raw_v = is_same_raw&lt;T1, T2&gt;::value; is_floating_point: reduxThis is using alias template. 12345template &lt;typename T&gt;using is_floating_point = std::bool_constant&lt; is_same_raw_v&lt;float, T&gt; || is_same_raw_v&lt;double, T&gt; || is_same_raw_v&lt;long double, T&gt;&gt;; is_integral: redux123456789101112131415161718template &lt;typename T&gt;using is_integral = std::bool_constant&lt; is_same_raw_v&lt;bool, T&gt; || is_same_raw_v&lt;char, T&gt; || is_same_raw_v&lt;char8_t, T&gt; || is_same_raw_v&lt;char16_t, T&gt; || is_same_raw_v&lt;char32_t, T&gt; || is_same_raw_v&lt;wchar_t, T&gt; || is_same_raw_v&lt;signed char, T&gt; || is_same_raw_v&lt;short, T&gt; || is_same_raw_v&lt;int, T&gt; || is_same_raw_v&lt;long, T&gt; || is_same_raw_v&lt;long long, T&gt; || is_same_raw_v&lt;unsigned char, T&gt; || is_same_raw_v&lt;unsigned short, T&gt; || is_same_raw_v&lt;unsigned int, T&gt; || is_same_raw_v&lt;unsigned long, T&gt; || is_same_raw_v&lt;unsigned long long, T&gt;&gt;; It might be implemented using parameter pack. is_type_in_pack is a meta-function, it takes a type and ti take a list of bunch of other types.Adn is_type_in_pack will biscally returned true if that type was anywhere in that list. 12345678910111213template &lt;typename TargetT, typename ...Ts&gt;using is_type_in_pack = ...;template &lt;typename T&gt;using is_integral = is_type_inpack&lt;remove_cv_t&lt;T&gt;, bool, char, char8_t, char16_t, char32_t, wchar_t, signed char, unsigned char, signed short, unsigned short, signed int, unsigned int, signed long, unsigned long, signed long long, unsigned long long&gt;; is_arrayThe definition of is_array. 12345678910template &lt;typename T&gt;struct is_array : std::false_type {};// inbounded arraytemplate &lt;typename T, std::size_t N&gt;struct is_arrya &lt;T[N]&gt; : std::true_type {};// unbounded arraytemplate &lt;typename T&gt;struct is_array&lt;T[]&gt; : std::true_type {}; Some examples. 1234567static_assert(is_array,int[5]&gt;);// T = int[5] - primary template matches// T = int, N = 5 - first specialization matches// no way to form T to match second sepcializationstatic_assert(is_array&lt;int[]&gt;);// T = int[] == primary template matches is_pointer1234567891011121314namespace detail {// Primary template - most things are not pointerstemplate &lt;typename T&gt;struct is_pointer_impl : std::false_type {};// When we have a pointertemplate &lt;typename T&gt;struct is_pointer_impl&lt;T *&gt; : std::true_type {};} // end of namespace detail// alias template template &lt;typename T&gt;using is_pointer = detail::is_pointer_impl&lt;remove_cv_t&lt;T&gt;&gt;; is_unionThis meta-function is actually impossible to implement without support from the compiler. Both clangand gcc provide this particular compiler intrinsic to determine if a type is a union. 12template &lt;typename T&gt;using is_union = std::bool_constant&lt;__is_union(T)&gt;; is_class_or_unionWhat do we know about unions and classes that is unique to those two types? They can have members. Devise a way to detect if a type can have a member. How can you tell if a class has a member? The syntax for a pointer-to-member is valid for any class, even without any members. Eg. int* is a valid pointer type, but does not have to point to anything. meta-programming is aimed todeal with types, not the data. int Foo::* is a member pointer type, does not have to point to anything. 12345678910// An empty struct, with no members of any kindstruct Bar {};// BarIntObjectMemPtr is an alias for a type that is a// pointer to a member of class Bar, where the member// is an int.using BarintObjectMemPtr = int Bar::*;// This, however, generates a hard compiler errorusign LongIntObjectMemPtr = ing long::*; Funciton Overload Resolution123456789101112namespace detail {std::true_type is_nullptr(std::nullptr_t);// ... it will match anything. But it is the least priority.// It will only ever be used if nothing else matches. It'll// only be used if it's the only one that matches.std::false_type is_nullptr(...);} // end of namespace detailtemplate &lt;typename T&gt;using is_null_pointer = decltype(detail::is_nullptr(std::devlval&lt;T&gt;())); 123456static_assert(not is_null_pointer&lt;int&gt;::value);// This only match the second one.static_assert(is_null_pointer&lt;std::nullptr_t&gt;::value);// This can match two versions of `is_nullptr`, but overload// resolution will choose the first one, because the first// one is the best match. Another case. 1234567891011121314template &lt;typename T&gt;struct TypeIdentity { using type = T; };namespace detail {template &lt;typename T&gt;std::true_type isconst(TypeIdentity&lt;T const&gt;);template &lt;typename T&gt;std::false_type isconst(TypeIdentity&lt;T&gt;);} // end of namespace detailtemplate &lt;typename T&gt;using is_const = decltype(detail::isconst(std::declval&lt;TypeIdentity&lt;T&gt;&gt;())); This uses technique called Tag Dispatch. Tag Dispatch is where we are creating a type that isjust being used as a tag. TypeIdentity takes no space, and it is very efficient to pass these guys around. SFINAE (Substitution Failure Is Not An Error)12345template &lt;typename T&gt;std::true_type can_have_pointer_to_member(int T::*);template &lt;typename T&gt;std::false_type can_have_pointer_to_member(...); is_classAlmost always implemented as compiler intrinsic. Because compiler is much faster dealing withintrinsics than dealing with even the simplest template stuff. Without the support of compiler, itis kind of impossible to distinguish between union and non-union class type. We have is_union (with help from the compiler) The definition is: 1234567891011121314namespace detail {template &lt;typename T&gt;std::bool_constant&lt;not std::is_union_v&lt;T&gt;&gt;is_class_or_union(int T::*);// We only want to use the return type of `is_class_or_union`// function. So we don't need to create implementation for this// function.template &lt;typename T&gt;std::false_type is_class_or_union(...);}template &lt;typename T&gt;using is_class = decltype(detail::is_class_or_union&lt;T&gt;(nullptr)); Implement is_class using constexpr. 12345678910111213namespace detail {template &lt;typename T&gt; constexpr bool is_class_or_union(int T::*) { return not std::is_union&lt;T&gt;::value;}template &lt;typename T&gt; constexpr bool is_class_or_union(...) { return false;}} // end of namespace detailtemplate &lt;typename T&gt;using is_class = std::bool_constant&lt;detail::is_class_or_union&lt;T&gt;(nullptr)&gt;; 123template &lt;typename T&gt;using is_const = decltype(detail::isconst(std::declval&lt;TypeIdentity&lt;T&gt;&gt;())); decltype — tells you to pretend that compiler will evaluate this expression, and give me theresult the type that you would get from the evaluated expression. declval — is there so you can grab a reference to any type. It just gives you a referenceto something as if you had created one as if you had one. So it just declaration, it’s there’s noimplementation. is_in_pack1234567891011121314151617// Template declaration, with no definitiontemplate &lt;typename TargetT, typename... Ts&gt;struct IsInPack;// Base case --- no more elementstemplate &lt;typename TargetT&gt;struct IsInPack&lt;TargetT&gt; : std::false_type {};// NOTES: is_in_pack uses partial specialization to match// the two same types. If the first one matches the target,// we are done.template &lt;typename TargetT, typename... Ts&gt;struct IsInpack&lt;TargetT, TargetT, Ts...&gt; : std::true_type {};// Otherwise, check the remaining ones.template &lt;typename TargetT, typename T, typename... Ts&gt;struct IsInpack&lt;TargetT, T, Ts...&gt; : IsInPack&lt;Target, Ts...&gt; {}; Examples 12static_assert(IsInPack&lt;int, double,char,int,float&gt;::value);static_assert(not IsInPack&lt;long, double,char,int,float&gt;::value); The version of using is_base_of. 123456789101112namespace detail {template &lt;typename T&gt;struct TypeIdentitiy { using type = T; };template &lt;typename... Ts&gt;struct IsInPackImpl : TypeIdentity&lt;Ts&gt;... {};tmeplate &lt;typename TargetT, typename... Ts&gt;using IsInpack = std::is_base_of&lt; TypeIdentity&lt;TargetT&gt;, detail::IsInPackImpl&lt;Ts...&gt;&gt;;} // end of namespace detail Examples 12static_assert(IsInPack&lt;int, double,char,int,float&gt;::value);static_assert(not IsInPack&lt;long, double,char,int,float&gt;::value); is_base_ofIf Derived is derived from Base or if both are the same non-union class (in both casescv-qualification), provides the member constant value equal to true. Otherwise value is false. The possible definition of is_base_of is as follows: 12345678910111213141516171819202122namespace detail {template &lt;typename B&gt;std::true_type test_pre_ptr_convertible(const volatile B*);template &lt;typename&gt;std::false_type test_pre_ptr_convertible(const volatile void*);template &lt;typename, typename&gt;auto test_pre_is_base_of(...) -&gt; std::true_type;template &lt;typename B, typename D&gt;auto test_pre_is_base_of(int) -&gt; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));} // end of namespace detailtemplate &lt;typename Base, typename Derived&gt;struct is_base_of : std::integral_constant&lt; bool, std::is_class&lt;Base&gt;::value &amp;&amp; std::is_class&lt;Derived&gt;::value &amp;&amp; decltype(details::test_pre_is_base_of&lt;Base, Derived&gt;(0))::value &gt; {}; Learning materials. Template Metaprogramming: Type Traits Part I Template Metaprogramming: Type Traits Part II Modern Template Metaprogramming: A Compendium, Part I, Walter E. Brown, CppCon 2014,Link: Part IPart II References Modern C++ Design About C++ Template Metaprogramming Template Metaprogramming with C++ Generic programming in OO Languages 30 Core Guidelines for Writting Clean, Safe, and Fast Code Reflective Metaprogramming in C++ Tag Dispatching","link":"/2022/11/06/Template-Metaprogramming-Type-Traits/"},{"title":"LLVM Series","text":"LLVM Series Callgraph LibCall Creation Calling Clang to compile a source codes. References clang-notes","link":"/2022/11/06/LLVM-Series/"},{"title":"Lambda Expression","text":"Lambda ExpressionInit CaptureThis feature is introduced since C++14, it also called generalized lambda capture. 12345678910111213141516171819202122232425262728293031namespace {class Widget {private: std::string name_; public: explicit Widget(std::string name) : name_(std::move(name)) {} friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Widget &amp;item) { os &lt;&lt; item.name_; return os; } void test_capture_member() { [name = std::ref(name_)] { std::cout &lt;&lt; &quot;name: &quot; &lt;&lt; name; }(); }};} // namespacevoid test_init_capture() { auto pw_outer = std::make_unique&lt;Widget&gt;(&quot;widget&quot;); // test init capture. [pw = std::move(pw_outer)] { std::cout &lt;&lt; *pw.get(); }(); [pw = std::make_unique&lt;Widget&gt;(&quot;widget2&quot;)] { std::cout &lt;&lt; *pw.get(); }(); auto pw = std::make_unique&lt;Widget&gt;(&quot;test&quot;); // test class member capture. pw-&gt;test_capture_member();} Captures apply only to non-static local variables (including parameters) visible in the scope wherethe lambda is created. So if you want to capture a class member, the original way is using a localvariable. For example: 12345678910111213141516namespace {class Widget {private: std::string name_; public: explicit Widget(std::string name) : name_(std::move(name)) {} void test_capture() { auto &amp;name = name_; [name] { std::cout &lt;&lt; name; }(); }};} // namespace Since C++14, we can use init capture feature for this situation. It means we can define a newvariable and initialize this local variable using class member during lambda capture. For example: 12345678910111213namespace {class Widget {private: std::string name_; // ... void test_capture() { [name = std::ref(name_)] { std::cout &lt;&lt; name; }(); }};} // namespace Please visit site for complete code Lambda Expression Testcase References Item 31: Avoid default capture modes, Effective Modern C++, Scott Meyer","link":"/2022/11/08/Lambda-Expression/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"CMake","slug":"CMake","link":"/tags/CMake/"},{"name":"Meta-Programming","slug":"Meta-Programming","link":"/tags/Meta-Programming/"},{"name":"LLVM","slug":"LLVM","link":"/tags/LLVM/"},{"name":"C++14","slug":"C-14","link":"/tags/C-14/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[],"pages":[]}