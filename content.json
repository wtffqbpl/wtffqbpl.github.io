{"posts":[{"title":"How To Use Hexo","text":"IntroductionThe combination of Hexo + GithubPages is an easier way to configure your own blog. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. StepsCreate a GitHub RepoYou should create a repo for your blog, and the repo name must be &lt;username&gt;.github.io. Init HexoThen, navigate to &lt;username&gt;.github.io directory, run the following command to init Hexo blog. 12# cd &lt;username&gt;.github.iohexo init Install DependenciesFinally, run the following command to finalize installing procedures. 1npm install Hexo Useful CommandsCreate a new postEnter &lt;username&gt;.github.io directory, and execute the following command for new page creation. If you haven’t specify layout, hexo will use the default layout for new page creation. The default layout is configured in _config.yml file, the keyword is default_layout. For more info, pleasesee chapter Writing. 12# hexo new [layout] &lt;title&gt;$ hexo new &quot;My New Post&quot; Run serverIf you want to preview your blog on your local machine, you can use following command to deploy your blog on your local machine. For more info, please see chapter Server. 1$ hexo server Generate static filesBefore you publish your blog to github pages, you should generate static files locally. If you use the github pages’s theme, you only need to configure wanted theme in your _config.yml file, and github will gengerate all static files before deploying. For more info, please see chapter Generating. 1$ hexo generate Deploy to Remote SitesAfter generating all static files, you can deploy your blog on GitHub pages. This command would create a master branch in your blog repo. So your github pages should be based on master branch. You can change the github pages’ branch in Settings-&gt;Pages-&gt;Branch. 1$ hexo deploy For more info, please see chapter Deployment. ThemesInstall ThemeI’d like to use hexo-theme-icarus theme. User should execute the following commands to configure icarus theme. hexo-theme-icarus 12npm install hexo-theme-icarushexo config theme icarus Hexo provides numerous themes, please see Hexo-Themes for more details. Change Your Personnel InfoUser should change the personnel info in _config.icarus.yml file. NotesAll blog data are listed in source/ directory. My source directory hierarchy is as follows: 123456789101112» tree source source├── _posts│ ├── How-To-Use-Hexo.md│ └── hello-world.md└── img ├── alipay-qrcode.jpg ├── logo.png ├── logo.svg └── wechat-qrcode.jpg2 directories, 6 files If you want to change the default logo logo.svg, you should put your own logo.svg in source/img/logo.svg. Besides, Mac user can use imagemagick tool for png to svg conversion. For more details, you can see imagemagick-homepage. After install imagemagick tool, you can execute the following commands to convert. 1convert logo.png logo.svg Add “Read More” tag for your postsThere are two ways to add this tag. First, you can add excerpt tag in your post, and add some introductions for posts. 12345title: New Articledate: 2022-11-12excerpt: Introductions---# Contents ... add &lt;!-- more --&gt; line after introductions in your posts. References PicGo-Configuration Using-ssh-instead-of-http-in-config.yml-file Hexo-Doc Hexo-theme-icarus Hexo-theme-icarus-doc","link":"/2022/10/30/How-To-Use-Hexo/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/10/30/hello-world/"},{"title":"CMAKE---Multiple directories","text":"OverviewCMake is a directory-based project management tool. If your project has multiple directories, more CMakeLists.txt files should be created in your project directories. SituationAs the following directories, each directory is a standalone module. For example: the root target has its own source file(s) in ${ROOT}/src directory. hello_object_lib is a OBJECT target, and it has its own including paths. So we use a CMakeLists.txt file for target management. hello_shared_lib is a SHARED library target, the root project will link this shared library or provide for other projects. hello_static_lib is a STATIC library target, this target will generate a static library file for other projects. 12345678910111213141516171819202122232425262728tree.├── CMakeLists.txt├── hello_object_lib│ ├── CMakeLists.txt│ ├── inc│ └── src│ └── main.cc├── hello_shared_lib│ ├── CMakeLists.txt│ ├── include│ │ └── hello│ │ └── hello.hpp│ └── src│ ├── hello.cc│ ├── internal.cc│ └── internal.hpp├── hello_static_lib│ ├── CMakeLists.txt│ ├── include│ │ └── hello│ │ └── hello.hpp│ └── src│ ├── hello.cc│ ├── internal.cc│ └── internal.hpp└── src └── main.cc The content of root CMakeLists.txt is as follows. Each sub-directory should be added in this CMakeLists.txt. In this CMakeLists.txt, we define a executable target multiple_exec, all of the other targets will be linked to this executable target. There’s a difference should be noticed. OBJECT target cannot be linked into other targets using target_link_libraries command before CMake V3.12. So if you use the older CMake version, you should use the 12345678910111213141516171819202122cmake_minimum_required(VERSION 3.21)project(multiple_dirs VERSION 1.0 DESCRIPTION &quot;Multiple directory project&quot; LANGUAGES CXX)# Add subdirectories with examples.add_subdirectory(hello_object_lib)add_subdirectory(hello_shared_lib)add_subdirectory(hello_static_lib)# add an example executableadd_executable(multiple_exec)# add sources to the example executabletarget_sources(multiple_exec PRIVATE src/main.cc)# link librariestarget_link_libraries( multiple_exec PRIVATE hello_object_target hello_shared_target hello_static_target) References My-Advanced-CMake-Repo","link":"/2022/10/31/CMAKE-Multiple-directories/"},{"title":"Template Metaprogramming---Type Traits","text":"The Aims How to implement and how to use Exploration of the standard set of type traits Focus on techniques for implementing type traits Remove some of the mystique that still surrounds template metaprogramming. Practical advice from a regular user. So you can more readily use the standard set and implement your own whenneeded. What is Meta-Programming In general, when programs treat programs as data Could be other programs or itself Could be at “compile time” or “run time” We will discuss compile time metaprogramming in C++ Wide array of current techniques, but still considered a niche This two-part tutorial helps shed light on a very few essential ideoms Why Care About Metaprogramming (and type traits in particular) Each new standard library employs more metaprogramming techniques Some requirements are impossible without advanced techniques(e.g., std::optional) Many third party libraries, not just Boost Tools and idioms have become well developed, no longer black magic, limited to STL and Boost. All C++ programmers should understand the basics. Any library developer should understand a good bit more C++20 - concepts and independent requires expressions It’s kind of a paradigm shift, there are a lot of things that make metaprogramming more look likeregular functional programming. Meta-Functions A meta-function is not a function but a class/struct Meta-functions are not part of the language and have no formal language support They exist as an idiomatic use of existing language features Their use is not enforced by the language Their use is dictated by convention C++ community has created common “standard” conventions The Definition of meta-function Technically, a class with zero+ template parameters and zero+ return types and values Convention is that a meta-function should return one thing, like a regular function Convention was developed over time, so plenty of existing examples that do not follow this convention More modern meta-functions do follow this convention Return From a Meta-Function Expose a public value “value” 1234template &lt;typename T&gt;struct TheAnswer { static constexpr int value = 42;}; Expose a public type “type” 1234template &lt;typename T&gt;struct Echo { using type = T;}; Meta-functions yield back some types to you. Value Meta-functions Simple regular function: identity This is a very simple regular function. 123int int_identity(int x) { reutrn x; }assert(42 == int_identity(42)); The Simple Meta-Function: identity 123456template &lt;int X&gt;struct IntIdentity { static constexpr int value = X;};static_assert(42 == IntIdentity&lt;42&gt;::value) Generic Identity Function 12345678template &lt;typename T&gt;T identity(T x) { return x; }// Returned type will be intassert(42 == identity(42));// Returned type will be unsigned long longassert(42ull == identity(42ull)); Generic Identity Meta-Function 12345678910template &lt;typename T, T Value&gt;struct ValueIdentity { static constexpr T value = Value;};// The type of value will be intstatic_assert(42 == ValueIdentity&lt;int, 42&gt;::value);// The type of value will be unsigned long longstatic_assert(ValueIdentity&lt;unsigned long long, 42ull&gt;::value == 42ull); Generic Identity Meta-Function (C++17) Template accepts non-type template parameter since C++17. 12345678910template &lt;auto X&gt;struct ValueIdentity { static constexpr auto value = X;};// The type of value will be intstatic_assert(42 == ValueIdentity&lt;42&gt;::value);// The type of value will be unsigned long longstatic_assert(42ull == ValueIdentity&lt;42ull&gt;::value); Two forms of Sum Function 1234567891011121314template &lt;typename X, typename Y&gt;constexpr auto sum(X x, Y y) { return x + y; }// Return type will be unsigned long longassert(42ull == sum(30, 12ull));// It takes two separate non-type template parameterstemplate &lt;auto X, auto Y&gt;struct Sum { static constexpr auto value = X + Y;};// Return type will be unsigned long longstatic_assert(42ull == Sum&lt;30, 12ull&gt;::value); Type Meta-Functions Type meta-functions just like a workhorse (especially will the advent of constexpr) which manipulatetypes. “Returns” a type. This is a type meta-function demo 12template &lt;typename T&gt;struct TypeIdentity { using type = T; }; C++20 introduces std::type_identity Calling Type Meta-Functions12ValueIdentity&lt;42&gt;::value;TypeIdentity&lt;int&gt;::type; Typename Dance 1typename TypeIdentity&lt;T&gt;::type; Convenience Calling Conventions Value meta-functions use variable templates ending with “_v”. 1234567891011121314template &lt;auto X&gt;struct ValueIdentity { static constexpr auto value = X;};// variable template// This is a convenient way to call a value meta-functions using// variable template.template &lt;auto X&gt;inline constexpr auto ValueIdentity_v = ValueIdentity&lt;X&gt;::value;static_assert(42 == ValueIdentity&lt;42&gt;::value);static_assert(42 == ValueIdentity_v&lt;42&gt;); Type Meta-Functions use alias templates ending with “_t”. Typename Dance. 1234template &lt;typename T&gt;using TypeIdentity_t = typename TypeIdentity&lt;T&gt;::type;static_assert(std::is_same_v&lt;int, TypeIdentity_t&lt;int&gt;&gt;); These calling conventions are easier to use. But each one must be explicitly handwritten. A meta-convention to get around that which I may get to if time for bonus material. Type TraitsSome Useful Meta-Functionsstd::integral_constantA very useful meta-function. It allows us to wrap a constant with its type. 123456789101112131415template &lt;class T, T v&gt;struct integral_constant { static constexpr T value = v; using value_type = T; using type = integral_constant&lt;T, v&gt;; constexpr operator value_type() const noexcept { return value; } // this is a functor, a call operator. constexpr value_type operator()() const noexcept { return value; }}; std::bool_constantThis is Convenient helpers. 12345678template &lt;bool B&gt;using bool_constant = integral_constant&lt;bool, B&gt;;// alias templates// this is equivalent to integral_constant&lt;bool, true&gt;.using true_type = bool_constant&lt;true&gt;;// this is equivalent to integral_constant&lt;bool, false&gt;.using false_type = bool_constant&lt;false&gt;; true_type and false_type are going to be meta-functions. They are called nullary meta-functionsbecause they have no parameters. 12true_type::value;false_type::value; Standard Type Trait RequirementsCpp17 Unary Type TraitCpp20 introduces very different meta-programming techniques. For a unary type trait in the standard library which is what we’re got which is what we are talkingabout. Unary type trait in the standard library it has a class template of one template typeargument Cpp17UnaryTypeTrait Class Template One template type argument* Cpp17DefaultConstructible Cpp17CopyConstructible Publicly and unambiguously derived from a specialization of std::integral_constant.All the unary type traits have to derive from integral_constant. The member names of the base characteristic shall not be hidden and shall be unambiguously availableBasically, this means if you inherit from it you can’t hide any of that stuff, you got to let allthat stuff be available publicly. Cpp17BinaryTypeTraitThis is an exactly same thing with Cpp17UnaryTypeTrait except Cpp17BinaryTypeTrait has twotemplate type argument*. Cpp17TransformationTrait Class Template One template type argument* Define a publicly asccessible nested type name type. No default/copy constructible requirement No inheritance requirement Specializationis_void (Unary Type Trait) Value meta-function: is the type void? yields true_type or false_type Specialization Primary template: general case 12template &lt;typename T&gt;struct is_void : std::false_type {}; Specialization: special case(s) 12345678910// The empty angle brackets mean it's an explicit full// specialization, and then we take the type that we// are specializing for. And we put it in right place.// In this case, we are going to return true and so// these static_assert.template&lt;&gt;struct is_void&lt;void&gt; : std::true_type {};static_assert(is_void&lt;void&gt;{});static_assert(not is_void&lt;int&gt;{}); Why does is void reutrn true type false type instead of true false values? The reason because it is a meta-function returning the true type(the actual type of it).First of all, the is_void is inherited from integral_constant. false_type is just integralconstant bool false. true_type is just integral_constant bool true. The standard says thatunary meta-functions must inherit from one of those.And the reason because if all we did was just return a true value where is a is_void is inherit from a true_type, and true_type is already having a type. static_assert(is_void&lt;void&gt;{}, the curly bracket, that is instantiating one of those things and itimplicit conversion operator to turn it into a true. Is void const void? Is void volatile void? is_void is in primary type categories. Yes, the standard says void &amp; void const &amp; void volatile &amp; void const volatile are all void. cv stands for const volatile For any given type T, the result of applying one of these templates to T and to cv T shall yieldthe same result. The definition of is_void 12345678910111213141516171819// The primary templatetemplate &lt;typename T&gt; struct is_void : std::false_type {};// specialization for void.template&lt;&gt;struct is_void&lt;void&gt; : std::true_type {};// specialization for void consttemplate&lt;&gt;struct is_void&lt;void const&gt; : std::true_type {};// specialization for void volatiletemplate&lt;&gt;struct is_void&lt;void volatile&gt; : std::true_type {};// specialization for void const volatiletemplate&lt;&gt;struct is_void &lt;void const volatile&gt; : std::true_type {};// The standard mandates this as well.template &lt;typename T&gt;inline constexpr bool is_void_v = is_void&lt;T&gt;::value; remove_const (Transformation Trait)There are three type traits: unary traits/binary traits/transformation traits. remove_const isa transformation traits. transformation traits are what they call they are type meta-functions. Formal Definition The member typedef type names the same type as T except that any top-level const-qualifier hasbeen removed. The top-level qualifier, like volatile/const which are attached to the type itself. 123456789101112remove_const&lt;int&gt; -&gt; intremove_const&lt;const int&gt; -&gt; intremove_const&lt;const volatile int&gt; -&gt; volatile intremove_const&lt;int *&gt; -&gt; int *remove_const&lt;cont int *&gt; -&gt; const int *// this because pointer to a constant,// it is not a const pointer.remove_const&lt;int const * const&gt; -&gt; int const *remove_const&lt;int * const&gt; -&gt; int * The definition of remove_const 1234567891011121314template &lt;typename T&gt;struct TypeIdentity { using type = T; };// primary template, do nothing if no consttemplate &lt;typename T&gt;struct remove_const : TypeIdentity&lt;T&gt; {};// Partial specialization, when detect consttemplate &lt;typename T&gt;struct remove_const&lt;T const&gt; : TypeIdentity&lt;T&gt; {};// Standar mandated convenience aliastemplate &lt;typename T&gt;using rmeove_const_t = typename remove_const&lt;T&gt;::type; Contains const so the partial specialization will match. 12template &lt;typename T&gt;struct remove_const&lt;T const&gt; : TypeIdentity&lt;T&gt; {}; The const is explicitly matched so the part remaining to match with the “T” is int volatile conditionalThis is basically think of it as like an if statement in regular programming. Some conditions itreturns T, else return F. In this you can read it, if the bool condition is true, return T, else return F. 1234567891011121314151617template &lt;typename T&gt;struct TypeIdentitiy { using type = T; };// This partial specialization means condition is true,// then returns T.template &lt;bool Condition, typename T, typename F&gt;struct conditional : TypeIdentity&lt;T&gt; {};// This partial specialization means condition is false,// then conditional returns F.template &lt;typename T, typename F&gt;struct conditional&lt;false, T, F&gt; : TypeIdentity&lt;F&gt; {};static_assert(is_same_v&lt;int, conditional_t&lt;is_void&lt;void&gt;::value, int, long&gt;);static_assert(is_same_v&lt;long, conditional_t&lt;is_void&lt;char&gt;::value, int, long&gt;); Not all the type traits can be implemented by c++, the compiler has way more information aboutthe type system and about what’s going on than it is exposed to the programmer through thelanguage. Type traits can be implemented by intrinsics, and compiler can be more efficient for intrinsicsprocessing. is_union should be supported by compiler. Primary Type CategoriesThere are 14 primary type categories. 1234567is_void is_classis_null_pointer is_functionis_integral is_pointeris_floating_point is_lvalue_referenceis_array is_rvalue_referenceis_enum is_member_object_pointeris_union is_member_function_pointer All are to have base characteristic of either true_type or false_type. All should yield the same result in light of cv(const volatile) qualifiers. is_null_pointer12345678910111213141516171819template &lt;typename T&gt;struct is_null_pointer : std::false_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t const&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t volatile&gt; : std::true_type {};template &lt;&gt;struct is_null_pointer&lt;std::nullptr_t const volatile&gt; : std::true_type {};// The standard mandates this as well...template &lt;typename T&gt;inline constexpr bool is_null_pointer_v = is_null_pointer&lt;T&gt;::value; is_floating_pointfloat/double/long double requires 12 specializations. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename T&gt; struct is_floating_point : std::false_type {};// float typetemplate &lt;&gt;struct is_floating_point&lt;float&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;float const volatile&gt; : std::true_type {};// double typetemplate &lt;&gt;struct is_floating_point&lt;double&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;double const volatile&gt; : std::true_type {};// long double typetemplate &lt;&gt;struct is_floating_point&lt;long double&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double const&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double volatile&gt; : std::true_type {};template &lt;&gt;struct is_floating_point&lt;long double const volatile&gt; : std::true_type {};// for convenience usetemplate &lt;typename T&gt;inline constexpr bool is_floating_point_v = is_floating_point&lt;T&gt;::value; is_integral Five standard signed integer types: signed char, short int, int, long int, long long int. Implementation defined extended signed integer types. Corresponding, but different, unsigned integer types. char, char8_t, char16_t, char32_t, wchar_t. bool Requires 16 * 4 = 54 specializations. Meta-Function Abstractions We would have reached for this long before now with regular/normal programming. Treat meta-function programming like regular programming because, well, that’s what it is. Step back to the land of regular functions. Pretend we needed to implement these same ideas with strings instead of types. The regular type of is_void 1234567bool is_void(std::string_view s) { return s == &quot;void&quot; || s == &quot;void const&quot; || s == &quot;void volatile&quot; || s == &quot;void const volatile&quot; || s == &quot;void volatile const&quot;;} A new version of type traits(A Step in the right direction) 123456789101112131415161718192021222324252627282930std::string_view remove_cv(std::string_view);bool is_void(std::string_view s) { return remove_cv(s) == &quot;void&quot;;}bool is_null_pointer(std::string_view s) { return remove_cv(s) == &quot;std::nullptr_t&quot;;}bool is_floating_point(std::string_view input) { auto const s = remove_cv(input); return s == &quot;float&quot; || s == &quot;double&quot; || s == &quot;long double&quot;;}std::string_view strip_signed(std::string_view);bool is_integral(std::string_view input) { auto const s = strip_signed(remove_cv(input)); return s == &quot;bool&quot; || s == &quot;char8_t&quot; || s == &quot;char16_t&quot; || s == &quot;char32_t&quot; || s == &quot;wchar_t&quot; || s == &quot;char&quot; || s == &quot;short&quot; || s == &quot;int&quot; || s == &quot;long&quot; || s == &quot;long long&quot;;} We already have remove_const, we also need remove_volatile, compose them to get remove_cv. remove_volatile Formal Definition The member typedef type names the same type as T except that any top-level volatile-qualifier hasbeen remove. 123456789101112131415template &lt;typename T&gt;struct TypeIdentity { using type = T; };// Primary template, do nothing if no volatiletemplate &lt;typename T&gt;struct remove_volatile : TypeIdentity&lt;T&gt; {};// Partial specialization, when detect volatiletemplate &lt;typename T&gt;strut remove_volatile&lt;T volatile&gt; : TypeIdentity&lt;T&gt; {};// Standard mandated convenience alias.template &lt;typename T&gt;using remove_volatile_t = typename remove_volatile&lt;T&gt;::type; remove_cv Formal Definition The member typedef type names the same type as T except that any top-level cv-qualifier hasbeen removed. 123456789101112131415// template &lt;typename T&gt;// using remove_cv = remove_const&lt;typename remove_volatile&lt;T&gt;::type&gt;;// alias templatetemplate &lt;typename T&gt;using remove_cv = remove_const&lt;remove_volatile_t&lt;T&gt;&gt;;// remove_volatile_t&lt;T&gt; is the same thing with typename// remove_volatile&lt;T&gt;::type.// Here we don't use remove_const_t, this because we want// remove_cv to be a meta-function.// If we use remove_const_t, remove_cv is just a type either// meta-function.template &lt;typename T&gt;using remove_cv_t = typename remove_cv&lt;T&gt;::type; Eg. remove_cv&lt;int const volatile&gt; 12345678// Removing volatile, then consttemplate &lt;typename T&gt;using remove_cv = remove_const&lt;remove_volatile_t&lt;T&gt;&gt;;// remove_cv&lt;int const volatile&gt;// remove_const&lt;remove_volatile_t&lt;int const volatile&gt;&gt;// remove_const&lt;typename remove_volatile&lt;int const volatile&gt;::type&gt;// remove_const&lt;int const&gt; Eg. remove_ct_t&lt;int const volatile&gt; 1234567template &lt;typename T&gt;using remove_cv_t = typename remove_cv&lt;T&gt;::type;// remove_cv_t&lt;int const volatile&gt;// typename remove_cv&lt;int const volatile&gt;::type// typename remove_const&lt;int const&gt;::type// int is_same12345678910111213template &lt;typename T1, typename T2&gt;strut is_same : std::false_type {};// Partial specialization --- when they are both the same.// angle bracketstemplate &lt;typename T&gt;struct is_same&lt;T, T&gt; : std::true_type {};// When T1 and T2 are same, then is_same matches this partial// specialization version. Otherwise, is_same matches the// false_type version. Compiler only choose the best match version.template &lt;typename T1, typename T2&gt;constexpr bool is_same_v = is_same&lt;T1, T2&gt;::value; Examples static_assert(not is_same_v&lt;int, unsigned&gt;) T1 = int, T2 = unsigned, primary template matches. No way to make T to matchspecialization. static_assert(is_same_v&lt;int, int&gt;) T1 = int, T2 = int, primary template matches, T = int – specialization matches is_same_rawThis is not standard type traits, but it is kind of useful. Take two types, and remove eachcv qualifiers and then compares them. If the two types are the same after removing thesecv qualifiers, then I’m treat them the same. So this might be helpful considering thatall of our type traits want us to remove both the const and the volatile qualifiers. 12345template &lt;typename T1, typename T2&gt;using is_same_raw = is_same&lt;remove_cv_t&lt;T1&gt;, remove_cv_t&lt;T2&gt;&gt;;template &lt;typename T1, typename T2&gt;constexpr bool is_same_raw_v = is_same_raw&lt;T1, T2&gt;::value; is_floating_point: reduxThis is using alias template. 12345template &lt;typename T&gt;using is_floating_point = std::bool_constant&lt; is_same_raw_v&lt;float, T&gt; || is_same_raw_v&lt;double, T&gt; || is_same_raw_v&lt;long double, T&gt;&gt;; is_integral: redux123456789101112131415161718template &lt;typename T&gt;using is_integral = std::bool_constant&lt; is_same_raw_v&lt;bool, T&gt; || is_same_raw_v&lt;char, T&gt; || is_same_raw_v&lt;char8_t, T&gt; || is_same_raw_v&lt;char16_t, T&gt; || is_same_raw_v&lt;char32_t, T&gt; || is_same_raw_v&lt;wchar_t, T&gt; || is_same_raw_v&lt;signed char, T&gt; || is_same_raw_v&lt;short, T&gt; || is_same_raw_v&lt;int, T&gt; || is_same_raw_v&lt;long, T&gt; || is_same_raw_v&lt;long long, T&gt; || is_same_raw_v&lt;unsigned char, T&gt; || is_same_raw_v&lt;unsigned short, T&gt; || is_same_raw_v&lt;unsigned int, T&gt; || is_same_raw_v&lt;unsigned long, T&gt; || is_same_raw_v&lt;unsigned long long, T&gt;&gt;; It might be implemented using parameter pack. is_type_in_pack is a meta-function, it takes a type and ti take a list of bunch of other types.Adn is_type_in_pack will biscally returned true if that type was anywhere in that list. 12345678910111213template &lt;typename TargetT, typename ...Ts&gt;using is_type_in_pack = ...;template &lt;typename T&gt;using is_integral = is_type_inpack&lt;remove_cv_t&lt;T&gt;, bool, char, char8_t, char16_t, char32_t, wchar_t, signed char, unsigned char, signed short, unsigned short, signed int, unsigned int, signed long, unsigned long, signed long long, unsigned long long&gt;; is_arrayThe definition of is_array. 12345678910template &lt;typename T&gt;struct is_array : std::false_type {};// inbounded arraytemplate &lt;typename T, std::size_t N&gt;struct is_arrya &lt;T[N]&gt; : std::true_type {};// unbounded arraytemplate &lt;typename T&gt;struct is_array&lt;T[]&gt; : std::true_type {}; Some examples. 1234567static_assert(is_array,int[5]&gt;);// T = int[5] - primary template matches// T = int, N = 5 - first specialization matches// no way to form T to match second sepcializationstatic_assert(is_array&lt;int[]&gt;);// T = int[] == primary template matches is_pointer1234567891011121314namespace detail {// Primary template - most things are not pointerstemplate &lt;typename T&gt;struct is_pointer_impl : std::false_type {};// When we have a pointertemplate &lt;typename T&gt;struct is_pointer_impl&lt;T *&gt; : std::true_type {};} // end of namespace detail// alias template template &lt;typename T&gt;using is_pointer = detail::is_pointer_impl&lt;remove_cv_t&lt;T&gt;&gt;; is_unionThis meta-function is actually impossible to implement without support from the compiler. Both clangand gcc provide this particular compiler intrinsic to determine if a type is a union. 12template &lt;typename T&gt;using is_union = std::bool_constant&lt;__is_union(T)&gt;; is_class_or_unionWhat do we know about unions and classes that is unique to those two types? They can have members. Devise a way to detect if a type can have a member. How can you tell if a class has a member? The syntax for a pointer-to-member is valid for any class, even without any members. Eg. int* is a valid pointer type, but does not have to point to anything. meta-programming is aimed todeal with types, not the data. int Foo::* is a member pointer type, does not have to point to anything. 12345678910// An empty struct, with no members of any kindstruct Bar {};// BarIntObjectMemPtr is an alias for a type that is a// pointer to a member of class Bar, where the member// is an int.using BarintObjectMemPtr = int Bar::*;// This, however, generates a hard compiler errorusign LongIntObjectMemPtr = ing long::*; Funciton Overload Resolution123456789101112namespace detail {std::true_type is_nullptr(std::nullptr_t);// ... it will match anything. But it is the least priority.// It will only ever be used if nothing else matches. It'll// only be used if it's the only one that matches.std::false_type is_nullptr(...);} // end of namespace detailtemplate &lt;typename T&gt;using is_null_pointer = decltype(detail::is_nullptr(std::devlval&lt;T&gt;())); 123456static_assert(not is_null_pointer&lt;int&gt;::value);// This only match the second one.static_assert(is_null_pointer&lt;std::nullptr_t&gt;::value);// This can match two versions of `is_nullptr`, but overload// resolution will choose the first one, because the first// one is the best match. Another case. 1234567891011121314template &lt;typename T&gt;struct TypeIdentity { using type = T; };namespace detail {template &lt;typename T&gt;std::true_type isconst(TypeIdentity&lt;T const&gt;);template &lt;typename T&gt;std::false_type isconst(TypeIdentity&lt;T&gt;);} // end of namespace detailtemplate &lt;typename T&gt;using is_const = decltype(detail::isconst(std::declval&lt;TypeIdentity&lt;T&gt;&gt;())); This uses technique called Tag Dispatch. Tag Dispatch is where we are creating a type that isjust being used as a tag. TypeIdentity takes no space, and it is very efficient to pass these guys around. SFINAE (Substitution Failure Is Not An Error)12345template &lt;typename T&gt;std::true_type can_have_pointer_to_member(int T::*);template &lt;typename T&gt;std::false_type can_have_pointer_to_member(...); is_classAlmost always implemented as compiler intrinsic. Because compiler is much faster dealing withintrinsics than dealing with even the simplest template stuff. Without the support of compiler, itis kind of impossible to distinguish between union and non-union class type. We have is_union (with help from the compiler) The definition is: 1234567891011121314namespace detail {template &lt;typename T&gt;std::bool_constant&lt;not std::is_union_v&lt;T&gt;&gt;is_class_or_union(int T::*);// We only want to use the return type of `is_class_or_union`// function. So we don't need to create implementation for this// function.template &lt;typename T&gt;std::false_type is_class_or_union(...);}template &lt;typename T&gt;using is_class = decltype(detail::is_class_or_union&lt;T&gt;(nullptr)); Implement is_class using constexpr. 12345678910111213namespace detail {template &lt;typename T&gt; constexpr bool is_class_or_union(int T::*) { return not std::is_union&lt;T&gt;::value;}template &lt;typename T&gt; constexpr bool is_class_or_union(...) { return false;}} // end of namespace detailtemplate &lt;typename T&gt;using is_class = std::bool_constant&lt;detail::is_class_or_union&lt;T&gt;(nullptr)&gt;; 123template &lt;typename T&gt;using is_const = decltype(detail::isconst(std::declval&lt;TypeIdentity&lt;T&gt;&gt;())); decltype — tells you to pretend that compiler will evaluate this expression, and give me theresult the type that you would get from the evaluated expression. declval — is there so you can grab a reference to any type. It just gives you a referenceto something as if you had created one as if you had one. So it just declaration, it’s there’s noimplementation. is_in_pack1234567891011121314151617// Template declaration, with no definitiontemplate &lt;typename TargetT, typename... Ts&gt;struct IsInPack;// Base case --- no more elementstemplate &lt;typename TargetT&gt;struct IsInPack&lt;TargetT&gt; : std::false_type {};// NOTES: is_in_pack uses partial specialization to match// the two same types. If the first one matches the target,// we are done.template &lt;typename TargetT, typename... Ts&gt;struct IsInpack&lt;TargetT, TargetT, Ts...&gt; : std::true_type {};// Otherwise, check the remaining ones.template &lt;typename TargetT, typename T, typename... Ts&gt;struct IsInpack&lt;TargetT, T, Ts...&gt; : IsInPack&lt;Target, Ts...&gt; {}; Examples 12static_assert(IsInPack&lt;int, double,char,int,float&gt;::value);static_assert(not IsInPack&lt;long, double,char,int,float&gt;::value); The version of using is_base_of. 123456789101112namespace detail {template &lt;typename T&gt;struct TypeIdentitiy { using type = T; };template &lt;typename... Ts&gt;struct IsInPackImpl : TypeIdentity&lt;Ts&gt;... {};tmeplate &lt;typename TargetT, typename... Ts&gt;using IsInpack = std::is_base_of&lt; TypeIdentity&lt;TargetT&gt;, detail::IsInPackImpl&lt;Ts...&gt;&gt;;} // end of namespace detail Examples 12static_assert(IsInPack&lt;int, double,char,int,float&gt;::value);static_assert(not IsInPack&lt;long, double,char,int,float&gt;::value); is_base_ofIf Derived is derived from Base or if both are the same non-union class (in both casescv-qualification), provides the member constant value equal to true. Otherwise value is false. The possible definition of is_base_of is as follows: 12345678910111213141516171819202122namespace detail {template &lt;typename B&gt;std::true_type test_pre_ptr_convertible(const volatile B*);template &lt;typename&gt;std::false_type test_pre_ptr_convertible(const volatile void*);template &lt;typename, typename&gt;auto test_pre_is_base_of(...) -&gt; std::true_type;template &lt;typename B, typename D&gt;auto test_pre_is_base_of(int) -&gt; decltype(test_pre_ptr_convertible&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));} // end of namespace detailtemplate &lt;typename Base, typename Derived&gt;struct is_base_of : std::integral_constant&lt; bool, std::is_class&lt;Base&gt;::value &amp;&amp; std::is_class&lt;Derived&gt;::value &amp;&amp; decltype(details::test_pre_is_base_of&lt;Base, Derived&gt;(0))::value &gt; {}; Learning materials. Template Metaprogramming: Type Traits Part I Template Metaprogramming: Type Traits Part II Modern Template Metaprogramming: A Compendium, Part I, Walter E. Brown, CppCon 2014,Link: Part IPart II References Modern C++ Design About C++ Template Metaprogramming Template Metaprogramming with C++ Generic programming in OO Languages 30 Core Guidelines for Writting Clean, Safe, and Fast Code Reflective Metaprogramming in C++ Tag Dispatching","link":"/2022/11/06/Template-Metaprogramming-Type-Traits/"},{"title":"LLVM Series","text":"LLVM Series Callgraph LibCall Creation Calling Clang to compile a source codes. References clang-notes","link":"/2022/11/06/LLVM-Series/"},{"title":"Lambda Expression","text":"Lambda ExpressionInit CaptureThis feature is introduced since C++14, it also called generalized lambda capture. 12345678910111213141516171819202122232425262728293031namespace {class Widget {private: std::string name_; public: explicit Widget(std::string name) : name_(std::move(name)) {} friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Widget &amp;item) { os &lt;&lt; item.name_; return os; } void test_capture_member() { [name = std::ref(name_)] { std::cout &lt;&lt; &quot;name: &quot; &lt;&lt; name; }(); }};} // namespacevoid test_init_capture() { auto pw_outer = std::make_unique&lt;Widget&gt;(&quot;widget&quot;); // test init capture. [pw = std::move(pw_outer)] { std::cout &lt;&lt; *pw.get(); }(); [pw = std::make_unique&lt;Widget&gt;(&quot;widget2&quot;)] { std::cout &lt;&lt; *pw.get(); }(); auto pw = std::make_unique&lt;Widget&gt;(&quot;test&quot;); // test class member capture. pw-&gt;test_capture_member();} Captures apply only to non-static local variables (including parameters) visible in the scope wherethe lambda is created. So if you want to capture a class member, the original way is using a localvariable. For example: 12345678910111213141516namespace {class Widget {private: std::string name_; public: explicit Widget(std::string name) : name_(std::move(name)) {} void test_capture() { auto &amp;name = name_; [name] { std::cout &lt;&lt; name; }(); }};} // namespace Since C++14, we can use init capture feature for this situation. It means we can define a newvariable and initialize this local variable using class member during lambda capture. For example: 12345678910111213namespace {class Widget {private: std::string name_; // ... void test_capture() { [name = std::ref(name_)] { std::cout &lt;&lt; name; }(); }};} // namespace Please visit site for complete code Lambda Expression Testcase References Item 31: Avoid default capture modes, Effective Modern C++, Scott Meyer","link":"/2022/11/08/Lambda-Expression/"},{"title":"C++ Lambda Idioms","text":"The closure type for a lambda-expression has a public inline function call operator(for a non-generic lambda) or function call operator template (for a generic lambda) whose parameters and return type are described by the lambda-expression‘s parameter-declaration-clause and trailing-returning-type respectively, and whose template-parameter-list consists of the specified template-parameter-list, if any. The requires-clause of the function call operator template is the requires-clause immediately following &lt; template-parameter-list &gt;, if any. The trailing requires-clause of the function call operator or operator template is the requires-clause of the lambda-declarator, if any. 123[](const Person &amp;lhs, const Person &amp;rhs) { return lhs.name &lt; rhs.name;}; The version after compiled. Lambda has no default noexcept attribute, if you want the call operator to be noexcept, you have to write noexcept keyword. 12345678910111213141516struct __lambda_1 { inline bool operator()(const Person &amp;lhs, const Person &amp;rhs) const { return lhs.name &lt; rhs.name; }; // not default-constructible! __lambda_1() = delete; // not assignable! __lambda_1&amp; operator=(const __lambda_1&amp;) = delete;};// call a lambda// this instance is auto-generated by the// compiler, so no error.__lambda_1(); Do not capture anything.Lambdas do not have a state, so if the [] is empty, the lambda have an implicit conversion to raw function pointer. So we have some kind of legacy call here like C APIs do that very often they take a raw function pointer. 1234567891011void legacy_call(int(*f)(int)) { std::cout &lt;&lt; f(7) &lt;&lt; '\\n';}int main() { // OK, implicit conversion to function pointer. legacy_call([](int i) { return i * i; }); // prints 49 } Something like this: __func_type. 1234567891011121314151617181920212223struct __lambda_1 { inline bool operator()(const Person&amp; lhs, const Person&amp; rhs) const { return lhs.name &lt; rhs.name; }; // not default-constructible __lambda_1() = delete; // not copyable or assignable! __lambda_1&amp; operator=(const __lambda_1&amp;) = delete; using __func_type = bool(*)(const Person&amp;, const Person&amp;); inline operator __func_type() const noexcept { return &amp;__invoke; } private: static inline bool __invoke(const Person&amp; lhs, const Person&amp; rhs) { return lhs.name &lt; rhs.name; }}; Idiom 1: Unary Plus TrickDO NOT USE THIS IN PRODUCTION CODE. It’s kind of really interesting it teaches us something about lambda does work. We’ve already known that no-capturing lambda would implicitly convert to function pointer but what if we need explicit conversion to function pointer? 12345678910111213int main() { // this will introduce error since compiler cannot // deduce auto * type from i * i. auto *fptr = [](int i) { return i * i; }; // So we can use static_cast for explicitly casting. auto *fptr = static_cast&lt;int(*)(int)&gt;([](int i) { return i * i; }); // auto *fptr = +[](int i) { return i * i; }} The unary operator is obviously not defined for lambdas. However, the unary plus operator is defined for pointers including pointers to function. So if the compiler sees the unary plus operator, it says okay well that only works for pointers, therefore I’m going to implicitly convert this to a pointer. So your lambda is going to be implicitly converted to function pointer, and then a unary plus operator is going to be applied to that function pointer. And what does the unary plus operator do? When it applies to a pointer, nothing will do exactly. So all it does is it’s going to static_cast the lambda to a function pointer. Lambda CapturesCapture is when you capture a variable from the scope where the lambda expression is. So it means the lambda now has states. Capture by Value123int i = 0;int j = 0;auto f = [=] { reutrn i == j; }; After compiled: 123456789101112struct __lambda_2 { __lambda_2(int i, int j) : __i(i), __j(j) {} inline bool operator()() const { return __i == __j; } private: int __i; int __j;};__lambda_2(i, j); When the lambda captures two variables i and j, then compiler is going to add two private members data non-static data members to your closure type, and it’s going to initialize those data members with the values of the variables that you have captured. For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified. Capture by ReferenceWhen you capture by reference. 123int i = 0;int j = 0;auto f = [&amp;] { reutrn i == j; }; After compiled: 123456789101112struct __lambda_2 { __lambda_2(int &amp;i, int &amp;j) : __i(i), __j(j) {} inline bool operator()() const { return __i == __j; } private: int &amp;__i; int &amp;__j;};__lambda_2(i, j); When the lambda captures two variables i and j by reference, then compiler will add two private reference members. An entity is captured by reference if it is implicitly or explicitly captured but not captured by copy. It is unspecified whether additional unnamed non-static data members are declared in the closure type for entities captured by reference. If declared, such non-static data member shall be of literal type. Capture this12345678910struct X { void printAsync() { callAsync([this] { std::cout &lt;&lt; i &lt;&lt; '\\n'; }); } private: int i = 42;}; After compiled: 1234567891011121314151617struct X { void printAsync() { struct __lambda_3 { __lambda_3(X* _this) : __this(_this) {} void operator()() const { std::cout &lt;&lt; __this-&gt;i &lt;&lt; '\\n'; } private: X* __this; }; callAsync(__lambda_3(this)); } private: int i = 42;}; If you capture this, then you get to call members and member functions that object that you are in so that you can have lambda inside a member function of a class and just naturally refer to other members of that class inside that. Lambda Capture GotchasOne really important thing is that you can only capture local variables. For example, you can not capture the static variable i. 123456789int main() { static int i = 42; // This capture fails since lambda cannot capture // non-static variables. auto f = [=] { ++i; }; f(); return i; // return 43!} You actually don’t capture global variable, you are just accessing it. For example, the code is as follows, 12345678int i = 42;int main() { auto f = [] { ++i; }; f(); return i; // return 43!} You also don’t capture variables even if they are local if the lambda doesn’t ODR use them. You only capture the things that are ODR used inside the lambda. ODR are used is kind of a term from the standards you can again look it up what it means exactly. Such as the following case, the lambda expression uses constexpr variable. Because the constexpr is a compile-time expression that is not an ODR use of the variable, that means you don’t have to capture I. So again, the capture is empty, but you can use i for printing. However, if you want to take the address of that variable 12345678910111213int main() { constexpr int i = 42; // OK: 'i' is not odr-used auto f = [] { std::cout &lt;&lt; i &lt;&lt; '\\n'; }; f();}int main() { constexpr int i = 42; // ERROR: `i` is odr-used but not captured. auto f = [] { std::cout &lt;&lt; &amp;i &lt;&lt; '\\n'; }; f();} Besides, const int variable also can not be captured by lambda expression since const is implicit constexpr. 123456int main() { const int i = 42; // ERROR: `i` is odr-used but not captured. auto f = [] { std::cout &lt;&lt; &amp;i &lt;&lt; '\\n'; }; f();} If it has a const float not an integer type, therefore, this logic doesn’t apply. You must capture it if you want to use it inside the lambda. 12345int main() { const float f = 42; // ERROR: `f` is not captured. []{ std::cout &lt;&lt; f &lt;&lt; '\\n'; }();} The right way to use const float variable inside the lambda is as follows. 12345int main() { const float f = 42; // OK: `f` should be captured explicitly. [&amp;f] { std::cout &lt;&lt; f &lt;&lt; '\\n'; }();} Idiom 2: Immediately Invoked Function Expressions (IIFE)This idiom is so useful and it’s really practice and I think it can be useful in many situations. For example: What is Immediately Invoked Function Expressions? We don’t necessarily have to assign a lambda expression to a variable. So if we have a lambda expression hever, we can also instead just call it right there. This immediately invoked lambda are really useful. 123int main() { [] { std::cout &lt;&lt; &quot;Hello world\\n&quot;; }();} The following code is not a good practice for foo variable initialization. This if-else statement may introduce undefined behavior. Besides, if Foo class is not default-constructible, this code may not be compiled. The third issue is that if const Foo foo, we cannot assign to a const object using if-else statement. In java, if we use final keyword, this means foo variable is only be assigned once, so the following code could be compiled in java. But in C++, the const keyword means you only get to initialize it once and it has to be at the point where you declare it. So we have problem if we declare foo as const. 123456789101112int main() { // some code... const Foo foo; // Foo does not have default-constructible. if (hasDatabase) { // Error: cannot assign to const object. foo = getFooFromDatabase(); } else { // Error: cannot assign to const object. foo = getFooFromElsewhere(); }} Without lambda, we can use following method to solve this problem. But the code like this is ugly and unreadable. 12345int main() { const Foo foo = hasDatabase ? ? getFooFromDatabase() : getFooFromElsewhere();} The other method is that we can extract foo initialization process into a real function. This can split logic into other function, and initialization process is not localization anymore. If the initialization depends on local variables, you now have to pass these local variables as a parameter to function. So it all just gets messy. 1234567891011Foo getFoo() { if (hasDatabase) return getFooFromDatabase(); else return getFooFromElsewhere();}int main() { // some code... const Foo foo = getFoo();} If we use lambda, it should be great. Using immediately invoked lambda, you can just assign return value to foo, and this solves the problem. This also gets benefits for make_shared/make_unique all of that stuff. 123456789int main() { // some code... const Foo foo = [&amp;] { if (hasDatabase) return getFooFromDatabase(); else return getFooFromElsewhere(); }(); // immediately invoke lambda.} Using std::invoke function, it takes a function and calls it right away. This looks a little bit more visible because it’s like right there in the beginning. You actually could do more cool stuff with these immediately invoked lambdas. 12345678910int main() { // some code... std::vector&lt;Foo&gt; foos; foos.emplace_back(std::invoke([] { // since C++17 if (hasDatabase) return getFooFromDatabase(); else return getFooFromElsewhere(); }));} Idiom 3: Call-Once Lambda Daisy Hollman: “What you can learn from being too cute.” For example, here you have some kind of struct X and has a constructor. And you want to run this code when you construct an object but only once, and then never again. When we have more than one initialization calls, we still want this code bo only be called at the first time and never again. How you will do this? 12345678910struct X { X() { std::cout &lt;&lt; &quot;Called once!\\n&quot;; }};int main() { X x1; X x2; X x3; } Using static immediately invoked lambda, you can exactly only execute constructor once. Since C++11 if you initialize a static object, it’s guaranteed to be initialized exactly once. And this initialization is also thread safe. So which means you can actually initialize these X objects from multiple threads simultaneously, and you will still only call this constructor only once, and it’s going to be thread-safe. So the compiler will insert invisible locks to make sure it’s all thread-safe and to make sure that this code is only going to be called only once. There is one caveat here which is if you run this constructor a second time, there will be an implicit check which is some kind of atomic flag whether this has already been called yet in order to make sure that it’s not going to be called again. So this is going to be a little bit of a runtime overhead. 1234567891011121314struct X { X() { static auto _ = [] { std::cout &lt;&lt; &quot;Called once!\\n&quot;; return 0; } };();};int main() { X x1; X x2; X x3; } C++14 Generic LambdasWe can use auto keyword as lambda’s parameter type. This is really cool because the compiler is going to deduce the type for us. 12345678910111213std::map&lt;int, std::string&gt; httpErrors = { {400, &quot;Bad Request&quot;}, {401, &quot;Unauthorised&quot;}, {403, &quot;Forbidden&quot;}, {404, &quot;Not Found&quot;},};std::for_each( httpErrors.begin(), httpErrors.end(), [](const auto &amp;item) { std::cout &lt;&lt; item.first &lt;&lt; ':' &lt;&lt; item.second &lt;&lt; '\\n'; }); For example, if we have the following lambda code like this. 123[](auto i) { std::cout &lt;&lt; i &lt;&lt; '\\n';} After compiled this code, you may get the following closure. 123456789101112131415161718192021struct __lambda_6 { template &lt;typename T&gt; void operator()(T i) const { std::cout &lt;&lt; i &lt;&lt; '\\n'; } template &lt;typename T&gt; using __func_type = void(*)(T i); template &lt;typename T&gt; inline operator __func_type&lt;T&gt;() const noexcept { return &amp;__invoke&lt;T&gt;; } private: template &lt;typename T&gt; static void __invoke(T i) { std::cout &lt;&lt; i &lt;&lt; '\\n'; }};__lambda_6(); So if you write generic lambda, it creates a call operator which is a function template. Besides, if your lambda does not capture anyone, you can still get the implicit conversion to function pointer. But now that conversion operator is also going to be a template. However, the + operator doesn’t work anymore because the compiler literally does not know what type you need what type you’re trying to create here, what’s the concrete function pointer type, it’s not clear. So that’s not going to work. 123456int main() { // Error: can't deduce template argument. auto *fptr = +[](auto i) { return i * i; };} The another cool thing about generic lambda is that they support the perfect forwarding. So if you write the auto ref ref, that’s a forwarding reference. 1234std::vector&lt;std::string&gt; v;auto f [&amp;v](auto&amp;&amp; item) { v.push_back(std::forward&lt;decltype(item)&gt;(item));}; The compiler generates code is more or less like this. You get a function template calling operator. 123456789101112struct __lambda_7 { __lambda_7(std::vector&lt;std::string&amp; _v) : _v(v) {} template &lt;typename T&gt; void operator()(T&amp;&amp; item) const { __v.push_back(std::forward&lt;decltype(item)&gt;(item)); } private: std::vector&lt;std::string&gt;&amp; __v;}; It also supports variate lambdas. 123456auto f [](auto&amp;&amp;... args) { // Fold expression (since C+17). (std::cout &lt;&lt; ... &lt;&lt; args);};f(42, &quot;Hello&quot;, 1.5); Because you can use auto keyword, you can pass lambdas into other lambdas. You can have a lambda that takes another lambda as its argument using auto keyword. You can do many cool meta-programming stuff with this. 123456789auto twice = [](auto&amp;&amp; f) { return [=] { f(); f(); };};auto print_hihi = twice([] { std::cout &lt;&lt; &quot;hi&quot;;});print_hihi(); // hihi Idiom 4: Variable Template Lambda1234std::vector&lt;std::string&gt; v;auto f = [&amp;v](auto&amp;&amp; item) { v.push_back(std::forward&lt;decltype(item)&gt;(item));}; If you have a generic lambda, the call operator is going to be a template. 123456789101112struct __lambda_7 { __lambda_7(std::vector&lt;std::string&gt;&amp; _v) : _v(v) {} template &lt;typename T&gt; void operator()(T&amp;&amp; item) const { __v.push_back(std::forward&lt;decltype(item)&gt;(item)); } private: std::vector&lt;std::string&gt;&amp; __v;}; What if we could make the lambda itself also a template. That you can make a lambda a variable template and access the template parameter in it. We define a variable template, and then we assign a generic lambda to it, and now what happens conceptually? Your Code 1234template &lt;typename T&gt;constexpr auto c_cast = [](auto x) { return (T)x;}; Compiler 12345678910template &lt;typename T&gt;struct __lambda_9 { template &lt;typename U&gt; inline auto operator()(U x) const { return (T)x; }};template &lt;typename T&gt;auto c_cast = __lambda_9&lt;T&gt;(); Now we have a lambda template definition. Besides, we have a template call operator with different type of lambda template’s type since we use generic lambda. 123456789template &lt;typename T&gt;struct __lambda_9 { //... template &lt;typename U&gt; inline auto operator()(U x) const { // ... } //... }; This can be useful in a very particular scenario. 123456789101112131415161718192021222324using ms = std::chrono::milliseconds;using us = std::chrono::microseconds;using ns = std::chrono::nanoseconds;// we have a struct for storing a time point// for some reason we use a variant(like union).struct Time { std::variant&lt;ms, ns&gt; time; // this convert function takes a convert function // and applies it to the variant using std::visit. auto convert(const auto &amp;converter) { return std::visit(converter, time); }};int main() { Time t(ns(3000)); std::cout &lt;&lt; t.convert(std::chrono::duration_cast&lt;us&gt;).count(); // Error: This will get error since // `std::chrono::duration_cast&lt;&gt;` has three template parameters. // we cannot deduce the other two template parameters since // this duration_cast function is used as a argument // for other function.} We should specify conversion types for duration_cast using variable template. We can wrap the duration_cast into a helper struct. You can split template parameters into two parts: the template parameters that you should specify explicitly; the template parameters that should be deduced during callsite. So this is a good practice for splitting template parameters into two parts, and using a helper variable template to specify the explicit parameters and deduce the other template parameters. 123456789101112131415161718192021struct Time { std::variant&lt;ms, ns&gt; time; auto convert(const auto &amp;converter) { return std::visit(converter, time); }};template &lt;typename T&gt;constexpr auto duration_cast = [](auto d) { // The first template parameter is specified // explicitly. And the other two parameters // are deduced when this duration_cast // function called. return std::chrono::duration_cast&lt;T&gt;(d);};int main() { Time t(ns(3000)); // Works. std::cout &lt;&lt; t.convert(duration_cast&lt;us&gt;).count();} C++14 Init CaptureUsing Init Capture, we can capture some non-copyable object. Your Code 12345678910struct Widget {};auto ptr = std::make_unique&lt;Widget&gt;();// move happens here.auto f = [ptr = std::move(ptr)] { std::cout &lt;&lt; ptr.get() &lt;&lt; '\\n';};assert(ptr == nullptr); // assert passesf(); Compiler 12345678910111213struct __lambda_8 { __lambda_8(std::unique_ptr&lt;Widget&gt; _ptr) : __ptr(std::move(_ptr)) {} inline void operator()() const { std::cout &lt;&lt; __ptr.get() &lt;&lt; '\\n'; } private: // type deduced as if by 'auto' decl. std::unique_ptr&lt;Widget&gt; __ptr;};__lambda_8(std::move(ptr)); Idiom 5: Init Capture Optimization Reference Book: Bartlomiej Filipek: “C++ Lambda Story” 1234567891011121314const std::vector&lt;std::string&gt; vs = {&quot;apple&quot;, &quot;orange&quot;, &quot;foobar&quot;, &quot;lemon&quot;};const std::string prefix = &quot;foo&quot;;auto result = std::find_if( vs.begin(), vs.end(), [&amp;prefix](const std::string &amp;s) { return s == prefix + &quot;bar&quot;; });if (result != vs.end() std::cout &lt;&lt; prefix &lt;&lt; &quot;-something found!\\n&quot;; In the upper case, we concatenate a new string using prefix and &quot;bar&quot; in every loop iteration. But the result is always the same. So if we use the Init Capture, we can optimize this operation. The concatenation operation is performed only once. In this way, you saved a lot of CPU cycles because we can just do this operation once. 12345678910111213const std::vector&lt;std::string&gt; vs = {&quot;apple&quot;, &quot;orange&quot;, &quot;foobar&quot;, &quot;lemon&quot;};const std::string prefix = &quot;foo&quot;;auto result = std::find_if( vs.begin(), vs.end(), [str = prefix + &quot;bar&quot;](const std::string&amp; s) { return s == str; });if (result != vs.end()) std::cout &lt;&lt; prefix &lt;&lt; &quot;-something found!\\n&quot;; C++17 constexprIn C++17, we can use constexpr because you can execute them at compile time. The result of a lambda as a non-type template parameter. 12345auto f = []() constexpr { return sizeof(void*);};std::array&lt;int, f()&gt; arr = {}; Class Template Argument Deducton (CTAD)You don’t need to specify all template parameters since compiler can deduce these parameters. 12// std::vector&lt;int&gt; deduced.std::vector vec = {1, 2, 3, 4, 5, 6, 7}; Idiom 6: Lambda Overload SetThis is a very cool tool to have in your toolbox. If you want to create an object that is a callable object. So you can call it using the usual function called syntax, but it acts as an overload set. we also have a set of lambdas for overload. Because lambda is a struct type after compiler compile it. So you can inherit a lambda. This is really cool technique. You can do is you can write a variadic template which takes a bunch of template parameters by a bunch of types, and it’s going to inherit from all of these types. And then it’s going to use the call operator of all these types. So which means if you write using Ts operator. using Ts::operator()... means it’s kind of inheriting the call operators. The other interesting thing is that overload is an aggregate because it has no user-defined Constructors, it has no private members or anything like this, which means it’s an aggregate and the elements of the aggregate are the base classes. So what we can do is we can initialize an overload object with aggregate initialization using the braces. You can give it a bunch of lambdas, and those lambdas are going to be the base classes of that overload class, and it’s going to inherit the call operator from them. We also need to write a deduction guide which is like two more lines. 123456789101112131415161718template &lt;typename... Ts&gt;struct overload : Ts... { using Ts::operator()...;};// C++17 should declare a deduction guide,// C++20 doesn't need it anymore.template &lt;typename... Ts&gt;overload(Ts...) -&gt; overload&lt;Ts...&gt;;int main() { // aggregate initialization. overload f = { [](int f) { std::cout &lt;&lt; &quot;int thingy&quot;; }, [](float f) { std::cout &lt;&lt; &quot;float thingy&quot;; } }; } C++2012345678struct Widget { float x, y;};auto [x, y] = Widget();auto f = [=] { std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; '\\n';}; Lambda can capture parameter packs. 12345678910auto foo(auto... args) { std::cout &lt;&lt; sizeof...(args) &lt;&lt; '\\n';}template &lt;typename... Args&gt;auto delay_invoke_foo(Args... args) { return [args...]() -&gt; decltype(auto) { return foo(args...); };} Lambda can be constval. This means it can only be called at compile-time. 12345678auto f = [](int i) constval { return i * i;};f(5); // OK, constant expression.int x = 5;f(x); // Error: call to immediate function 'f' // is not a constant expression. Template Lambda123456std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};std::erase_if( data, // in generate lambda, you do not // need to specify types. [](auto i) { return i % 2; }); In C++20, you can explicitly use template lambda. 1234std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};std::erase_if( data, []&lt;typename T&gt;(T i) { return i % 2; }); Some interesting lambda expression features in C++20. Lambdas allowed in unevaluated contexts. Lambdas without captures are now: default-constructible assignable Before C++20, it is not possible to have a lambda be a data member of a class, because you cannot write this 12345class Widget { // Error: non-static data member // cannot be 'auto'. auto f = [] {};}; Since C++20, you can write a lambda in an undivided context like this using decltype. 123class Widget { decltype([]{}) f; // OK, since C++20}; This can be useful when 1234567template &lt;typename T&gt;using MyPtr = std::unique_ptr&lt;T, decltype([](T *t) { myDeleter(t); })&gt;;MyPtr&lt;Widget&gt; ptr; Some tricky questions.12345auto f1 = [] {};auto f2 = [] {};// f1 and f2 have different types since compiler// generates different struct closure for each// lambda respectively. 123auto f1 = [] {};auto f2 = f1;// f1 and f2 have the same type. 1234auto f1 = [] {};decltype(f1) f2;// f1 and f2 have the same type. Because there is// only one lambda type. 1234using t = decltype([] {});t f1;t f2;// f1 and f2 have the same type. 123decltype([] {}) f1;decltype([] {}) f2;// f1 and f2 have different lambda types. 12345678910template &lt;auto = []{}&gt; struct X {};X x1;X x2;// x1 and x2 have different types.// Because every time you define a lambda,// compiler will generate a new struct// closure, then there will be a different type. Idiom 7: Unique types generatorSince C++20. Idiom 8: Recursive LambdasNaive approach: 12345678910111213int main() { auto f = [](int i) { if (i == 0) return 1; // Error: 'f' declared with 'auto' // cannot appear in its own initializer! return i * f(i - 1); }; std::cout &lt;&lt; f(5) &lt;&lt; '\\n'; return 0;} Using std::function(Still not great). 12345678910int main() { std::function&lt;int(int)&gt; f = [&amp;](int i) { if (i == 0) return 1; return i * f(i - 1); }; std::cout &lt;&lt; f(5) &lt;&lt; '\\n'; return 0;} We cannot name the lambda within itself, but we can template it on the function that it’s going to be calling within itself. And then we can pass itself to itself like this. 1234567891011121314int main() { auto f = [](auto&amp;&amp; self, int i) { if (i == 0) return 1; // We can pass itself to itself like this. // But this looks awkward that this does not // look like a normal function call because // you always have to pass the lambda to itself // by argument. return i * self(self, i - 1); }; std::cout &lt;&lt; f(f, 5) &lt;&lt; '\\n'; // prints 120 return 0;} 123456789101112131415161718// C++ deducing this: it just worksint main() { // this is an implicit argument, we don't need to // pass it, we just call f act like a normal // function call. Because if the compiler is going // to be like you want to have this implicit first // parameter which is this pointer, let's deduce // what it is, let's deduce the type and now you // can name this parameter. That's a good convention // that's what python people use. This must be good. auto f = [](this auto&amp;&amp; self, int i) { if (i == 0) return 1; return i * self(i - 1); }; std::cout &lt;&lt; f(5) &lt;&lt; '\\n'; // prints 120 return 0;} Idiom 6 + 8: Recursive Lambda Overload Set Ben Deane: Deducing this patterns This is an example where you want to tree traversal. You have a binary tree. You are going to implement it as a variant. So every tree is either a leaf or a node, and it’s kind of recursive. And then what you want to traverse the tree you recursively and count the number of leaves. We can use the recursive lambda overload pattern here. Do this varient and we are going to have two lambdas here, one overload for the leaf, and one for the node, and if you have a node, you count the least by taking the left child and counting the leaves and taking the right child and counting leaves, so you are going to call it recursively. And the really cool thing here is that if you call this thing from within itself recursively using reducing this. Deducing this because it’s using the normal rules of function template argument deduction it’s going to deduce the fully derived like in so far as it s known at compile time, which in this case it is. So if you refer to self here, the self is not the lambda. The self is the fully derived type which is the whole overload set.This is a classic job interview question. So next time somebody wanted to implement tree traverse, you can write it like this and you can really impress your interviewer. This is only supported in Microsoft compiler. 12345678910111213141516171819202122232425struct Leaf {};struct Node;using Tree = std::variant&lt;Leaf, Node*&gt;;struct Node { Tree left, right;};template &lt;typename... Ts&gt;struct overload : Ts... { using Ts::operator()...; };// C++17 should define a guide deduction,// C++20 doesn't need it anymore.template &lt;typename... Ts&gt;overload(Ts...) -&gt; overload&lt;Ts...&gt;;int countLeaves(const Tree &amp;tree) { return std::visit(overload{ [](const Leaf&amp;) { return 1; }, [](this const auto &amp;self, const Node *node) -&gt; int { return visit(self, node-&gt;left) + visit(self, node-&gt;right); } }, tree); } References expr.prim.lambda Timur Audio’s Blog","link":"/2022/11/13/C-Lambda-Idioms/"},{"title":"Aggregate Initialization","text":"An aggregate is one of the following types: array type class type (typically, struct or union), that has no private or protected non-static data members no user-declared constructors no user-provided, inherited, or explicit constructors no user-declared or inherited constructors no virtual, private, or protected base classes no virtual member functions no default member initializers If we have a struct which has a single integer in it. We would need to do something like initialize the integer class member. If we use the C++03 standard, we must have a constructor for this initialization. The code is as follows. 123456789struct S { S(int s_i) : i(s_i) {} int i;};int main() { S s(1); return s.i;} Now the C++11, we were given the ability to do this uniform initialization syntax. So instead of doing a constructor, we can do this brace initialization syntax. And this works for however many elements you happen to have. 123456789101112struct S { int i; float f;};int main() { S s{1, 5.4f}; // We can see a truncation of the floating point value // 5.4 -&gt; 5 on the return statement from main here. return s.f;} Well, what happens when we introduce class hierarchy here. We have a base class. We get an error if we actually use inheritance from our struct S and that there is no matching constructor for initialization of s. Because we don’t have any way to initialize the base class. 12345678910111213141516struct B { double d;};struct S : B { int i; float f;};int main() { S s{1, 2.3}; // Error: no matching constructor for // initialization of 'S'. return s.f;} So what C++17 is giving us is the ability to explicitly specify that we want the base class initialized also. 1234567891011121314151617181920212223242526#include &lt;iostream&gt;struct B { double d;};struct S : B { int i; float f;};int main() { // Here, we use the default initialization of // the members of struct B. S s{{}, 1, 2.3}; // Here when we return d in base class B, we // return 0 since d is the default initialization. std::cout &lt;&lt; int(s.d) &lt;&lt; std::endl; // 0 // If we specify the value for d in base class B, // then we've got truncated value as we would expect. S s2{{54.3}, 1, 2.3}; std::cout &lt;&lt; int(s2.d) &lt;&lt; std::endl; // 54 return 0;} So we now have with our uniform initialization syntax a way of initializing base class objects Aggregate InitializationAggregate initialization, for example, an array initialize. So we could always initialize like this with a list initialization which is then going to perform aggreagte initialization. So list initialization means you have these braces. In C++20, we can now instead of the braces use parents which is direct initialization. 123// aggregate initializationint a1[]{1, 2, 3};int a1[](1, 2, 3); Why C++ committee do this? Because you couldn’t really perfect forward aggregates before C++20, that just wasn’t possible. Now you can implement emplace_back so now you can in-place aggregates in C++20. The other thing you can now do which is a little bit more like rare. You couldn’t really do aggregate initialization inside a macro because if you had inside the macro if you have curlies and then you have a comma in there the compiler would think that that’s then the next macro argument after the comma and then the puzzle will just explode. Now you can use parents so that actually compiles and now works since C++20. 1234567891011struct A { int i; bool b;};int main() { std::vector&lt;A&gt; v; v.emplace_back(42, true); // works since C++20 return 0;} Aggregate init inside a macro.123456789101112131415struct A { int i; bool b; bool isValid() const { return i == 42; }};int main() { // Error: parser explodes :( assert(A{42, true}.isValid()); // OK since C++20 assert(A(42, true).isValid()); return 0;} So introduce this feature, we solved two problems. Narrowing conversions.123456789struct A { int i; bool b;};// Error: narrowing conversion from 'double' to 'int'.A a1{42.5, true};// OKA a2(42.5, true); Brace elision. If you have a brace elision like that you have a nested aggregate. So you have an aggregate inside an aggregate. If you do curlys, you get brace solutions so you can basically do the flat right out the flat initializations and it’s going to recurse into the sub aggregates. But the parents doesn’t work. 123456789101112struct A { int i; bool b;};struct AA { A a1; A a2;};AA aa1{42, true, 43, false}; // OKAA aa1(42, true, 43, false); // Error Lifetime Extension of Temporary ObjectYou have a reference member, so what list initialization is going to do if you do aggregation via list initialization, it’s going to actually extend the lifetime of the reference if you initialize it with a temporary. 12345678910111213141516struct A { int&amp;&amp; i; bool b;};int main() { A a1{42, true}; // OK return a1.i; // returns 42 // If you use the parents, then you got // Dangling reference error, and then you // got a behavior and that is going to be // sad. A a2(42, true); // Dangling reference return a2.i; // Undefined behavior} Another case.If you have a struct A, which has one aggregation member, and have a non-aggregation member since struct C has a user-defined constructor. Then if you want to initialize this aggregate with a list initialization by just initialization both of these members. That works with curlys and works with parens. 123456789101112131415161718192021222324struct C { explicit C() = default;};struct A { int i; C c; // This is not aggregation member // since struct C has a user-defined // constructor.};auto a1 = A{42, C{}}; // OKauto a2 = A{42, C()}; // OK// Error: can't call explicit ctor.auto a3 = A{42};auto a4 = A(42);// Error: can't call explicit ctor.auto a5 = A{};// OK: value initialization,// NOT aggregate initialization!auto a6 = A(); auto a5 = A{}; is wrong, because you get an implicit initialized aggregate member, and if you do that with curlies, it is going to copy initialize that aggregate member as if by copy initialization from an empty braced init list. And copy initialization doesn’t work with explicit constructors, so you get a compiler error. auto a6 = A(); is OK. This is actually has a meaning, it has the meaning of value initialization since C++03, which is going to do zero initialization. This has the same meaning as before, so that’s going to just zero out the struct, and that’s fine. References Direct Aggregate Initialization - Timur Doumler C++17’s Aggregate Initializations Aggregate Initialization","link":"/2022/11/13/Aggregate-Initialization/"},{"title":"C++ learning lists","text":"Learning MaterialsDoneLambda Expression C++ Lambda Idioms - Timur Doumler - CppCon 2022 Type Traits Template Metaprogramming: Type Traits (part 1 of 2) - Jody Hagins - CppCon 2020 Template Metaprogramming: Type Traits (part 2 of 2) - Jody Hagins - CppCon 2020 Aggregate Initialization C++17’s Aggregate Initializations Lightning Talk: Direct Aggregate Initialisation - Timur Doumler - CppCon 2021 TODOSTL Algorithms 105 STL Algorithms in Less Than an Hour C++ Interview Questions C++ Interview Questions Some C++ Learning Materials C++ Learning Materials Debugger Tutorial Debugger Tutorial LLVM Learning Materials LLVM Learning Materials LLVM Tutor C++ Coroutines Understanding C++ COroutines By Example (1/2) Understanding C++ COroutines By Example (2/2) Currency - Mike Shah - CppCon 2021 A C++ Library for Parallelism and Concurrency Designing Classes Designing Classes (1/2) Designing Classes (2/2) Class Layout MISC The Right Way to Write C++ Code Design Patterns: Facts and Misconceptions Interpreter http://qingyunha.github.io/taotao/","link":"/2022/11/14/C-learning-lists/"},{"title":"C++ STL Overview","text":"STL algorithms can make code more expressive Raising levels of abstraction Sometimes, it can be spectacular. Avoid common mistakes off-by-one empty loops naive complexity When writing our own for-loops is about complexity. Some algorithms that they can be implemented naively in quadratic complexity, and in a more astute manner in a linear complexity. Used by lots of people A common vocabulary Whatever the version of your compiler Also, STL algorithms are used by billions of people every day. You don’t need to afraid of them. I think we should level up to STL algorithms and not the other way around.So even if you are running an older C++ version, you can still get most of the STL algorithms, like for example, if you are in C++03 for example, and you want to use all_of, any_of or none_of which appeared in C++11. Well you can just grab that code, and copy it into your codebase and just start using them. So most of them are within your reach whichever version of C++ you are on right now. Many more of the STL algorithms that let you express more nuance when you write your code. I’m going to show you something to illustrate the fact that there’s much more than for_each in the STL algorithms library. Here is the world of C++ STL algorithms The Queries means the stl algorithms which in this area just extract some piece of information, and they don’t actually modify it. The most of the stl algorithms would somehow change the collection, like sort or partition or whatever. But most of them are just read-only operations. HeapsA Heap is a data structure that looks like a tree, but that has a property is that every node must be smaller than its children. This is called max heap.So one extremely interesting property of the heap is taht we can squash it down into a range like below. std::make_heapWhen you do this, there is a nice property that it’s a range. So we can represent it with a vector, for example which is quite convenient to work with. And also, to go froma node to its left child, it is essentially taking its index and multiplying it by twos, nearly that. So it’s a way to represent a tree into a range. If you have a range, we have a beginning and an end and we can use STL algorithms.So first thing we can do is taking values that are not particularly a heap, and rearrange them so that they respect the heap property. We use std::make_heap to make a heap. We rearrange the element inside of a collection. This is our first algorithm. std::push_heapWhen we want to add a new value into a heap, we should move up the new value to right position in case to meet the heap criteria. When we squash the heap into a vector, we add something to the end, and then we need something to make it bubble its way up to its final position, and that is std::push_heap. std::pop_heapWhen we want to remove something from the heap. Usually we want to get the maximum value from this heap, std::pop_heap can be used to get this maximum value.To do this, we swap the first one and the last one. At this point, we need to make it bubble its way down to its final position, and that’s what pop_heap does. And if we want to remove, actually remove that value, we pop it back from the vector. If we pop each value from heap, then we get a sorted collection, and that is what std::sort_heap. SORTINGstd::sortRearrange the collection, and we get a sorted order collection. std::partial_sortNow if we only want to sort the beginning of a collection, this is a partial_sort. partial sort is kind of like a middle, something inside of the collection, and sorts the collection from the beginning to that point, and the rest is in unspecified order. std::nth_elementnth_element is a partial sorting algorithm that rearranges elements in [first, last). 123456789101112131415161718192021222324252627// Since C++20template &lt;typename RandomIt&gt;void nth_element(RandomIt first, RandomIt nth, RandomIt last);// Since C++20template &lt;typename RandomIt, typename Compare&gt;void nth_element(RandomIt first, RandomIt nth, RandomIt last, Cmpare comp);// Since C++17template &lt;typename ExecutionPolicy, typename RandomIt&gt;void nth_element(ExecutionPolicy&amp;&amp; policy, RandomIt first, RandomIt nth, RandomIt last);// Since C++20template &lt;typename RandomIt&gt;constexpr void nth_element(RandomIt first, RandomIt nth, RandomIt last);// Since C++17template &lt;typename ExecutionPolicy, typename RandomIt, typename Compare&gt;void nth_element(ExecutionPolicy&amp;&amp; policy, RandomIt first, RandomIt nth, RandomIt last, Compare comp); std::sort_heapstd::inplace_mergeinplace_merge is the incremental step in a merge sort. Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). 1234567891011// Since C++17template &lt;typename ExecutionPolicy, typename BidirIt&gt;void inplace_merge(ExecutionPolicy&amp;&amp; policy, BidirIt first, BidirIt middle, BidirIt last);// Since C++17template &lt;typename ExecutionPolicy, typename BidirIt, typename Compare&gt;void inplace_merge(ExecutionPolicy&amp;&amp; policy, BidirIt first, BidirIt middle, BidirIt last, Compare comp); PARTITIONINGTo partition a collection is to look at it through a predicate, something that returns a Boolean. If the blue is the predicates. The original collection is depicted as follows. Then we do partition, then the predicates are at the beginning, and other not-blue ones at the end. The border between the blue ones and the not-blue ones is called a partition point, that’s the end of the blue range and that’s also the beginning of the not blue range. PERMUTATIONSThe elements move around the collection, even if they don’t change value. std::rotate123456789// since C++11 and until C++20template &lt;typename ForwardIt&gt;ForwardIt rotate(ForwardIt first, ForwardIt n_first, ForwardIt last);// since C++17template &lt;typename ExecutionPolicy, class ForwardIt&gt;ForwardIt rotate(ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt n_first, ForwardIt last); Performs a left rotation on a range of elements. Specifically, std::rotate swaps the elements in the range[first, last) in such a way that the element n_first becomes the first element of the new range and n_first - 1 becomes the last element. std::shufflestd::shuffle is used to randomly change elements in a container. So std::shuffle takes a collection with elements in a certain order, and takes something that generates random numbers, and rearranges the collection in random order. std::next_permutation/std::prev_permutationGiven a collection of object, we can order them, order all their possible arrangements, and an intuitive way to see that is thinking about an alphabetical order. 123456789101112131415161718// until C++20template &lt;typename BidirIt&gt;bool next_permutation(BidirIt first, BidirIt last);// until C++20template &lt;typename BidirIt, typename Compare&gt;bool next_permutation(BidirIt first, BidirIt last, Compare comp);// since C++20template &lt;typename BidirIt&gt;constexpr bool next_permutation(BidirIt first, BidirIt last);// since C++20template &lt;typename BidirIt, typename Compare&gt;constexpr bool next_permutation(BidirIt first, BidirIt last, Compare comp); Permutes the range [first, last) into the next permutation, where the set of all permutations is ordered lexicographically with respect to operator &lt; or comp. Returns true if such a “next permutation” exists; otherwise transforms the range into the lexicographically first permutation (as if by std::sort(first, last, comp)) and returns false.That’s interesting for every possible arrangement of a collection, we can repeatedly call std::next_permutation until you’ve cycled back to the beginning. SECRET RUNESThe secret runes are things that you can combine with other algorithms to generate new algorithms. I called them runs because it’s like going to see runes to augment your powers and also because I find that kind of cool as a name. PARTITIONING-SORT-HEAPstable_* runeWhen we will see all the algorithm that go with the stable rune, so stable when you tack it onto an algorithm, it does what this algorithm does, but keep the relative order. Think std::partition for example, it put all the blue ones at the beginning that’s for sure, but maybe in the process, some of them got swapped around. With std::stable_partition, they all keep the same relative order. Same thing with std::stable_sort. 123stable_* ---&gt; stable_sort \\ --&gt; stable_partition is_* runeThe is_* rune checks for a predicate on the collection. We know what sort, partition, heap, means is_sort/is_partition/is_heap and returns a boolean. To indicate whether it’s a sorted/partitioned/heap that we are looking at. 123is_* -----| is_sorted | is_partitioned | is_heap is_*_untilis_*_until returns an iterator that’s the first position where that predicate doesn’t hold anymore. So for example, if we have a sorted collection, and then we call std::is_sorted_until we’ll get the end of that collection. 123is_*_until -----| is_sorted_until | is_partitioned_until | is_heap_until QUERIESSo one thing you can extract out of a collection is some sort of value. std::countFor example, the simplest one is probably std::count that takes a begin and an end a value, and returns how many times this value occurs in the collection. std::accumulate/(transform_)reduceThe accumulate makes some elements of the collection calling operator plus, or any custom function you’d pass it. In C++17, there’s std::reduce appeared, that does practically the same thing as accumulate, except it has a slightly different interface. It can accept to take no initial value, and it can also be run in parallel, but essentially, it’s the same as std::accumulate. std::transform_reduce takes a function and applies that function to the element of the collection before calling the reduce. std::partial_sumI think this is the pre-sum algorithm in std algorithms. 12345678910111213141516171819202122// until C++20template &lt;typename InputIt, typename OutputIt&gt;OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first);// until C++20template &lt;typename InputIt, typename OutputIt, typename BinaryOperation&gt;OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first, BinaryOperation op);// since C++20template &lt;typename InputIt, typename OutputIt&gt;OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first);// since C++20template &lt;typename InputIt, typename OutputIt, typename BinaryOperation&gt;constexpr OutputIt partial_sum(InputIt first, InputIt last, OutputIt d_first, BinaryOperation op); std::partial_sum, it sums the all the elements starting from the beginning to the current point of the collection. So here, partial_sum would return a collection with, in the first position, what was in the first position of the original collection. and the second one would plus the seco Computes the partial sums of the elements in the sub-ranges of the range[first, last) and writes them to the range beginning at d_dirst. This is equivalent operation: 12345*(d_first) = *first;*(d_first + 1) = *first + *(first + 1);*(d_first + 2) = *first + *(first + 1) + *(first + 2);*(d_first + 3) = *first + *(first + 1) + *(first + 2) + *(first + 3);// ... In C++17, there are std::(transform_)inclusive_scan and std::(transform_)exclusive_scan. inclusive_scan is the same thing as partial_sum, except it can run in parallel. exclusive_scan is the same as inclusive_scan, except it doesn’t include the current element. So for example, with exclusive_scan, the second value is the same to the first element of the original collection. The third would be one plus second, so-on and so-forth. 12345// *(d_first) = ;*(d_first + 1) = *first;*(d_first + 2) = *first + *(first + 1);*(d_first + 3) = *first + *(first + 1) + *(first + 2);// ...","link":"/2022/11/17/C-STL-Overview/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"CMake","slug":"CMake","link":"/tags/CMake/"},{"name":"Meta-Programming","slug":"Meta-Programming","link":"/tags/Meta-Programming/"},{"name":"LLVM","slug":"LLVM","link":"/tags/LLVM/"},{"name":"C++14","slug":"C-14","link":"/tags/C-14/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"C++17","slug":"C-17","link":"/tags/C-17/"},{"name":"C++20","slug":"C-20","link":"/tags/C-20/"},{"name":"STL","slug":"STL","link":"/tags/STL/"}],"categories":[],"pages":[{"title":"","text":"google-site-verification: google22665da6f1436b9d.html","link":"/google22665da6f1436b9d.html"},{"title":"about","text":"PROFILE Yuanjun RenSELF-ESTIMATION Proficiency in C + +, STL,Python; Proficient in the use of Linux operating system and shell programming; Familiar with Linux development environment, including VIM + GDB + GIT + C Make/Makefile and other development tools; EDUCATION Durations University Major Degree 2011/09 - 2014/04 China Academy of Aeronautics Science in Computational Aerodynamics Master 2007/09 - 2011/06 Beihang University Aircraft Design and Engineering Bachelor EXPERIENCE2022/02~ Present Company: Hexaflake Technology Co., Ltd. Position: GPU Compiler Development Engineer(Based on LLVM) 2018/03 - 2022/02 Company: Huawei Technologies Co., Ltd. Position: DSP Compiler Development Engineer(Based on LLVM) 2017/05 - 2018/03 Company: Xi’an Yongshengda Electronic Technology Co., Ltd. Position: C + + Development Engineer 2014/05 - 2017/04 Company: Aerodynamics Research Institute of Aviation Position: CFD Solver Development Engineer","link":"/about/index.html"}]}